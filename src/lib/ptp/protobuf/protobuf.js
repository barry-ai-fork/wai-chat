/**
 * DO NOT EDIT
 * -- this file is generated by minipbjs v0.2.5
 */

const protobuf = require("protobufjs/minimal") ;
protobuf.util.Long = require('long');
var $root = protobuf.roots;

// type system from protobuf
// notice: minimal build protobuf library does not contains 'types'
var $wires = protobuf.types ? protobuf.types.basic : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0, 'string': 2, 'bytes': 2 };
var $packed = protobuf.types ? protobuf.types.packed : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0 };
var $types = Object.keys($wires);

function invalid({ name, repeated, map, keyType }, expected) {
    return name + ': ' + expected + (repeated && expected !== 'array' ? '[]' : map && expected !== 'object' ? '{k:'+keyType+'}' : '') + ' expected';
}
var keyVerifyMap = { int32: 'key32Re', uint32: 'key32Re', sint32: 'key32Re', fixed32: 'key32Re', sfixed32: 'key32Re', int64: 'key64Re', uint64: 'key64Re', sint64: 'key64Re', fixed64: 'key64Re', sfixed64: 'key64Re', bool: 'key2Re' };
function verifyKey(type, message, fieldInfo) {
    if (keyVerifyMap[type]) {
        if (!protobuf.util[keyVerifyMap[type]].test(message)) {
            fieldInfo.keyType = type;
            return invalid(fieldInfo, 'key')
        }
        return null;
    }
    return null;
};
var type32Map = { int32: 1, uint32: 1, sint32: 1, fixed32: 1, sfixed32: 1 };
var type64Map = { int64: 1, uint64: 1, sint64: 1, fixed64: 1, sfixed64: 1 };
var floatOrDoubleMap = { float: 1, double: 1 };
var util = protobuf.util;

var $verifier = {
    '$': function(type, message, fieldInfo, field) {
        if (field === '$1') {
            fieldInfo.map = true;
            return verifyKey(type, message, fieldInfo);
        }
        // basic type
        if ($wires[type] !== undefined) {
            if (type32Map[type]) {
                if (typeof message !== 'number') return invalid(fieldInfo, 'number');
            } else if (type64Map[type]) {
                if (!util.isInteger(message) && !(message && util.isInteger(message.low) && util.isInteger(message.high))) {
                    return invalid(fieldInfo, 'integer|Long');
                }
            } else if (floatOrDoubleMap[type]) {
                if (typeof message !== 'number') return invalid(fieldInfo, 'float|double');
            } else if (type === 'bool') {
                if (typeof message !== 'boolean') return invalid(fieldInfo, 'boolean');
            } else if (type === 'string') {
                if (!util.isString(message)) return invalid(fieldInfo, 'string');
            } else if (type === 'bytes') {
                if(!(message && typeof message.length ==='number' || util.isString(message))) {
                    return invalid(fieldInfo, 'invalid bytes');
                }
            }
            return null;
        }
        if ($root[type].resolvedType) return $root[type].resolvedType[message] ? null : invalid(fieldInfo, 'enum value');
        return $root[type].verify(message);
    },
};
// wrappers
var $reader = {
    '$': function(type) {
        if ($reader[type]) {
            return $reader[type].call(this);
        }
        return $root[type].decode(this, this.uint32());
    }
}, $writer = {
    '$': function(type, message, id) {
        var wire = $wires[type];
        if (wire === undefined) {
            this.uint32((id << 3 | 2) >> 0).fork();
            return $root[type].encode(message, this).ldelim();
        }
        return $writer[type].call(this.uint32(id << 3 | wire), message);
    }
};

for (var i = 0; i < $types.length; i ++) {
    $reader[$types[i]] = protobuf.Reader.prototype[$types[i]];
    $writer[$types[i]] = protobuf.Writer.prototype[$types[i]];
}

function $createConverter(cfgs) {
    var converter = {};
    for (var i = 0; i < cfgs.length; i ++) {
        var cfg = cfgs[i];
        for (var j = 0; j < cfg.types.length; j ++) {
            converter[cfg.types[j]] = cfg.convf;
        }
    }
    return converter;
}

// fromObject
var $conv_object = $createConverter([
    {
        'types': [ 'bool' ],
        'convf': Boolean
    }, {
        'types': [ 'string' ],
        'convf': String
    }, {
        'types': [ 'float', 'double' ],
        'convf': Number
    }, {
        'types': [ 'uint32', 'fixed32' ],
        'convf': function(value) { return value >>> 0; }
    }, {
        'types': [ 'int32', 'sint32', 'sfixed32' ],
        'convf': function(value) { return value | 0; }
    }, {
        'types': [ 'int64', 'sint64', 'fixed64', 'sfixed64', 'uint64' ],
        'convf': function(value, type) {
            var ret = undefined;
            if (protobuf.util.Long) {
                ret = protobuf.util.Long.fromValue(value);
                ret.unsigned = type.charAt(0) === 'u';
            } else if (typeof value === 'object') {
                ret = new protobuf.util.LongBits(value.low >>> 0, value.high >>> 0).toNumber(type.charAt(0) === 'u');
            } else if (typeof value === 'string') {
                ret = parseInt(value, 10);
            } else if (typeof value === 'number') {
                ret = value;
            }
            return ret;
        }
    }, {
        'types': [ 'bytes' ],
        'convf': function(value, type) {
            var ret = undefined;
            if (typeof value === 'string') {
                ret = protobuf.util.newBuffer(protobuf.util.base64.length(value))
                protobuf.util.base64.decode(value, ret, 0);
            } else if (value.length) {
                ret = value;
            }
            return ret;
        }
    }, {
        'types': [ '$' ],
        'convf': function(value, type) {
            if ($conv_object[type]) {
                return $conv_object[type].call(null, value, type);
            } else if (!$root[type].fromObject) {
                // enum
                var ret = $root[type][value];
                return typeof ret === 'string' ? $root[type][ret] : ret;
            }
            return $root[type].fromObject(value);
        }
    }
]);

// toObject
var $conv_message = $createConverter([
    {
        'types': [ 'float', 'double' ],
        'convf': function(value, type, options) {
            return options.json && !isFinite(value) ? String(value) : value;
        }
    }, {
        'types': [ 'int64', 'sint64', 'fixed64', 'sfixed64', 'uint64' ],
        'convf': function(value, type, options) {
            if (typeof value === 'number') {
                return options.longs === String ? String(value) : value;
            }
            if (options.longs === String) {
                return protobuf.util.Long.prototype.toString.call(value);
            } else if (options.longs === Number) {
                return new protobuf.util.LongBits(value.low >>> 0, value.high >>> 0).toNumber(type.charAt(0) === 'u');
            }
            return value;
        }
    }, {
        'types': [ 'bytes' ],
        'convf': function(value, type, options) {
            if (options.bytes === String) {
                return protobuf.util.base64.encode(value, 0, value.length);
            } else if (options.bytes === Array) {
                return Array.prototype.slice.call(value);
            }
            if (Array.isArray(value)) {
                return protobuf.util.newBuffer(value);
            }
            return value;
        }
    }, {
        'types': [ '$' ],
        'convf': function(value, type, options) {
            if ($conv_message[type]) {
                return $conv_message[type].call(null, value, type, options);
            } else if ($wires[type] === undefined) {
                if ($root[type].toObject) {
                    return $root[type].toObject(value, options);
                }
                // enum
                return options.enums === String ? $root[type][value] : value;
            }
            return value;
        }
    }
]);

// namespace builder
(function _(namespace, path, parent, inner) {
    for (var i = 0, keys = Object.keys(namespace); i < keys.length; i ++) {
        var key = keys[i];
        if (namespace[key]['$'] && Object.keys(namespace[key]['$']).every(function(k) { return Number(k); })) {
            // protobuf.type
            if (parent[key]) throw Error('field ' + path + '.' + key + ' has already existed');
            parent[key] = function(payloads, key) {
                /**
                 * Constructor function wrapper for the all protobuf type.
                 * @constructor
                 * @param [props] Properties to set with
                 */
                function C(props) {
                    for (var id in payloads) {
                        var payload = payloads[id];
                        // initialize object/array fields
                        if (payload[1].charAt(0) === '{') {
                            this[payload[0]] = {};
                        } else if (payload[1].charAt(0) === '[' || payload[1].charAt(0) === '<') {
                            this[payload[0]] = [];
                            }
                        }
                        if (props) {
                            for (var keys = Object.keys(props), i = 0; i < keys.length; ++i) {
                                props[keys[i]] != null && (this[keys[i]] = props[keys[i]]);
                        }
                    }
                }

                // set prototypes and collect inner namespace for map fields
                var $namespace = {};
                for (var id in payloads) {
                    var payload = payloads[id];
                    var type = payload[1];
                    if (type.charAt(0) === '{') {
                        C.prototype[payload[0]] = protobuf.util.emptyObject;
                        // collect all map fields
                        // { key: value } => { '1': [ '$1', <key>, null ], '2': [ '$2', <value>, null ] }
                        $namespace[type] = {
                            '$': type.substring(1).split(',')
                                .map(function(t, i) { return ['$' + (i + 1), t, null] })
                                .reduce(function(m, o, i) { m[i + 1] = o; return m; }, {})
                        };
                    } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                        C.prototype[payload[0]] = protobuf.util.emptyArray;
                    } else if (type === 'bytes') {
                        C.prototype[payload[0]] = protobuf.util.newBuffer([]);
                    } else {
                        if (payload[2] && payload[2].hasOwnProperty('low') && payload[2].hasOwnProperty('high')) {
                            C.prototype[payload[0]] = protobuf.util.Long.fromBits(payload[2].low, payload[2].high, payload[2].unsigned);
                        } else {
                            C.prototype[payload[0]] = payload[2];
                        }
                    }
                }

                /**
                 * Creates a new instance using the specified properties.
                 * @function create
                 * @static
                 * @param [props] Properties to set with
                 * @returns {C} instance
                 */
                C.create = function(props) {
                    return new parent[key](props);
                };

                /**
                 * Decodes a message from the specified reader or buffer.
                 * @function decode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} length Message length if known beforehand
                 * @returns {C} instance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                C.decode = function(reader, length) {
                    if (!(reader instanceof protobuf.Reader)) reader = protobuf.Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length;
                    var message = new parent[key]();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        var id = tag >>> 3;
                        if (id > 0 && payloads[id]) {
                            var field = payloads[id][0];
                            var type = payloads[id][1];
                            if (type.charAt(0) === '{') {
                                // map field
                                if (message[field] === protobuf.util.emptyObject) {
                                    message[field] = {};
                                }
                                // decode map fields from inner namespace
                                var $message = parent[key].$namespace[type].decode(reader, reader.uint32());
                                message[field][$message['$1']] = $message['$2'];
                            } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                                // repeated field
                                type = type.substring(1);
                                if (!(message[field] && message[field].length)) {
                                    message[field] = [];
                                }
                                if ($packed[type] !== undefined && (tag & /*2^3-1=*/7) === 2) {
                                    // packed repeated
                                    var $end = reader.uint32() + reader.pos;
                                    while (reader.pos < $end) {
                                        message[field].push($reader['$'].call(reader, type));
                                    }
                                } else {
                                    message[field].push($reader['$'].call(reader, type));
                                }
                            } else {
                                // non-repeated field
                                message[field] = $reader['$'].call(reader, type);
                            }
                        } else {
                            // unknown field
                            reader.skipType(tag & /*2^3-1=*/7);
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} length Message length if known beforehand
                 * @returns {C} instance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                C.decodeDelimited = function(reader) {
                    if (!(reader instanceof protobuf.Reader)) reader = protobuf.Reader.create(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Encodes the specified C message. Does not implicitly verify messages.
                 * @function encode
                 * @static
                 * @param {C} message or plain object to encode
                 * @param {$protobuf.Writer} writer Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                C.encode = function(message, writer) {
                    if (!writer) writer = protobuf.Writer.create();
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        if (type.charAt(0) === '{') {
                            // map field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                for (var i = 0, keys = Object.keys(message[field]); i < keys.length; ++ i) {
                                    writer.uint32((id << 3 | 2) >> 0).fork();
                                    // encode map fields from inner namespace
                                    parent[key].$namespace[type].encode({ '$1': keys[i], '$2': message[field][keys[i]] }, writer).ldelim();
                                }
                            }
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            var packed = type.charAt(0) === '<';
                            type = type.substring(1);
                            var array = message[field];
                            if (array != null && array.length) {
                                if (packed && $packed[type] !== undefined) {
                                    // packed repeated
                                    writer.uint32((id << 3 | 2) >> 0).fork();
                                    for (var i = 0; i < array.length; i ++) {
                                        $writer[type].call(writer, array[i]);
                                    }
                                    writer.ldelim();
                                } else {
                                    for (var i = 0; i < array.length; i ++) {
                                        $writer['$'].call(writer, type, array[i], id);
                                    }
                                }
                            }
                        } else {
                            // non-repeated field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                $writer['$'].call(writer, type, message[field], id);
                            }
                        }
                    }
                    return writer;
                };

                /**
                 * Encodes the specified C message, length delimited. Does not implicitly verify messages.
                 * @function encode
                 * @static
                 * @param {C} message or plain object to encode
                 * @param {$protobuf.Writer} writer Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                C.encodeDelimited = function(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Creates a C message from plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @param {C} message
                 */
                C.fromObject = function(object) {
                    if (object instanceof parent[key]) return object;
                    var message = new parent[key]();
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        var property = object[field];
                        if (type.charAt(0) === '{') {
                            // map field
                            if (!property) continue;
                            if (typeof property !== 'object') throw TypeError(path + '.' + key + '.' + field + ': object expected');
                            var map = {};
                            var vtype = type.substring(1).split(',')[1];
                            for (var i = 0, keys = Object.keys(property); i < keys.length; ++ i) {
                                map[keys[i]] = $conv_object['$'].call(null, property[keys[i]], vtype);
                            }
                            message[field] = map;
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            if (!property) continue;
                            if (!Array.isArray(property)) throw TypeError(path + '.' + key + '.' + type + ': arary excepted');
                            var array = [];
                            type = type.substring(1);
                            for (var i = 0; i < property.length; i ++) {
                                array[i] = $conv_object['$'].call(null, property[i], type);
                            }
                            message[field] = array;
                        } else {
                            // non-repeated field
                            if (property != null) {
                                message[field] = $conv_object['$'].call(null, property, type);
                            }
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a C message. Also converts values to other types if specified.
                 * @function toObject
                 * @static
                 * @param {C} message protobuf message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                C.toObject = function(message, options) {
                    options = options || {};
                    var object = {};
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        var property = message[field];
                        if (type.charAt(0) === '{') {
                            // map field
                            if (options.objects || options.defaults) {
                                object[field] = {};
                            }
                            var keys = property ? Object.keys(property) : [];
                            if (keys.length) {
                                var map = {};
                                var vtype = type.substring(1).split(',')[1];
                                for (var i = 0; i < keys.length; i ++) {
                                    map[keys[i]] = $conv_message['$'].call(null, property[keys[i]], vtype, options);
                                }
                                object[field] = map;
                            }
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            if (options.arrays || options.defaults) {
                                object[field] = [];
                            }
                            if (property && property.length) {
                                var array = [];
                                type = type.substring(1);
                                for (var i = 0; i < property.length; i ++) {
                                    array[i] = $conv_message['$'].call(null, property[i], type, options);
                                }
                                object[field] = array;
                            }
                        } else {
                            // non-repeated field
                            // TODO support for Enum type
                            if (options.defaults) {
                                object[field] = $conv_message['$'].call(null, payloads[id][2], type, options);
                            }
                            if (property != null && message.hasOwnProperty(field)) {
                                object[field] = $conv_message['$'].call(null, property, type, options);
                            }
                        }
                    }
                    return object;
                };

                /**
                 * Converts this C to JSON.
                 * @function toJSON
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                C.prototype.toJSON = function() {
                    return this.constructor.toObject(this, protobuf.util.toJSONOptions);
                };

                /**
                 * Verifies C message.
                 * @function verify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                C.verify = function(message) {
                    if (typeof message !=='object' || message === null) return 'object expected'
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        var fieldName = path + '.' + key + '.' + field;
                        if (type.charAt(0) === '{') {
                            // map field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                if (!protobuf.util.isObject(message[field])) return invalid({ name: fieldName, map: true }, 'object');
                                var keys = Object.keys(message[field]);
                                for (var i = 0; i < keys.length; ++i) {
                                    parent[key].$namespace[type].$fieldName = fieldName
                                    var error = parent[key].$namespace[type].verify({ '$1': keys[i], '$2': message[field][keys[i]] });
                                    if (error) return error;
                                }
                            }
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            type = type.substring(1);
                            var array = message[field];
                            if (!Array.isArray(array)) {
                                return invalid({ name: fieldName, repeated: true }, 'array')
                            }
                            for (var i = 0; i < array.length; i ++) {
                                var error = $verifier['$'](type, array[i], { name: fieldName + '['+i+']' , repeated: true });
                                if (error) return error;
                            }
                        } else {
                            // non-repeated field
                            if (field === '$1' || field === '$2') fieldName = this.$fieldName;
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                var error = $verifier['$'](type, message[field], { name: fieldName }, field);
                                if (error) return error;
                            }
                        }
                    }
                    return null;
                };

                // create inner namespace for each map field
                if (Object.keys($namespace).length) {
                    C.$namespace = _($namespace, path + '.' + key, C.$namespace || {}, true);
                }

                return C;
            }(namespace[key]['$'], key);

            // exposing non-inner type to $root
            !inner && ($root[path + '.' + key] = parent[key]);
        } else if (namespace[key]['@'] && Object.values(namespace[key]['@']).every(function(v) { return Number(v) === v; })) {
            // protobuf.enum
            parent[key] = function(payloads, key) {
                var keys = Object.keys(payloads);
                var values = {};
                for (var i = 0; i < keys.length; i ++) {
                    values[values[keys[i]] = payloads[keys[i]]] = keys[i];
                }
                var vals = {};
                keys.forEach(function (i) { vals[values[i]] = 1; });
                values.resolvedType = vals;
                return values;
            }(namespace[key]['@'], key);
            // exposing non-inner enum to $root
            !inner && ($root[path + '.' + key] = parent[key]);
        }
        // delete parsed type and enum
        delete namespace[key]['$'];
        delete namespace[key]['@'];
        parent[key] = _(namespace[key], path ? path + '.' + key : key, parent[key] || {});
    }
    return parent;
})({
    default: {
        PTP: {
            Auth: {
                AuthLoginReq: {
                    '$': {"1":["sign","bytes",[]],"2":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"3":["uid","string",""],"4":["address","string",""]}
                },
                AuthLoginRes: {
                    '$': {"100":["err","uint32",0]}
                },
                AuthPreLoginReq: {
                    '$': {"1":["sign1","bytes",[]],"2":["address1","string",""],"3":["sign2","bytes",[]],"4":["address2","string",""],"5":["ts","uint64",{"low":0,"high":0,"unsigned":true}]}
                },
                AuthPreLoginRes: {
                    '$': {"1":["uid","string",""],"2":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"100":["err","uint32",0]}
                },
                AuthStep1Req: {
                    '$': {"1":["p","bytes",[]]}
                },
                AuthStep1Res: {
                    '$': {"1":["q","bytes",[]],"2":["address","string",""],"3":["sign","bytes",[]],"6":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"100":["err","uint32",0]}
                },
                AuthStep2Req: {
                    '$': {"1":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"2":["address","string",""],"3":["sign","bytes",[]]}
                },
                AuthStep2Res: {
                    '$': {"100":["err","uint32",0]}
                }
            },
            Chats: {
                LoadChatsReq: {
                    '$': {"1":["limit","uint32",0],"2":["offsetDate","uint32",0],"3":["archived","bool",false],"4":["withPinned","bool",false],"5":["lastLocalServiceMessage","string",""]}
                },
                LoadChatsRes: {
                    '$': {"1":["payload","string",""],"100":["err","uint32",0]}
                }
            },
            Common: {
                AUTH_TYPE: {
                    '@': {"AUTH_TYPE_USERNAME":0,"AUTH_TYPE_EMAIL":1,"AUTH_TYPE_MOBILE":2}
                },
                ERR: {
                    '@': {"NO_ERROR":0,"ERR_SYSTEM":1}
                }
            },
            Other: {
                OtherNotify: {
                    '$': {"100":["err","uint32",0]}
                }
            }
        }
    }
}, '', $root, false);

// exposing 'default' to global/window
protobuf.util.global['default'] = $root['default'];

//module.exports = protobuf.util.global['default']

export default protobuf.util.global['default'];
