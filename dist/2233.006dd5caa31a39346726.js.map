{"version":3,"file":"2233.006dd5caa31a39346726.js","mappings":"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","sources":["webpack://wai/./src/api/gramjs/apiBuilders/helpers.ts","webpack://wai/./src/api/gramjs/apiBuilders/messages.ts","webpack://wai/./src/api/gramjs/localDb.ts","webpack://wai/./src/api/gramjs/methods/media.ts","webpack://wai/./src/api/gramjs/methods/client.ts","webpack://wai/./src/api/gramjs/updater.ts","webpack://wai/./src/global/actions/api/chats.ts","webpack://wai/./src/global/actions/ui/calls.ts","webpack://wai/./src/global/reducers/calls.ts","webpack://wai/./src/lib/gramjs/client/uploadFile.ts","webpack://wai/./src/lib/gramjs/errors/index.js","webpack://wai/./src/lib/gramjs/tl/api.js","webpack://wai/./src/lib/ptp/protobuf/ActionCommands.ts","webpack://wai/./src/lib/ptp/protobuf/PTPAuth/AuthNativeReq.ts","webpack://wai/./src/lib/ptp/protobuf/PTPCommon/PbMsg.ts","webpack://wai/./src/lib/ptp/protobuf/PTPCommon/PbQrCode.ts","webpack://wai/./src/lib/ptp/protobuf/PTPCommon/PbUser.ts","webpack://wai/./src/lib/ptp/protobuf/PTPMsg/DownloadMsgReq.ts","webpack://wai/./src/lib/ptp/protobuf/PTPMsg/DownloadMsgRes.ts","webpack://wai/./src/lib/ptp/protobuf/PTPMsg/GenMsgIdReq.ts","webpack://wai/./src/lib/ptp/protobuf/PTPMsg/GenMsgIdRes.ts","webpack://wai/./src/lib/ptp/protobuf/PTPMsg/UploadMsgReq.ts","webpack://wai/./src/lib/ptp/protobuf/PTPUser/DownloadUserReq.ts","webpack://wai/./src/worker/msg/MsgCommand.ts","webpack://wai/./src/worker/msg/MsgCommandChatGpt.ts","webpack://wai/./src/lib/ptp/protobuf/PTPSync/SyncReq.ts","webpack://wai/./src/lib/ptp/protobuf/PTPSync/SyncRes.ts","webpack://wai/./src/worker/msg/MsgCommandSetting.ts","webpack://wai/./src/worker/msg/MsgDispatcher.ts","webpack://wai/./src/worker/msg/utils.ts","webpack://wai/./src/worker/share/utils/utils.ts"],"sourcesContent":["import type { Api as GramJs } from '../../../lib/gramjs';\n\ntype VirtualFields =\n  'flags'\n  | 'CONSTRUCTOR_ID'\n  | 'SUBCLASS_OF_ID'\n  | 'className'\n  | 'classType'\n  | 'getBytes';\n\nexport function bytesToDataUri(bytes: Buffer, shouldOmitPrefix = false, mimeType: string = 'image/jpeg') {\n  const prefix = shouldOmitPrefix ? '' : `data:${mimeType};base64,`;\n\n  return `${prefix}${btoa(String.fromCharCode(...bytes))}`;\n}\n\nexport function omitVirtualClassFields<T extends GramJs.VirtualClass<T> & { flags?: any }>(\n  instance: T,\n): Omit<T, VirtualFields> {\n  const {\n    flags,\n    CONSTRUCTOR_ID,\n    SUBCLASS_OF_ID,\n    className,\n    classType,\n    getBytes,\n    ...rest\n  } = instance;\n\n  return rest;\n}\n","import { Api as GramJs } from '../../../lib/gramjs';\nimport type {\n  ApiMessage,\n  ApiMessageForwardInfo,\n  ApiPhoto,\n  ApiSticker,\n  ApiVideo,\n  ApiVoice,\n  ApiAudio,\n  ApiDocument,\n  ApiAction,\n  ApiContact,\n  ApiAttachment,\n  ApiPoll,\n  ApiNewPoll,\n  ApiWebPage,\n  ApiMessageEntity,\n  ApiFormattedText,\n  ApiReplyKeyboard,\n  ApiKeyboardButton,\n  ApiChat,\n  ApiThreadInfo,\n  ApiInvoice,\n  ApiGroupCall,\n  ApiReactions,\n  ApiReactionCount,\n  ApiUserReaction,\n  ApiAvailableReaction,\n  ApiSponsoredMessage,\n  ApiUser,\n  ApiLocation,\n  ApiGame,\n  PhoneCallAction,\n  ApiWebDocument,\n  ApiMessageEntityDefault,\n  ApiMessageExtendedMediaPreview,\n  ApiReaction,\n  ApiReactionEmoji,\n} from '../../types';\nimport {\n  ApiMessageEntityTypes,\n} from '../../types';\n\nimport {\n  DELETED_COMMENTS_CHANNEL_ID,\n  LOCAL_MESSAGE_MIN_ID,\n  SERVICE_NOTIFICATIONS_USER_ID,\n  SPONSORED_MESSAGE_CACHE_MS,\n  SUPPORTED_AUDIO_CONTENT_TYPES,\n  SUPPORTED_IMAGE_CONTENT_TYPES,\n  SUPPORTED_VIDEO_CONTENT_TYPES,\n  VIDEO_MOV_TYPE,\n  VIDEO_WEBM_TYPE,\n} from '../../../config';\nimport { pick } from '../../../util/iteratees';\nimport { buildStickerFromDocument } from './symbols';\nimport { buildApiPhoto, buildApiPhotoSize, buildApiThumbnailFromStripped } from './common';\nimport { interpolateArray } from '../../../util/waveform';\nimport { buildPeer } from '../gramjsBuilders';\nimport { addPhotoToLocalDb, resolveMessageApiChatId, serializeBytes } from '../helpers';\nimport { buildApiPeerId, getApiChatIdFromMtpPeer, isPeerUser } from './peers';\nimport { buildApiCallDiscardReason } from './calls';\nimport { getEmojiOnlyCountForMessage } from '../../../global/helpers/getEmojiOnlyCountForMessage';\nimport { getServerTimeOffset } from '../../../util/serverTime';\n\nconst TIMESTAMP_BASE = 1676e9; // 2023-02-10\nconst TIMESTAMP_PRECISION = 1e2; // 0.1s\nconst LOCAL_MESSAGES_LIMIT = 1e6; // 1M\n\nconst LOCAL_MEDIA_UPLOADING_TEMP_ID = 'temp';\nconst INPUT_WAVEFORM_LENGTH = 63;\n\nlet localMessageCounter = LOCAL_MESSAGE_MIN_ID;\n\n// Local IDs need to be fractional to allow service notifications to be placed between real messages.\n// It also allows to avoid collisions when sending messages from multiple tabs due to timestamp-based whole part.\n// To support up to 1M local messages, the whole part must be below 8.5B (https://stackoverflow.com/a/57225494/903919).\n// The overflow will happen when `datePart` is >3.59B which will be in June 2034.\nexport function getNextLocalMessageId() {\n  const datePart = Math.round((Date.now() - TIMESTAMP_BASE) / TIMESTAMP_PRECISION);\n  return LOCAL_MESSAGE_MIN_ID + datePart + (++localMessageCounter / LOCAL_MESSAGES_LIMIT);\n}\n\nlet currentUserId!: string;\n\nexport function setMessageBuilderCurrentUserId(_currentUserId: string) {\n  currentUserId = _currentUserId;\n}\n\nexport function buildApiSponsoredMessage(mtpMessage: GramJs.SponsoredMessage): ApiSponsoredMessage | undefined {\n  const {\n    fromId, message, entities, startParam, channelPost, chatInvite, chatInviteHash, randomId, recommended,\n  } = mtpMessage;\n  const chatId = fromId ? getApiChatIdFromMtpPeer(fromId) : undefined;\n  const chatInviteTitle = chatInvite\n    ? (chatInvite instanceof GramJs.ChatInvite\n      ? chatInvite.title\n      : !(chatInvite.chat instanceof GramJs.ChatEmpty) ? chatInvite.chat.title : undefined)\n    : undefined;\n\n  return {\n    randomId: serializeBytes(randomId),\n    isBot: fromId ? isPeerUser(fromId) : false,\n    text: buildMessageTextContent(message, entities),\n    expiresAt: Math.round(Date.now() / 1000) + SPONSORED_MESSAGE_CACHE_MS,\n    isRecommended: Boolean(recommended),\n    ...(chatId && { chatId }),\n    ...(chatInviteHash && { chatInviteHash }),\n    ...(chatInvite && { chatInviteTitle }),\n    ...(startParam && { startParam }),\n    ...(channelPost && { channelPostId: channelPost }),\n  };\n}\n\nexport function buildApiMessage(mtpMessage: GramJs.TypeMessage): ApiMessage | undefined {\n  const chatId = resolveMessageApiChatId(mtpMessage);\n  if (\n    !chatId\n    || !(mtpMessage instanceof GramJs.Message || mtpMessage instanceof GramJs.MessageService)) {\n    return undefined;\n  }\n\n  return buildApiMessageWithChatId(chatId, mtpMessage);\n}\n\nexport function buildApiMessageFromShort(mtpMessage: GramJs.UpdateShortMessage): ApiMessage {\n  const chatId = buildApiPeerId(mtpMessage.userId, 'user');\n\n  return buildApiMessageWithChatId(chatId, {\n    ...mtpMessage,\n    fromId: buildPeer(mtpMessage.out ? currentUserId : buildApiPeerId(mtpMessage.userId, 'user')),\n  });\n}\n\nexport function buildApiMessageFromShortChat(mtpMessage: GramJs.UpdateShortChatMessage): ApiMessage {\n  const chatId = buildApiPeerId(mtpMessage.chatId, 'chat');\n\n  return buildApiMessageWithChatId(chatId, {\n    ...mtpMessage,\n    fromId: buildPeer(buildApiPeerId(mtpMessage.fromId, 'user')),\n  });\n}\n\nexport function buildApiMessageFromNotification(\n  notification: GramJs.UpdateServiceNotification,\n  currentDate: number,\n): ApiMessage {\n  const localId = getNextLocalMessageId();\n  const content = buildMessageContent(notification);\n\n  return {\n    id: localId,\n    chatId: SERVICE_NOTIFICATIONS_USER_ID,\n    date: notification.inboxDate || currentDate,\n    content,\n    isOutgoing: false,\n  };\n}\n\ntype UniversalMessage = (\n  Pick<GramJs.Message & GramJs.MessageService, ('id' | 'date')>\n  & Pick<Partial<GramJs.Message & GramJs.MessageService>, (\n    'out' | 'message' | 'entities' | 'fromId' | 'peerId' | 'fwdFrom' | 'replyTo' | 'replyMarkup' | 'post' |\n    'media' | 'action' | 'views' | 'editDate' | 'editHide' | 'mediaUnread' | 'groupedId' | 'mentioned' | 'viaBotId' |\n    'replies' | 'fromScheduled' | 'postAuthor' | 'noforwards' | 'reactions' | 'forwards' | 'silent'\n  )>\n);\n\nexport function buildApiMessageWithChatId(\n  chatId: string,\n  mtpMessage: UniversalMessage,\n): ApiMessage {\n  const fromId = mtpMessage.fromId ? getApiChatIdFromMtpPeer(mtpMessage.fromId) : undefined;\n  const peerId = mtpMessage.peerId ? getApiChatIdFromMtpPeer(mtpMessage.peerId) : undefined;\n  const isChatWithSelf = !fromId && chatId === currentUserId;\n  const isOutgoing = (mtpMessage.out && !mtpMessage.post) || (isChatWithSelf && !mtpMessage.fwdFrom);\n  const content = buildMessageContent(mtpMessage);\n  const action = mtpMessage.action\n    && buildAction(mtpMessage.action, fromId, peerId, Boolean(mtpMessage.post), isOutgoing);\n  if (action) {\n    content.action = action;\n  }\n\n  const isInvoiceMedia = mtpMessage.media instanceof GramJs.MessageMediaInvoice\n    && Boolean(mtpMessage.media.extendedMedia);\n\n  const {\n    replyToMsgId, replyToTopId, forumTopic, replyToPeerId,\n  } = mtpMessage.replyTo || {};\n  const isEdited = mtpMessage.editDate && !mtpMessage.editHide;\n  const {\n    inlineButtons, keyboardButtons, keyboardPlaceholder, isKeyboardSingleUse, isKeyboardSelective,\n  } = buildReplyButtons(mtpMessage, isInvoiceMedia) || {};\n  const forwardInfo = mtpMessage.fwdFrom && buildApiMessageForwardInfo(mtpMessage.fwdFrom, isChatWithSelf);\n  const { replies, mediaUnread: isMediaUnread, postAuthor } = mtpMessage;\n  const groupedId = mtpMessage.groupedId && String(mtpMessage.groupedId);\n  const isInAlbum = Boolean(groupedId) && !(content.document || content.audio || content.sticker);\n  const shouldHideKeyboardButtons = mtpMessage.replyMarkup instanceof GramJs.ReplyKeyboardHide;\n  const isHideKeyboardSelective = mtpMessage.replyMarkup instanceof GramJs.ReplyKeyboardHide\n    && mtpMessage.replyMarkup.selective;\n  const isProtected = mtpMessage.noforwards || isInvoiceMedia;\n  const isForwardingAllowed = !mtpMessage.noforwards;\n  const emojiOnlyCount = getEmojiOnlyCountForMessage(content, groupedId);\n\n  return {\n    id: mtpMessage.id,\n    chatId,\n    isOutgoing,\n    content,\n    date: mtpMessage.date,\n    senderId: fromId || (mtpMessage.out && mtpMessage.post && currentUserId) || chatId,\n    views: mtpMessage.views,\n    forwards: mtpMessage.forwards,\n    isFromScheduled: mtpMessage.fromScheduled,\n    isSilent: mtpMessage.silent,\n    reactions: mtpMessage.reactions && buildMessageReactions(mtpMessage.reactions),\n    ...(emojiOnlyCount && { emojiOnlyCount }),\n    ...(replyToMsgId && { replyToMessageId: replyToMsgId }),\n    ...(forumTopic && { isTopicReply: true }),\n    ...(replyToPeerId && { replyToChatId: getApiChatIdFromMtpPeer(replyToPeerId) }),\n    ...(replyToTopId && { replyToTopMessageId: replyToTopId }),\n    ...(forwardInfo && { forwardInfo }),\n    ...(isEdited && { isEdited }),\n    ...(mtpMessage.editDate && { editDate: mtpMessage.editDate }),\n    ...(isMediaUnread && { isMediaUnread }),\n    ...(mtpMessage.mentioned && isMediaUnread && { hasUnreadMention: true }),\n    ...(mtpMessage.mentioned && { isMentioned: true }),\n    ...(groupedId && {\n      groupedId,\n      isInAlbum,\n    }),\n    inlineButtons,\n    ...(keyboardButtons && {\n      keyboardButtons, keyboardPlaceholder, isKeyboardSingleUse, isKeyboardSelective,\n    }),\n    ...(shouldHideKeyboardButtons && { shouldHideKeyboardButtons, isHideKeyboardSelective }),\n    ...(mtpMessage.viaBotId && { viaBotId: buildApiPeerId(mtpMessage.viaBotId, 'user') }),\n    ...(replies && { repliesThreadInfo: buildThreadInfo(replies, mtpMessage.id, chatId) }),\n    ...(postAuthor && { postAuthorTitle: postAuthor }),\n    isProtected,\n    isForwardingAllowed,\n  };\n}\n\nexport function buildMessageReactions(reactions: GramJs.MessageReactions): ApiReactions {\n  const {\n    recentReactions, results, canSeeList,\n  } = reactions;\n\n  return {\n    canSeeList,\n    results: results.map(buildReactionCount).filter(Boolean).sort(reactionCountComparator),\n    recentReactions: recentReactions?.map(buildMessagePeerReaction).filter(Boolean),\n  };\n}\n\nfunction reactionCountComparator(a: ApiReactionCount, b: ApiReactionCount) {\n  const diff = b.count - a.count;\n  if (diff) return diff;\n  if (a.chosenOrder !== undefined && b.chosenOrder !== undefined) {\n    return a.chosenOrder - b.chosenOrder;\n  }\n  if (a.chosenOrder !== undefined) return 1;\n  if (b.chosenOrder !== undefined) return -1;\n  return 0;\n}\n\nfunction buildReactionCount(reactionCount: GramJs.ReactionCount): ApiReactionCount | undefined {\n  const { chosenOrder, count, reaction } = reactionCount;\n\n  const apiReaction = buildApiReaction(reaction);\n  if (!apiReaction) return undefined;\n\n  return {\n    chosenOrder,\n    count,\n    reaction: apiReaction,\n  };\n}\n\nexport function buildMessagePeerReaction(userReaction: GramJs.MessagePeerReaction): ApiUserReaction | undefined {\n  const {\n    peerId, reaction, big, unread,\n  } = userReaction;\n\n  const apiReaction = buildApiReaction(reaction);\n  if (!apiReaction) return undefined;\n\n  return {\n    userId: getApiChatIdFromMtpPeer(peerId),\n    reaction: apiReaction,\n    isUnread: unread,\n    isBig: big,\n  };\n}\n\nexport function buildApiReaction(reaction: GramJs.TypeReaction): ApiReaction | undefined {\n  if (reaction instanceof GramJs.ReactionEmoji) {\n    return {\n      emoticon: reaction.emoticon,\n    };\n  }\n\n  if (reaction instanceof GramJs.ReactionCustomEmoji) {\n    return {\n      documentId: reaction.documentId.toString(),\n    };\n  }\n\n  return undefined;\n}\n\nexport function buildApiAvailableReaction(availableReaction: GramJs.AvailableReaction): ApiAvailableReaction {\n  const {\n    selectAnimation, staticIcon, reaction, title,\n    inactive, aroundAnimation, centerIcon, effectAnimation, activateAnimation,\n    premium,\n  } = availableReaction;\n\n  return {\n    selectAnimation: buildApiDocument(selectAnimation),\n    activateAnimation: buildApiDocument(activateAnimation),\n    effectAnimation: buildApiDocument(effectAnimation),\n    staticIcon: buildApiDocument(staticIcon),\n    aroundAnimation: aroundAnimation ? buildApiDocument(aroundAnimation) : undefined,\n    centerIcon: centerIcon ? buildApiDocument(centerIcon) : undefined,\n    reaction: { emoticon: reaction } as ApiReactionEmoji,\n    title,\n    isInactive: inactive,\n    isPremium: premium,\n  };\n}\n\nexport function buildMessageContent(\n  mtpMessage: UniversalMessage | GramJs.UpdateServiceNotification,\n) {\n  let content: ApiMessage['content'] = {};\n\n  if (mtpMessage.media) {\n    content = {\n      ...buildMessageMediaContent(mtpMessage.media),\n    };\n  }\n\n  const hasUnsupportedMedia = mtpMessage.media instanceof GramJs.MessageMediaUnsupported;\n\n  if (mtpMessage.message && !hasUnsupportedMedia\n    && !content.sticker && !content.poll && !content.contact && !(content.video?.isRound)) {\n    content = {\n      ...content,\n      text: buildMessageTextContent(mtpMessage.message, mtpMessage.entities),\n    };\n  }\n\n  return content;\n}\n\nexport function buildMessageTextContent(\n  message: string,\n  entities?: GramJs.TypeMessageEntity[],\n): ApiFormattedText {\n  return {\n    text: message,\n    ...(entities && { entities: entities.map(buildApiMessageEntity) }),\n  };\n}\n\nexport function buildMessageDraft(draft: GramJs.TypeDraftMessage) {\n  if (draft instanceof GramJs.DraftMessageEmpty) {\n    return undefined;\n  }\n\n  const {\n    message, entities, replyToMsgId, date,\n  } = draft;\n\n  return {\n    formattedText: message ? buildMessageTextContent(message, entities) : undefined,\n    replyingToId: replyToMsgId,\n    date,\n  };\n}\n\nexport function buildMessageMediaContent(media: GramJs.TypeMessageMedia): ApiMessage['content'] | undefined {\n  if ('ttlSeconds' in media && media.ttlSeconds) {\n    return undefined;\n  }\n\n  if ('extendedMedia' in media && media.extendedMedia instanceof GramJs.MessageExtendedMedia) {\n    return buildMessageMediaContent(media.extendedMedia.media);\n  }\n\n  const sticker = buildSticker(media);\n  if (sticker) return { sticker };\n\n  const photo = buildPhoto(media);\n  if (photo) return { photo };\n\n  const video = buildVideo(media);\n  if (video) return { video };\n\n  const audio = buildAudio(media);\n  if (audio) return { audio };\n\n  const voice = buildVoice(media);\n  if (voice) return { voice };\n\n  const document = buildDocumentFromMedia(media);\n  if (document) return { document };\n\n  const contact = buildContact(media);\n  if (contact) return { contact };\n\n  const poll = buildPollFromMedia(media);\n  if (poll) return { poll };\n\n  const webPage = buildWebPage(media);\n  if (webPage) return { webPage };\n\n  const invoice = buildInvoiceFromMedia(media);\n  if (invoice) return { invoice };\n\n  const location = buildLocationFromMedia(media);\n  if (location) return { location };\n\n  const game = buildGameFromMedia(media);\n  if (game) return { game };\n\n  return undefined;\n}\n\nfunction buildApiMessageForwardInfo(fwdFrom: GramJs.MessageFwdHeader, isChatWithSelf = false): ApiMessageForwardInfo {\n  const savedFromPeerId = fwdFrom.savedFromPeer && getApiChatIdFromMtpPeer(fwdFrom.savedFromPeer);\n  const fromId = fwdFrom.fromId && getApiChatIdFromMtpPeer(fwdFrom.fromId);\n\n  return {\n    date: fwdFrom.date,\n    isImported: fwdFrom.imported,\n    isChannelPost: Boolean(fwdFrom.channelPost),\n    channelPostId: fwdFrom.channelPost,\n    isLinkedChannelPost: Boolean(fwdFrom.channelPost && savedFromPeerId && !isChatWithSelf),\n    fromChatId: savedFromPeerId || fromId,\n    fromMessageId: fwdFrom.savedFromMsgId || fwdFrom.channelPost,\n    senderUserId: fromId,\n    hiddenUserName: fwdFrom.fromName,\n    postAuthorTitle: fwdFrom.postAuthor,\n  };\n}\n\nfunction buildSticker(media: GramJs.TypeMessageMedia): ApiSticker | undefined {\n  if (\n    !(media instanceof GramJs.MessageMediaDocument)\n    || !media.document\n    || !(media.document instanceof GramJs.Document)\n  ) {\n    return undefined;\n  }\n\n  return buildStickerFromDocument(media.document, media.nopremium);\n}\n\nfunction buildPhoto(media: GramJs.TypeMessageMedia): ApiPhoto | undefined {\n  if (!(media instanceof GramJs.MessageMediaPhoto) || !media.photo || !(media.photo instanceof GramJs.Photo)) {\n    return undefined;\n  }\n\n  return buildApiPhoto(media.photo, media.spoiler);\n}\n\nexport function buildVideoFromDocument(document: GramJs.Document, isSpoiler?: boolean): ApiVideo | undefined {\n  if (document instanceof GramJs.DocumentEmpty) {\n    return undefined;\n  }\n\n  const {\n    id, mimeType, thumbs, size, attributes,\n  } = document;\n\n  // eslint-disable-next-line no-restricted-globals\n  if (mimeType === VIDEO_WEBM_TYPE && !(self as any).isWebmSupported) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line no-restricted-globals\n  if (mimeType === VIDEO_MOV_TYPE && !(self as any).isMovSupported) {\n    return undefined;\n  }\n\n  const videoAttr = attributes\n    .find((a: any): a is GramJs.DocumentAttributeVideo => a instanceof GramJs.DocumentAttributeVideo);\n\n  if (!videoAttr) {\n    return undefined;\n  }\n\n  const gifAttr = attributes\n    .find((a: any): a is GramJs.DocumentAttributeAnimated => a instanceof GramJs.DocumentAttributeAnimated);\n\n  const {\n    duration,\n    w: width,\n    h: height,\n    supportsStreaming = false,\n    roundMessage: isRound = false,\n  } = videoAttr;\n\n  return {\n    id: String(id),\n    mimeType,\n    duration,\n    fileName: getFilenameFromDocument(document, 'video'),\n    width,\n    height,\n    supportsStreaming,\n    isRound,\n    isGif: Boolean(gifAttr),\n    thumbnail: buildApiThumbnailFromStripped(thumbs),\n    size: size.toJSNumber(),\n    isSpoiler,\n  };\n}\n\nfunction buildVideo(media: GramJs.TypeMessageMedia): ApiVideo | undefined {\n  if (\n    !(media instanceof GramJs.MessageMediaDocument)\n    || !(media.document instanceof GramJs.Document)\n    || !media.document.mimeType.startsWith('video')\n  ) {\n    return undefined;\n  }\n\n  return buildVideoFromDocument(media.document, media.spoiler);\n}\n\nfunction buildAudio(media: GramJs.TypeMessageMedia): ApiAudio | undefined {\n  if (\n    !(media instanceof GramJs.MessageMediaDocument)\n    || !media.document\n    || !(media.document instanceof GramJs.Document)\n  ) {\n    return undefined;\n  }\n\n  const audioAttribute = media.document.attributes\n    .find((attr: any): attr is GramJs.DocumentAttributeAudio => (\n      attr instanceof GramJs.DocumentAttributeAudio\n    ));\n\n  if (!audioAttribute || audioAttribute.voice) {\n    return undefined;\n  }\n\n  const thumbnailSizes = media.document.thumbs && media.document.thumbs\n    .filter((thumb): thumb is GramJs.PhotoSize => thumb instanceof GramJs.PhotoSize)\n    .map((thumb) => buildApiPhotoSize(thumb));\n\n  return {\n    id: String(media.document.id),\n    fileName: getFilenameFromDocument(media.document, 'audio'),\n    thumbnailSizes,\n    size: media.document.size.toJSNumber(),\n    ...pick(media.document, ['mimeType']),\n    ...pick(audioAttribute, ['duration', 'performer', 'title']),\n  };\n}\n\nfunction buildVoice(media: GramJs.TypeMessageMedia): ApiVoice | undefined {\n  if (\n    !(media instanceof GramJs.MessageMediaDocument)\n    || !media.document\n    || !(media.document instanceof GramJs.Document)\n  ) {\n    return undefined;\n  }\n\n  const audioAttribute = media.document.attributes\n    .find((attr: any): attr is GramJs.DocumentAttributeAudio => (\n      attr instanceof GramJs.DocumentAttributeAudio\n    ));\n\n  if (!audioAttribute || !audioAttribute.voice) {\n    return undefined;\n  }\n\n  const { duration, waveform } = audioAttribute;\n\n  return {\n    id: String(media.document.id),\n    duration,\n    waveform: waveform ? Array.from(waveform) : undefined,\n  };\n}\n\nfunction buildDocumentFromMedia(media: GramJs.TypeMessageMedia) {\n  if (!(media instanceof GramJs.MessageMediaDocument) || !media.document) {\n    return undefined;\n  }\n\n  return buildApiDocument(media.document);\n}\n\nexport function buildApiDocument(document: GramJs.TypeDocument): ApiDocument | undefined {\n  if (!(document instanceof GramJs.Document)) {\n    return undefined;\n  }\n\n  const {\n    id, size, mimeType, date, thumbs, attributes,\n  } = document;\n\n  const thumbnail = thumbs && buildApiThumbnailFromStripped(thumbs);\n\n  let mediaType: ApiDocument['mediaType'] | undefined;\n  let mediaSize: ApiDocument['mediaSize'] | undefined;\n  const photoSize = thumbs && thumbs.find((s: any): s is GramJs.PhotoSize => s instanceof GramJs.PhotoSize);\n  if (photoSize) {\n    mediaSize = {\n      width: photoSize.w,\n      height: photoSize.h,\n    };\n\n    if (SUPPORTED_IMAGE_CONTENT_TYPES.has(mimeType)) {\n      mediaType = 'photo';\n\n      const imageAttribute = attributes\n        .find((a: any): a is GramJs.DocumentAttributeImageSize => a instanceof GramJs.DocumentAttributeImageSize);\n\n      if (imageAttribute) {\n        const { w: width, h: height } = imageAttribute;\n        mediaSize = {\n          width,\n          height,\n        };\n      }\n    } else if (SUPPORTED_VIDEO_CONTENT_TYPES.has(mimeType)) {\n      mediaType = 'video';\n      const videoAttribute = attributes\n        .find((a: any): a is GramJs.DocumentAttributeVideo => a instanceof GramJs.DocumentAttributeVideo);\n\n      if (videoAttribute) {\n        const { w: width, h: height } = videoAttribute;\n        mediaSize = {\n          width,\n          height,\n        };\n      }\n    }\n  }\n\n  return {\n    id: String(id),\n    size: size.toJSNumber(),\n    mimeType,\n    timestamp: date,\n    fileName: getFilenameFromDocument(document),\n    thumbnail,\n    mediaType,\n    mediaSize,\n  };\n}\n\nfunction buildContact(media: GramJs.TypeMessageMedia): ApiContact | undefined {\n  if (!(media instanceof GramJs.MessageMediaContact)) {\n    return undefined;\n  }\n\n  const {\n    firstName, lastName, phoneNumber, userId,\n  } = media;\n\n  return {\n    firstName, lastName, phoneNumber, userId: buildApiPeerId(userId, 'user'),\n  };\n}\n\nfunction buildPollFromMedia(media: GramJs.TypeMessageMedia): ApiPoll | undefined {\n  if (!(media instanceof GramJs.MessageMediaPoll)) {\n    return undefined;\n  }\n\n  return buildPoll(media.poll, media.results);\n}\n\nfunction buildInvoiceFromMedia(media: GramJs.TypeMessageMedia): ApiInvoice | undefined {\n  if (!(media instanceof GramJs.MessageMediaInvoice)) {\n    return undefined;\n  }\n\n  return buildInvoice(media);\n}\n\nfunction buildLocationFromMedia(media: GramJs.TypeMessageMedia): ApiLocation | undefined {\n  if (media instanceof GramJs.MessageMediaGeo) {\n    return buildGeo(media);\n  }\n\n  if (media instanceof GramJs.MessageMediaVenue) {\n    return buildVenue(media);\n  }\n\n  if (media instanceof GramJs.MessageMediaGeoLive) {\n    return buildGeoLive(media);\n  }\n\n  return undefined;\n}\n\nfunction buildGeo(media: GramJs.MessageMediaGeo): ApiLocation | undefined {\n  const point = buildGeoPoint(media.geo);\n  return point && { type: 'geo', geo: point };\n}\n\nfunction buildVenue(media: GramJs.MessageMediaVenue): ApiLocation | undefined {\n  const {\n    geo, title, provider, address, venueId, venueType,\n  } = media;\n  const point = buildGeoPoint(geo);\n  return point && {\n    type: 'venue',\n    geo: point,\n    title,\n    provider,\n    address,\n    venueId,\n    venueType,\n  };\n}\n\nfunction buildGeoLive(media: GramJs.MessageMediaGeoLive): ApiLocation | undefined {\n  const { geo, period, heading } = media;\n  const point = buildGeoPoint(geo);\n  return point && {\n    type: 'geoLive',\n    geo: point,\n    period,\n    heading,\n  };\n}\n\nfunction buildGeoPoint(geo: GramJs.TypeGeoPoint): ApiLocation['geo'] | undefined {\n  if (geo instanceof GramJs.GeoPointEmpty) return undefined;\n  const {\n    long, lat, accuracyRadius, accessHash,\n  } = geo;\n  return {\n    long,\n    lat,\n    accessHash: accessHash.toString(),\n    accuracyRadius,\n  };\n}\n\nfunction buildGameFromMedia(media: GramJs.TypeMessageMedia): ApiGame | undefined {\n  if (!(media instanceof GramJs.MessageMediaGame)) {\n    return undefined;\n  }\n\n  return buildGame(media);\n}\n\nfunction buildGame(media: GramJs.MessageMediaGame): ApiGame | undefined {\n  const {\n    id, accessHash, shortName, title, description, photo: apiPhoto, document: apiDocument,\n  } = media.game;\n\n  const photo = apiPhoto instanceof GramJs.Photo ? buildApiPhoto(apiPhoto) : undefined;\n  const document = apiDocument instanceof GramJs.Document ? buildApiDocument(apiDocument) : undefined;\n\n  return {\n    id: id.toString(),\n    accessHash: accessHash.toString(),\n    shortName,\n    title,\n    description,\n    photo,\n    document,\n  };\n}\n\nexport function buildPoll(poll: GramJs.Poll, pollResults: GramJs.PollResults): ApiPoll {\n  const { id, answers: rawAnswers } = poll;\n  const answers = rawAnswers.map((answer) => ({\n    text: answer.text,\n    option: serializeBytes(answer.option),\n  }));\n\n  return {\n    id: String(id),\n    summary: {\n      isPublic: poll.publicVoters,\n      ...pick(poll, [\n        'closed',\n        'multipleChoice',\n        'quiz',\n        'question',\n        'closePeriod',\n        'closeDate',\n      ]),\n      answers,\n    },\n    results: buildPollResults(pollResults),\n  };\n}\n\nexport function buildInvoice(media: GramJs.MessageMediaInvoice): ApiInvoice {\n  const {\n    description: text, title, photo, test, totalAmount, currency, receiptMsgId, extendedMedia,\n  } = media;\n\n  const preview = extendedMedia instanceof GramJs.MessageExtendedMediaPreview\n    ? buildApiMessageExtendedMediaPreview(extendedMedia) : undefined;\n\n  return {\n    title,\n    text,\n    photo: buildApiWebDocument(photo),\n    receiptMsgId,\n    amount: Number(totalAmount),\n    currency,\n    isTest: test,\n    extendedMedia: preview,\n  };\n}\n\nexport function buildPollResults(pollResults: GramJs.PollResults): ApiPoll['results'] {\n  const {\n    results: rawResults, totalVoters, recentVoters, solution, solutionEntities: entities, min,\n  } = pollResults;\n  const results = rawResults && rawResults.map(({\n    option, chosen, correct, voters,\n  }) => ({\n    isChosen: chosen,\n    isCorrect: correct,\n    option: serializeBytes(option),\n    votersCount: voters,\n  }));\n\n  return {\n    isMin: min,\n    totalVoters,\n    recentVoterIds: recentVoters?.map((id) => buildApiPeerId(id, 'user')),\n    results,\n    solution,\n    ...(entities && { solutionEntities: entities.map(buildApiMessageEntity) }),\n  };\n}\n\nexport function buildWebPage(media: GramJs.TypeMessageMedia): ApiWebPage | undefined {\n  if (\n    !(media instanceof GramJs.MessageMediaWebPage)\n    || !(media.webpage instanceof GramJs.WebPage)\n  ) {\n    return undefined;\n  }\n\n  const { id, photo, document } = media.webpage;\n\n  let video;\n  if (document instanceof GramJs.Document && document.mimeType.startsWith('video/')) {\n    video = buildVideoFromDocument(document);\n  }\n\n  return {\n    id: Number(id),\n    ...pick(media.webpage, [\n      'url',\n      'displayUrl',\n      'type',\n      'siteName',\n      'title',\n      'description',\n      'duration',\n    ]),\n    photo: photo instanceof GramJs.Photo ? buildApiPhoto(photo) : undefined,\n    document: !video && document ? buildApiDocument(document) : undefined,\n    video,\n  };\n}\n\nfunction buildAction(\n  action: GramJs.TypeMessageAction,\n  senderId: string | undefined,\n  targetPeerId: string | undefined,\n  isChannelPost: boolean,\n  isOutgoing: boolean,\n): ApiAction | undefined {\n  if (action instanceof GramJs.MessageActionEmpty) {\n    return undefined;\n  }\n\n  let phoneCall: PhoneCallAction | undefined;\n  let call: Partial<ApiGroupCall> | undefined;\n  let amount: number | undefined;\n  let currency: string | undefined;\n  let text: string;\n  const translationValues = [];\n  let type: ApiAction['type'] = 'other';\n  let photo: ApiPhoto | undefined;\n  let score: number | undefined;\n  let months: number | undefined;\n  let topicEmojiIconId: string | undefined;\n  let isTopicAction: boolean | undefined;\n\n  const targetUserIds = 'users' in action\n    ? action.users && action.users.map((id) => buildApiPeerId(id, 'user'))\n    : ('userId' in action && [buildApiPeerId(action.userId, 'user')]) || [];\n  let targetChatId: string | undefined;\n\n  if (action instanceof GramJs.MessageActionChatCreate) {\n    text = 'Notification.CreatedChatWithTitle';\n    translationValues.push('%action_origin%', action.title);\n    type = 'chatCreate';\n  } else if (action instanceof GramJs.MessageActionChatEditTitle) {\n    if (isChannelPost) {\n      text = 'Channel.MessageTitleUpdated';\n      translationValues.push(action.title);\n    } else {\n      text = 'Notification.ChangedGroupName';\n      translationValues.push('%action_origin%', action.title);\n    }\n  } else if (action instanceof GramJs.MessageActionChatEditPhoto) {\n    if (isChannelPost) {\n      text = 'Channel.MessagePhotoUpdated';\n    } else {\n      text = 'Notification.ChangedGroupPhoto';\n      translationValues.push('%action_origin%');\n    }\n  } else if (action instanceof GramJs.MessageActionChatDeletePhoto) {\n    if (isChannelPost) {\n      text = 'Channel.MessagePhotoRemoved';\n    } else {\n      text = 'Group.MessagePhotoRemoved';\n    }\n  } else if (action instanceof GramJs.MessageActionChatAddUser) {\n    if (!senderId || targetUserIds.includes(senderId)) {\n      text = 'Notification.JoinedChat';\n      translationValues.push('%target_user%');\n    } else {\n      text = 'Notification.Invited';\n      translationValues.push('%action_origin%', '%target_user%');\n    }\n  } else if (action instanceof GramJs.MessageActionChatDeleteUser) {\n    if (!senderId || targetUserIds.includes(senderId)) {\n      text = 'Notification.LeftChat';\n      translationValues.push('%target_user%');\n    } else {\n      text = 'Notification.Kicked';\n      translationValues.push('%action_origin%', '%target_user%');\n    }\n  } else if (action instanceof GramJs.MessageActionChatJoinedByLink) {\n    text = 'Notification.JoinedGroupByLink';\n    translationValues.push('%action_origin%');\n  } else if (action instanceof GramJs.MessageActionChannelCreate) {\n    text = 'Notification.CreatedChannel';\n  } else if (action instanceof GramJs.MessageActionChatMigrateTo) {\n    targetChatId = getApiChatIdFromMtpPeer(action);\n    text = 'Migrated to %target_chat%';\n    translationValues.push('%target_chat%');\n  } else if (action instanceof GramJs.MessageActionChannelMigrateFrom) {\n    targetChatId = getApiChatIdFromMtpPeer(action);\n    text = 'Migrated from %target_chat%';\n    translationValues.push('%target_chat%');\n  } else if (action instanceof GramJs.MessageActionPinMessage) {\n    text = 'Chat.Service.Group.UpdatedPinnedMessage1';\n    translationValues.push('%action_origin%', '%message%');\n  } else if (action instanceof GramJs.MessageActionHistoryClear) {\n    text = 'HistoryCleared';\n    type = 'historyClear';\n  } else if (action instanceof GramJs.MessageActionPhoneCall) {\n    const withDuration = Boolean(action.duration);\n    text = [\n      withDuration ? 'ChatList.Service' : 'Chat',\n      action.video ? 'VideoCall' : 'Call',\n      isOutgoing ? (withDuration ? 'outgoing' : 'Outgoing') : (withDuration ? 'incoming' : 'Incoming'),\n    ].join('.');\n\n    if (withDuration) {\n      const mins = Math.max(Math.round(action.duration! / 60), 1);\n      translationValues.push(`${mins} min${mins > 1 ? 's' : ''}`);\n    }\n\n    phoneCall = {\n      isOutgoing,\n      isVideo: action.video,\n      duration: action.duration,\n      reason: buildApiCallDiscardReason(action.reason),\n    };\n  } else if (action instanceof GramJs.MessageActionInviteToGroupCall) {\n    text = 'Notification.VoiceChatInvitation';\n    call = {\n      id: action.call.id.toString(),\n      accessHash: action.call.accessHash.toString(),\n    };\n    translationValues.push('%action_origin%', '%target_user%');\n  } else if (action instanceof GramJs.MessageActionContactSignUp) {\n    text = 'Notification.Joined';\n    translationValues.push('%action_origin%');\n    type = 'contactSignUp';\n  } else if (action instanceof GramJs.MessageActionPaymentSent) {\n    amount = Number(action.totalAmount);\n    currency = action.currency;\n    text = 'PaymentSuccessfullyPaid';\n    if (targetPeerId) {\n      targetUserIds.push(targetPeerId);\n    }\n    translationValues.push('%payment_amount%', '%target_user%', '%product%');\n  } else if (action instanceof GramJs.MessageActionGroupCall) {\n    if (action.duration) {\n      const mins = Math.max(Math.round(action.duration / 60), 1);\n      text = 'Notification.VoiceChatEnded';\n      translationValues.push(`${mins} min${mins > 1 ? 's' : ''}`);\n    } else {\n      text = 'Notification.VoiceChatStartedChannel';\n      call = {\n        id: action.call.id.toString(),\n        accessHash: action.call.accessHash.toString(),\n      };\n    }\n  } else if (action instanceof GramJs.MessageActionBotAllowed) {\n    text = 'Chat.Service.BotPermissionAllowed';\n    translationValues.push(action.domain);\n  } else if (action instanceof GramJs.MessageActionCustomAction) {\n    text = action.message;\n  } else if (action instanceof GramJs.MessageActionChatJoinedByRequest) {\n    text = 'ChatService.UserJoinedGroupByRequest';\n    translationValues.push('%action_origin%');\n  } else if (action instanceof GramJs.MessageActionGameScore) {\n    text = senderId === currentUserId ? 'ActionYouScoredInGame' : 'ActionUserScoredInGame';\n    translationValues.push('%score%');\n    score = action.score;\n  } else if (action instanceof GramJs.MessageActionWebViewDataSent) {\n    text = 'Notification.WebAppSentData';\n    translationValues.push(action.text);\n  } else if (action instanceof GramJs.MessageActionGiftPremium) {\n    text = isOutgoing ? 'ActionGiftOutbound' : 'ActionGiftInbound';\n    if (isOutgoing) {\n      translationValues.push('%gift_payment_amount%');\n    } else {\n      translationValues.push('%action_origin%', '%gift_payment_amount%');\n    }\n    if (targetPeerId) {\n      targetUserIds.push(targetPeerId);\n    }\n    currency = action.currency;\n    amount = action.amount.toJSNumber();\n    months = action.months;\n  } else if (action instanceof GramJs.MessageActionTopicCreate) {\n    text = 'TopicWasCreatedAction';\n    type = 'topicCreate';\n    translationValues.push(action.title);\n  } else if (action instanceof GramJs.MessageActionTopicEdit) {\n    if (action.closed !== undefined) {\n      text = action.closed ? 'TopicWasClosedAction' : 'TopicWasReopenedAction';\n      translationValues.push('%action_origin%', '%action_topic%');\n    } else if (action.hidden !== undefined) {\n      text = action.hidden ? 'TopicHidden2' : 'TopicShown';\n    } else if (action.title) {\n      text = 'TopicRenamedTo';\n      translationValues.push('%action_origin%', action.title);\n    } else if (action.iconEmojiId) {\n      text = 'TopicWasIconChangedToAction';\n      translationValues.push('%action_origin%', '%action_topic_icon%');\n      topicEmojiIconId = action.iconEmojiId.toString();\n    } else {\n      text = 'ChatList.UnsupportedMessage';\n    }\n    isTopicAction = true;\n  } else if (action instanceof GramJs.MessageActionAttachMenuBotAllowed) {\n    text = 'ActionAttachMenuBotAllowed';\n  } else if (action instanceof GramJs.MessageActionSuggestProfilePhoto) {\n    const isVideo = action.photo instanceof GramJs.Photo && action.photo.videoSizes?.length;\n    text = senderId === currentUserId\n      ? (isVideo ? 'ActionSuggestVideoFromYouDescription' : 'ActionSuggestPhotoFromYouDescription')\n      : (isVideo ? 'ActionSuggestVideoToYouDescription' : 'ActionSuggestPhotoToYouDescription');\n    type = 'suggestProfilePhoto';\n    translationValues.push('%target_user%');\n\n    if (targetPeerId) targetUserIds.push(targetPeerId);\n  } else {\n    text = 'ChatList.UnsupportedMessage';\n  }\n\n  if ('photo' in action && action.photo instanceof GramJs.Photo) {\n    addPhotoToLocalDb(action.photo);\n    photo = buildApiPhoto(action.photo);\n  }\n\n  return {\n    text,\n    type,\n    targetUserIds,\n    targetChatId,\n    photo, // TODO Only used internally now, will be used for the UI in future\n    amount,\n    currency,\n    translationValues,\n    call,\n    phoneCall,\n    score,\n    months,\n    topicEmojiIconId,\n    isTopicAction,\n  };\n}\n\nfunction buildReplyButtons(message: UniversalMessage, shouldSkipBuyButton?: boolean): ApiReplyKeyboard | undefined {\n  const { replyMarkup, media } = message;\n\n  // TODO Move to the proper button inside preview\n  if (!replyMarkup) {\n    if (media instanceof GramJs.MessageMediaWebPage && media.webpage instanceof GramJs.WebPage) {\n      if (media.webpage.type === 'telegram_message') {\n        return {\n          inlineButtons: [[{\n            type: 'url',\n            text: 'Show Message',\n            url: media.webpage.url,\n          }]],\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  // TODO\n  if (!(replyMarkup instanceof GramJs.ReplyKeyboardMarkup || replyMarkup instanceof GramJs.ReplyInlineMarkup)) {\n    return undefined;\n  }\n\n  const markup = replyMarkup.rows.map(({ buttons }) => {\n    return buttons.map((button): ApiKeyboardButton | undefined => {\n      const { text } = button;\n\n      if (button instanceof GramJs.KeyboardButton) {\n        return {\n          type: 'command',\n          text,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonUrl) {\n        if (button.url.includes('?startgroup=')) {\n          return {\n            type: 'unsupported',\n            text,\n          };\n        }\n\n        return {\n          type: 'url',\n          text,\n          url: button.url,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonCallback) {\n        if (button.requiresPassword) {\n          return {\n            type: 'unsupported',\n            text,\n          };\n        }\n\n        return {\n          type: 'callback',\n          text,\n          data: serializeBytes(button.data),\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonRequestPoll) {\n        return {\n          type: 'requestPoll',\n          text,\n          isQuiz: button.quiz,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonRequestPhone) {\n        return {\n          type: 'requestPhone',\n          text,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonBuy) {\n        if (media instanceof GramJs.MessageMediaInvoice && media.receiptMsgId) {\n          return {\n            type: 'receipt',\n            text: 'PaymentReceipt',\n            receiptMessageId: media.receiptMsgId,\n          };\n        }\n        if (shouldSkipBuyButton) return undefined;\n        return {\n          type: 'buy',\n          text,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonGame) {\n        return {\n          type: 'game',\n          text,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonSwitchInline) {\n        return {\n          type: 'switchBotInline',\n          text,\n          query: button.query,\n          isSamePeer: button.samePeer,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonUserProfile) {\n        return {\n          type: 'userProfile',\n          text,\n          userId: button.userId.toString(),\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonSimpleWebView) {\n        return {\n          type: 'simpleWebView',\n          text,\n          url: button.url,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonWebView) {\n        return {\n          type: 'webView',\n          text,\n          url: button.url,\n        };\n      }\n\n      if (button instanceof GramJs.KeyboardButtonUrlAuth) {\n        return {\n          type: 'urlAuth',\n          text,\n          url: button.url,\n          buttonId: button.buttonId,\n        };\n      }\n\n      return {\n        type: 'unsupported',\n        text,\n      };\n    }).filter(Boolean);\n  });\n\n  if (markup.every((row) => !row.length)) return undefined;\n\n  return {\n    [replyMarkup instanceof GramJs.ReplyKeyboardMarkup ? 'keyboardButtons' : 'inlineButtons']: markup,\n    ...(replyMarkup instanceof GramJs.ReplyKeyboardMarkup && {\n      keyboardPlaceholder: replyMarkup.placeholder,\n      isKeyboardSingleUse: replyMarkup.singleUse,\n      isKeyboardSelective: replyMarkup.selective,\n    }),\n  };\n}\n\nfunction getFilenameFromDocument(document: GramJs.Document, defaultBase = 'file') {\n  const { mimeType, attributes } = document;\n  const filenameAttribute = attributes\n    .find((a: any): a is GramJs.DocumentAttributeFilename => a instanceof GramJs.DocumentAttributeFilename);\n\n  if (filenameAttribute) {\n    return filenameAttribute.fileName;\n  }\n\n  const extension = mimeType.split('/')[1];\n\n  return `${defaultBase}${String(document.id)}.${extension}`;\n}\n\nexport function buildLocalMessage(\n  chat: ApiChat,\n  text?: string,\n  entities?: ApiMessageEntity[],\n  replyingTo?: number,\n  replyingToTopId?: number,\n  attachment?: ApiAttachment,\n  sticker?: ApiSticker,\n  gif?: ApiVideo,\n  poll?: ApiNewPoll,\n  contact?: ApiContact,\n  groupedId?: string,\n  scheduledAt?: number,\n  sendAs?: ApiChat | ApiUser,\n): ApiMessage {\n  const localId = getNextLocalMessageId();\n  const media = attachment && buildUploadingMedia(attachment);\n  const isChannel = chat.type === 'chatTypeChannel';\n  const isForum = chat.isForum;\n\n  const message = {\n    id: localId,\n    chatId: chat.id,\n    content: {\n      ...(text && {\n        text: {\n          text,\n          entities,\n        },\n      }),\n      ...media,\n      ...(sticker && { sticker }),\n      ...(gif && { video: gif }),\n      ...(poll && buildNewPoll(poll, localId)),\n      ...(contact && { contact }),\n    },\n    date: scheduledAt || Math.round(Date.now() / 1000) + getServerTimeOffset(),\n    isOutgoing: !isChannel,\n    senderId: sendAs?.id || currentUserId,\n    ...(replyingTo && { replyToMessageId: replyingTo }),\n    ...(replyingToTopId && { replyToTopMessageId: replyingToTopId }),\n    ...((replyingTo || replyingToTopId) && isForum && { isTopicReply: true }),\n    ...(groupedId && {\n      groupedId,\n      ...(media && (media.photo || media.video) && { isInAlbum: true }),\n    }),\n    ...(scheduledAt && { isScheduled: true }),\n    isForwardingAllowed: true,\n  } satisfies ApiMessage;\n\n  const emojiOnlyCount = getEmojiOnlyCountForMessage(message.content, message.groupedId);\n\n  return {\n    ...message,\n    ...(emojiOnlyCount && { emojiOnlyCount }),\n  };\n}\n\nexport function buildLocalForwardedMessage({\n  toChat,\n  toThreadId,\n  message,\n  scheduledAt,\n  noAuthors,\n  noCaptions,\n  isCurrentUserPremium,\n}: {\n  toChat: ApiChat;\n  toThreadId?: number;\n  message: ApiMessage;\n  scheduledAt?: number;\n  noAuthors?: boolean;\n  noCaptions?: boolean;\n  isCurrentUserPremium?: boolean;\n}): ApiMessage {\n  const localId = getNextLocalMessageId();\n  const {\n    content,\n    chatId: fromChatId,\n    id: fromMessageId,\n    senderId,\n    groupedId,\n    isInAlbum,\n  } = message;\n\n  const isAudio = content.audio;\n  const asIncomingInChatWithSelf = (\n    toChat.id === currentUserId && (fromChatId !== toChat.id || message.forwardInfo) && !isAudio\n  );\n  const shouldHideText = Object.keys(content).length > 1 && content.text && noCaptions;\n  const shouldDropCustomEmoji = !isCurrentUserPremium;\n  const strippedText = content.text?.entities && shouldDropCustomEmoji ? {\n    text: content.text.text,\n    entities: content.text.entities.filter((entity) => entity.type !== ApiMessageEntityTypes.CustomEmoji),\n  } : content.text;\n  const emojiOnlyCount = getEmojiOnlyCountForMessage(content, groupedId);\n\n  const updatedContent = {\n    ...content,\n    text: !shouldHideText ? strippedText : undefined,\n  };\n\n  return {\n    id: localId,\n    chatId: toChat.id,\n    content: updatedContent,\n    date: scheduledAt || Math.round(Date.now() / 1000) + getServerTimeOffset(),\n    isOutgoing: !asIncomingInChatWithSelf && toChat.type !== 'chatTypeChannel',\n    senderId: currentUserId,\n    sendingState: 'messageSendingStatePending',\n    groupedId,\n    isInAlbum,\n    isForwardingAllowed: true,\n    replyToTopMessageId: toThreadId,\n    ...(toThreadId && toChat?.isForum && { isTopicReply: true }),\n\n    ...(emojiOnlyCount && { emojiOnlyCount }),\n    // Forward info doesn't get added when users forwards his own messages, also when forwarding audio\n    ...(message.chatId !== currentUserId && !isAudio && !noAuthors && {\n      forwardInfo: {\n        date: message.date,\n        isChannelPost: false,\n        fromChatId,\n        fromMessageId,\n        senderUserId: senderId,\n      },\n    }),\n    ...(message.chatId === currentUserId && !noAuthors && { forwardInfo: message.forwardInfo }),\n    ...(scheduledAt && { isScheduled: true }),\n  };\n}\n\nfunction buildUploadingMedia(\n  attachment: ApiAttachment,\n): ApiMessage['content'] {\n  const {\n    filename: fileName,\n    blobUrl,\n    previewBlobUrl,\n    mimeType,\n    size,\n    audio,\n    shouldSendAsFile,\n    shouldSendAsSpoiler,\n  } = attachment;\n\n  if (!shouldSendAsFile) {\n    if (attachment.quick) {\n      // TODO Handle GIF as video, but support playback in <video>\n      if (SUPPORTED_IMAGE_CONTENT_TYPES.has(mimeType)) {\n        const { width, height } = attachment.quick;\n        return {\n          photo: {\n            id: LOCAL_MEDIA_UPLOADING_TEMP_ID,\n            sizes: [],\n            thumbnail: { width, height, dataUri: blobUrl },\n            blobUrl,\n            isSpoiler: shouldSendAsSpoiler,\n          },\n        };\n      }\n      if (SUPPORTED_VIDEO_CONTENT_TYPES.has(mimeType)) {\n        const { width, height, duration } = attachment.quick;\n        return {\n          video: {\n            id: LOCAL_MEDIA_UPLOADING_TEMP_ID,\n            mimeType,\n            duration: duration || 0,\n            fileName,\n            width,\n            height,\n            blobUrl,\n            ...(previewBlobUrl && { thumbnail: { width, height, dataUri: previewBlobUrl } }),\n            size,\n            isSpoiler: shouldSendAsSpoiler,\n          },\n        };\n      }\n    }\n    if (attachment.voice) {\n      const { duration, waveform } = attachment.voice;\n      const { data: inputWaveform } = interpolateArray(waveform, INPUT_WAVEFORM_LENGTH);\n      return {\n        voice: {\n          id: LOCAL_MEDIA_UPLOADING_TEMP_ID,\n          duration,\n          waveform: inputWaveform,\n        },\n      };\n    }\n    if (SUPPORTED_AUDIO_CONTENT_TYPES.has(mimeType)) {\n      const { duration, performer, title } = audio || {};\n      return {\n        audio: {\n          id: LOCAL_MEDIA_UPLOADING_TEMP_ID,\n          mimeType,\n          fileName,\n          size,\n          duration: duration || 0,\n          title,\n          performer,\n        },\n      };\n    }\n  }\n  return {\n    document: {\n      mimeType,\n      fileName,\n      size,\n      ...(previewBlobUrl && { previewBlobUrl }),\n    },\n  };\n}\n\nexport function buildApiMessageExtendedMediaPreview(\n  preview: GramJs.MessageExtendedMediaPreview,\n): ApiMessageExtendedMediaPreview {\n  const {\n    w, h, thumb, videoDuration,\n  } = preview;\n\n  return {\n    width: w,\n    height: h,\n    duration: videoDuration,\n    thumbnail: thumb ? buildApiThumbnailFromStripped([thumb]) : undefined,\n  };\n}\n\nexport function buildApiWebDocument(document?: GramJs.TypeWebDocument): ApiWebDocument | undefined {\n  if (!document) return undefined;\n\n  const {\n    url, size, mimeType,\n  } = document;\n  const accessHash = document instanceof GramJs.WebDocument ? document.accessHash.toString() : undefined;\n  const sizeAttr = document.attributes.find((attr): attr is GramJs.DocumentAttributeImageSize => (\n    attr instanceof GramJs.DocumentAttributeImageSize\n  ));\n  const dimensions = sizeAttr && { width: sizeAttr.w, height: sizeAttr.h };\n\n  return {\n    url,\n    accessHash,\n    size,\n    mimeType,\n    dimensions,\n  };\n}\n\nfunction buildNewPoll(poll: ApiNewPoll, localId: number) {\n  return {\n    poll: {\n      id: String(localId),\n      summary: pick(poll.summary, ['question', 'answers']),\n      results: {},\n    },\n  };\n}\n\nexport function buildApiMessageEntity(entity: GramJs.TypeMessageEntity): ApiMessageEntity {\n  const {\n    className: type, offset, length,\n  } = entity;\n\n  if (entity instanceof GramJs.MessageEntityMentionName) {\n    return {\n      type: ApiMessageEntityTypes.MentionName,\n      offset,\n      length,\n      userId: buildApiPeerId(entity.userId, 'user'),\n    };\n  }\n\n  if (entity instanceof GramJs.MessageEntityTextUrl) {\n    return {\n      type: ApiMessageEntityTypes.TextUrl,\n      offset,\n      length,\n      url: entity.url,\n    };\n  }\n\n  if (entity instanceof GramJs.MessageEntityPre) {\n    return {\n      type: ApiMessageEntityTypes.Pre,\n      offset,\n      length,\n      language: entity.language,\n    };\n  }\n\n  if (entity instanceof GramJs.MessageEntityCustomEmoji) {\n    return {\n      type: ApiMessageEntityTypes.CustomEmoji,\n      offset,\n      length,\n      documentId: entity.documentId.toString(),\n    };\n  }\n\n  return {\n    type: type as `${ApiMessageEntityDefault['type']}`,\n    offset,\n    length,\n  };\n}\n\nfunction buildThreadInfo(\n  messageReplies: GramJs.TypeMessageReplies, messageId: number, chatId: string,\n): ApiThreadInfo | undefined {\n  const {\n    channelId, replies, maxId, readMaxId, recentRepliers, comments,\n  } = messageReplies;\n\n  const apiChannelId = channelId ? buildApiPeerId(channelId, 'channel') : undefined;\n  if (apiChannelId === DELETED_COMMENTS_CHANNEL_ID) {\n    return undefined;\n  }\n\n  const isPostThread = apiChannelId && chatId !== apiChannelId;\n\n  return {\n    isComments: comments,\n    threadId: messageId,\n    ...(isPostThread ? {\n      chatId: apiChannelId,\n      originChannelId: chatId,\n    } : {\n      chatId,\n    }),\n    messagesCount: replies,\n    lastMessageId: maxId,\n    lastReadInboxMessageId: readMaxId,\n    ...(recentRepliers && { recentReplierIds: recentRepliers.map(getApiChatIdFromMtpPeer) }),\n  };\n}\n\nexport function buildApiFormattedText(textWithEntities: GramJs.TextWithEntities): ApiFormattedText {\n  const { text, entities } = textWithEntities;\n\n  return {\n    text,\n    entities: entities.map(buildApiMessageEntity),\n  };\n}\n","import BigInt from 'big-integer';\nimport type { Api as GramJs } from '../../lib/gramjs';\nimport type { ApiMessage } from '../types';\nimport { omitVirtualClassFields } from './apiBuilders/helpers';\nimport { DATA_BROADCAST_CHANNEL_NAME } from '../../config';\nimport { constructors } from '../../lib/gramjs/tl';\nimport { throttle } from '../../util/schedulers';\n\n// eslint-disable-next-line no-restricted-globals\nconst IS_MULTITAB_SUPPORTED = 'BroadcastChannel' in self;\n\nexport interface LocalDb {\n  localMessages: Record<string, ApiMessage>;\n  // Used for loading avatars and media through in-memory Gram JS instances.\n  chats: Record<string, GramJs.Chat | GramJs.Channel>;\n  users: Record<string, GramJs.User>;\n  messages: Record<string, GramJs.Message | GramJs.MessageService>;\n  documents: Record<string, GramJs.Document>;\n  stickerSets: Record<string, GramJs.StickerSet>;\n  photos: Record<string, GramJs.Photo>;\n  webDocuments: Record<string, GramJs.TypeWebDocument>;\n  cache: Record<string,any>;\n  botWaitReply: Record<string, undefined | {\n    command:string,\n    payload?:Record<string,any>\n  }>;\n}\n\nconst channel = IS_MULTITAB_SUPPORTED ? new BroadcastChannel(DATA_BROADCAST_CHANNEL_NAME) : undefined;\n\nlet batchedUpdates: {\n  name: string;\n  prop: string;\n  value: any;\n}[] = [];\nconst throttledLocalDbUpdate = throttle(() => {\n  channel!.postMessage({\n    type: 'localDbUpdate',\n    batchedUpdates,\n  });\n  batchedUpdates = [];\n}, 100);\n\nfunction createProxy(name: string, object: any) {\n  return new Proxy(object, {\n    get(target, prop: string, value: any) {\n      return Reflect.get(target, prop, value);\n    },\n    set(target, prop: string, value: any) {\n      batchedUpdates.push({ name, prop, value });\n      throttledLocalDbUpdate();\n      return Reflect.set(target, prop, value);\n    },\n  });\n}\n\nfunction convertToVirtualClass(value: any): any {\n  if (value instanceof Uint8Array) return Buffer.from(value);\n  if (typeof value === 'object' && Object.keys(value).length === 1 && Object.keys(value)[0] === 'value') {\n    return BigInt(value.value);\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(convertToVirtualClass);\n  }\n\n  if (typeof value !== 'object' || !('CONSTRUCTOR_ID' in value)) {\n    return value;\n  }\n  const path = value.className.split('.');\n  const VirtualClass = path.reduce((acc: any, field: string) => {\n    return acc[field];\n  }, constructors);\n\n  const valueOmited = omitVirtualClassFields(value);\n  const valueConverted = Object.keys(valueOmited).reduce((acc, key) => {\n    acc[key] = convertToVirtualClass(valueOmited[key]);\n    return acc;\n  }, {} as Record<string, any>);\n\n  return new VirtualClass(valueConverted);\n}\n\nfunction createLocalDbInitial(initial?: LocalDb): LocalDb {\n  return [\n    'localMessages', 'chats', 'users', 'messages', 'documents', 'stickerSets', 'photos', 'webDocuments','cache','botWaitReply',\n  ]\n    .reduce((acc: Record<string, any>, key) => {\n      const value = initial?.[key as keyof LocalDb] ?? {};\n      const valueVirtualClass = Object.keys(value).reduce((acc2, key2) => {\n        acc2[key2] = convertToVirtualClass(value[key2]);\n        return acc2;\n      }, {} as Record<string, any>);\n\n      acc[key] = IS_MULTITAB_SUPPORTED\n        ? createProxy(key, valueVirtualClass)\n        : valueVirtualClass;\n      return acc;\n    }, {} as LocalDb) as LocalDb;\n}\n\nconst localDb: LocalDb = createLocalDbInitial();\n\nexport default localDb;\n\nexport function broadcastLocalDbUpdateFull() {\n  if (!channel) return;\n\n  channel.postMessage({\n    type: 'localDbUpdateFull',\n    localDb: Object.keys(localDb).reduce((acc: Record<string, any>, key) => {\n      acc[key] = { ...localDb[key as keyof LocalDb] };\n      return acc;\n    }, {} as Record<string, any>),\n  });\n}\n\nexport function updateFullLocalDb(initial: LocalDb) {\n  Object.assign(localDb, createLocalDbInitial(initial));\n}\n\nexport function clearLocalDb() {\n  Object.assign(localDb, createLocalDbInitial());\n}\n","import type {TelegramClient} from '../../../lib/gramjs';\nimport {Api as GramJs} from '../../../lib/gramjs';\nimport type {ApiOnProgress, ApiParsedMedia} from '../../types';\nimport {ApiMediaFormat,} from '../../types';\n\nimport {\n  CLOUD_MESSAGE_API, CLOUD_MESSAGE_ENABLE,\n  DOWNLOAD_WORKERS,\n  MEDIA_CACHE_DISABLED,\n  MEDIA_CACHE_MAX_BYTES,\n  MEDIA_CACHE_NAME,\n  MEDIA_CACHE_NAME_AVATARS,\n} from '../../../config';\nimport localDb from '../localDb';\nimport * as cacheApi from '../../../util/cacheApi';\nimport {getEntityTypeById} from '../gramjsBuilders';\nimport {DownloadReq, DownloadRes} from \"../../../lib/ptp/protobuf/PTPFile\";\nimport {ERR} from \"../../../lib/ptp/protobuf/PTPCommon/types\";\nimport {Pdu} from \"../../../lib/ptp/protobuf/BaseMsg\";\n\nconst MEDIA_ENTITY_TYPES = new Set([\n  'msg', 'sticker', 'gif', 'wallpaper', 'photo', 'webDocument', 'document', 'videoAvatar',\n]);\n\n\nasync function fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = () => {\n      resolve(reader.result as ArrayBuffer);\n    };\n\n    reader.onerror = () => {\n      reject(reader.error);\n    };\n\n    reader.readAsArrayBuffer(file);\n  });\n}\n\nexport default async function downloadMedia(\n  {\n    url, mediaFormat, start, end, isHtmlAllowed,\n  }: {\n    url: string; mediaFormat: ApiMediaFormat; start?: number; end?: number; isHtmlAllowed?: boolean;\n  },\n  client: TelegramClient,\n  isConnected: boolean,\n  onProgress?: ApiOnProgress,\n) {\n  let data:Buffer,fullSize:number,blob:Blob,mimeType:string;\n  let flag = false;\n  let id;\n  const t = url.split(\"?\")\n  const t1 = t[0].split(\":\");\n  if(url.indexOf(\"progressive\") > 0 || t1[0].indexOf(\"-\") > 1){\n    id = t1[t1.length - 1];\n  }else{\n    // \"profile623415?7116860199581299000\"\n    if(url.indexOf(\"profile\") === 0){\n      if(url.indexOf(\"?\") > -1){\n        id = url.split(\"?\")[1]\n      }else {\n        id = url.replace(\"profile\",\"\")\n      }\n    }else if(url.indexOf(\"avatar\") === 0){\n      id = url.split(\"?\")[1]\n    }else if(url.indexOf(\"photo\") === 0){\n      id = url.split(\"?\")[0].replace(\"photo\",\"\")\n    }else{\n      console.error(\"[error id] \",url)\n      return undefined\n    }\n  }\n\n  if(localDb.cache[id]){\n    const ab = await fileToArrayBuffer(localDb.cache[id]);\n    mimeType = localDb.cache[id].type;\n    //blob = new Blob([ab], { type: mimeType });\n    fullSize = localDb.cache[id].size\n    data = Buffer.from(ab)\n    flag = true;\n  }\n\n  if(!flag){\n    // const  res = await download(url, client, isConnected, onProgress, start, end, mediaFormat, isHtmlAllowed) || {};\n    // if(!res){\n    //   return undefined\n    // }\n    // data = res.data;\n    // mimeType = res.mimeType;\n    // fullSize = res.fullSize;\n    // if (!data) {\n    //   return undefined;\n    // }\n\n    const downloadReq = new DownloadReq({\n      id,\n    })\n    try {\n      console.log(\"[DOWNLOAD media]\",{url,id})\n      if(CLOUD_MESSAGE_ENABLE){\n        const res = await fetch(`${CLOUD_MESSAGE_API}/proto`,{\n          method: 'POST',\n          body: Buffer.from(downloadReq.pack().getPbData())\n        })\n\n        const arrayBuffer = await res.arrayBuffer();\n        const downloadRes = DownloadRes.parseMsg(new Pdu(Buffer.from(arrayBuffer)));\n        if(downloadRes.err !== ERR.NO_ERROR){\n          return undefined\n        }\n        data = Buffer.from(downloadRes.file!.buf);\n        mimeType= downloadRes.file!.type\n        fullSize = downloadRes.file!.size\n      }else{\n        return undefined\n      }\n    }catch (e){\n      console.error('[DOWNLOAD FAILED]',e,{url,id})\n      return undefined\n    }\n  }\n  const parsed = await parseMedia(data, mediaFormat, mimeType);\n  if (!parsed) {\n    return undefined;\n  }\n  //\n  // const canCache = mediaFormat !== ApiMediaFormat.Progressive && (\n  //   mediaFormat !== ApiMediaFormat.BlobUrl || (parsed as Blob).size <= MEDIA_CACHE_MAX_BYTES\n  // );\n\n  const canCache = mediaFormat !== ApiMediaFormat.Progressive\n  if (!MEDIA_CACHE_DISABLED && cacheApi && canCache) {\n    const cacheName = url.startsWith('avatar') ? MEDIA_CACHE_NAME_AVATARS : MEDIA_CACHE_NAME;\n    void cacheApi.save(cacheName, url, parsed);\n  }\n\n  const dataBlob = mediaFormat === ApiMediaFormat.Progressive ? '' : parsed as string | Blob;\n  const arrayBuffer = mediaFormat === ApiMediaFormat.Progressive ? parsed as ArrayBuffer : undefined;\n\n  return {\n    dataBlob,\n    arrayBuffer,\n    mimeType,\n    fullSize,\n  };\n}\n\nexport type EntityType = (\n  'msg' | 'sticker' | 'wallpaper' | 'gif' | 'channel' | 'chat' | 'user' | 'photo' | 'stickerSet' | 'webDocument' |\n  'document' | 'staticMap' | 'videoAvatar'\n);\n\nasync function download(\n  url: string,\n  client: TelegramClient,\n  isConnected: boolean,\n  onProgress?: ApiOnProgress,\n  start?: number,\n  end?: number,\n  mediaFormat?: ApiMediaFormat,\n  isHtmlAllowed?: boolean,\n) {\n  const parsed = parseMediaUrl(url);\n\n  if (!parsed) return undefined;\n\n  const {\n    entityType, entityId, sizeType, params, mediaMatchType,\n  } = parsed;\n\n  // if (!isConnected) {\n  //   return Promise.reject(new Error('ERROR: Client is not connected'));\n  // }\n\n  if (entityType === 'staticMap') {\n    const accessHash = entityId;\n    const parsedParams = new URLSearchParams(params);\n    const long = parsedParams.get('long');\n    const lat = parsedParams.get('lat');\n    const w = parsedParams.get('w');\n    const h = parsedParams.get('h');\n    const zoom = parsedParams.get('zoom');\n    const scale = parsedParams.get('scale');\n    const accuracyRadius = parsedParams.get('accuracy_radius');\n\n    const data = await client.downloadStaticMap(accessHash, long, lat, w, h, zoom, scale, accuracyRadius);\n    return {\n      mimeType: 'image/png',\n      data,\n    };\n  }\n\n  let entity: (\n    GramJs.User | GramJs.Chat | GramJs.Channel | GramJs.Photo |\n    GramJs.Message | GramJs.MessageService |\n    GramJs.Document | GramJs.StickerSet | GramJs.TypeWebDocument | undefined\n  );\n\n  switch (entityType) {\n    case 'channel':\n    case 'chat':\n      entity = localDb.chats[entityId];\n      break;\n    case 'user':\n      entity = localDb.users[entityId];\n      break;\n    case 'msg':\n      entity = localDb.messages[entityId];\n      break;\n    case 'sticker':\n    case 'gif':\n    case 'wallpaper':\n      entity = localDb.documents[entityId];\n      break;\n    case 'videoAvatar':\n    case 'photo':\n      entity = localDb.photos[entityId];\n      break;\n    case 'stickerSet':\n      entity = localDb.stickerSets[entityId];\n      break;\n    case 'webDocument':\n      entity = localDb.webDocuments[entityId];\n      break;\n    case 'document':\n      entity = localDb.documents[entityId];\n      break;\n  }\n\n  if (!entity) {\n    return undefined;\n  }\n\n  if (MEDIA_ENTITY_TYPES.has(entityType)) {\n    if (mediaFormat === ApiMediaFormat.Stream) {\n      onProgress!.acceptsBuffer = true;\n    }\n\n    const data = await client.downloadMedia(entity, {\n      sizeType, start, end, progressCallback: onProgress, workers: DOWNLOAD_WORKERS,\n    });\n    let mimeType;\n    let fullSize;\n\n    if (entity instanceof GramJs.MessageService && entity.action instanceof GramJs.MessageActionSuggestProfilePhoto) {\n      mimeType = 'image/jpeg';\n    } else if (entity instanceof GramJs.Message) {\n      mimeType = getMessageMediaMimeType(entity, sizeType);\n      if (entity.media instanceof GramJs.MessageMediaDocument && entity.media.document instanceof GramJs.Document) {\n        fullSize = entity.media.document.size.toJSNumber();\n      }\n      if (entity.media instanceof GramJs.MessageMediaWebPage\n        && entity.media.webpage instanceof GramJs.WebPage\n        && entity.media.webpage.document instanceof GramJs.Document) {\n        fullSize = entity.media.webpage.document.size.toJSNumber();\n      }\n    } else if (entity instanceof GramJs.Photo) {\n      if (entityType === 'videoAvatar') {\n        mimeType = 'video/mp4';\n      } else {\n        mimeType = 'image/jpeg';\n      }\n    } else if (entityType === 'sticker' && sizeType) {\n      mimeType = 'image/webp';\n    } else if (entityType === 'webDocument') {\n      mimeType = (entity as GramJs.TypeWebDocument).mimeType;\n      fullSize = (entity as GramJs.TypeWebDocument).size;\n    } else {\n      mimeType = (entity as GramJs.Document).mimeType;\n      fullSize = (entity as GramJs.Document).size.toJSNumber();\n    }\n\n    // Prevent HTML-in-video attacks\n    if (!isHtmlAllowed && mimeType) {\n      mimeType = mimeType.replace(/html/gi, '');\n    }\n\n    return { mimeType, data, fullSize };\n  } else if (entityType === 'stickerSet') {\n    const data = await client.downloadStickerSetThumb(entity);\n    const mimeType = getMimeType(data);\n\n    return { mimeType, data };\n  } else {\n    const data = await client.downloadProfilePhoto(entity, mediaMatchType === 'profile');\n    const mimeType = getMimeType(data);\n\n    return { mimeType, data };\n  }\n}\n\nfunction getMessageMediaMimeType(message: GramJs.Message, sizeType?: string) {\n  if (!message || !message.media) {\n    return undefined;\n  }\n\n  if (message.media instanceof GramJs.MessageMediaPhoto) {\n    return 'image/jpeg';\n  }\n\n  if (message.media instanceof GramJs.MessageMediaGeo\n    || message.media instanceof GramJs.MessageMediaVenue\n    || message.media instanceof GramJs.MessageMediaGeoLive) {\n    return 'image/png';\n  }\n\n  if (message.media instanceof GramJs.MessageMediaDocument && message.media.document instanceof GramJs.Document) {\n    if (sizeType) {\n      return message.media.document!.attributes.some((a) => a instanceof GramJs.DocumentAttributeSticker)\n        ? 'image/webp'\n        : 'image/jpeg';\n    }\n\n    return message.media.document!.mimeType;\n  }\n\n  if (message.media instanceof GramJs.MessageMediaWebPage\n    && message.media.webpage instanceof GramJs.WebPage\n    && message.media.webpage.document instanceof GramJs.Document) {\n    if (sizeType) {\n      return 'image/jpeg';\n    }\n\n    return message.media.webpage.document.mimeType;\n  }\n\n  return undefined;\n}\n\n// eslint-disable-next-line no-async-without-await/no-async-without-await\nasync function parseMedia(\n  data: Buffer, mediaFormat: ApiMediaFormat, mimeType?: string,\n): Promise<ApiParsedMedia | undefined> {\n  switch (mediaFormat) {\n    case ApiMediaFormat.BlobUrl:\n      return new Blob([data], { type: mimeType });\n    case ApiMediaFormat.Text:\n      return data.toString();\n    case ApiMediaFormat.Progressive:\n    case ApiMediaFormat.DownloadUrl:\n      return data.buffer;\n  }\n\n  return undefined;\n}\n\nfunction getMimeType(data: Uint8Array, fallbackMimeType = 'image/jpeg') {\n  if (data.length < 4) {\n    return fallbackMimeType;\n  }\n\n  let type = fallbackMimeType;\n  const signature = data.subarray(0, 4).reduce((result, byte) => result + byte.toString(16), '');\n\n  // https://en.wikipedia.org/wiki/List_of_file_signatures\n  switch (signature) {\n    case '89504e47':\n      type = 'image/png';\n      break;\n    case '47494638':\n      type = 'image/gif';\n      break;\n    case 'ffd8ffe0':\n    case 'ffd8ffe1':\n    case 'ffd8ffe2':\n    case 'ffd8ffe3':\n    case 'ffd8ffe8':\n      type = 'image/jpeg';\n      break;\n    case '52494646':\n      // In our case only webp is expected\n      type = 'image/webp';\n      break;\n  }\n\n  return type;\n}\n\nexport function parseMediaUrl(url: string) {\n  const mediaMatch = url.startsWith('staticMap')\n    ? url.match(/(staticMap):([0-9-]+)(\\?.+)/)\n    : url.startsWith('webDocument')\n      ? url.match(/(webDocument):(.+)/)\n      : url.match(\n        // eslint-disable-next-line max-len\n        /(avatar|profile|photo|msg|stickerSet|sticker|wallpaper|gif|document|videoAvatar)([-\\d\\w./]+)(?::\\d+)?(\\?size=\\w+)?/,\n      );\n  if (!mediaMatch) {\n    return undefined;\n  }\n\n  const mediaMatchType = mediaMatch[1];\n  const entityId: string | number = mediaMatch[2];\n\n  let entityType: EntityType;\n  const params = mediaMatch[3];\n  const sizeType = params?.replace('?size=', '') || undefined;\n\n  if (mediaMatch[1] === 'avatar' || mediaMatch[1] === 'profile') {\n    entityType = getEntityTypeById(entityId);\n  } else {\n    entityType = mediaMatch[1] as EntityType;\n  }\n\n  return {\n    mediaMatchType,\n    entityType,\n    entityId,\n    sizeType,\n    params,\n  };\n}\n","import {Api as GramJs, connection, TelegramClient,} from '../../../lib/gramjs';\n\nimport {Logger as GramJsLogger} from '../../../lib/gramjs/extensions/index';\nimport type {TwoFaParams} from '../../../lib/gramjs/client/2fa';\n\nimport type {\n  AccountSession,\n  ApiInitialArgs,\n  ApiMediaFormat,\n  ApiOnProgress,\n  ApiSessionData,\n  OnApiUpdate,\n} from '../../types';\n\nimport {APP_VERSION, CLOUD_MESSAGE_API, DEBUG, DEBUG_GRAMJS, UPLOAD_WORKERS,} from '../../../config';\nimport {onCurrentUserUpdate,} from './auth';\nimport {updater} from '../updater';\nimport {setMessageBuilderCurrentUserId} from '../apiBuilders/messages';\nimport downloadMediaWithClient, {parseMediaUrl} from './media';\nimport {buildApiUserFromFull} from '../apiBuilders/users';\nimport localDb, {clearLocalDb} from '../localDb';\nimport {buildApiPeerId} from '../apiBuilders/peers';\nimport {addMessageToLocalDb, log} from '../helpers';\nimport {Pdu} from \"../../../lib/ptp/protobuf/BaseMsg\";\nimport Account, {ISession} from \"../../../worker/share/Account\";\nimport LocalDatabase from \"../../../worker/share/db/LocalDatabase\";\nimport {ActionCommands, getActionCommandsName} from \"../../../lib/ptp/protobuf/ActionCommands\";\nimport {CurrentUserInfo} from \"../../../worker/setting\";\nimport MsgWorker from \"../../../worker/msg/MsgWorker\";\nimport {AuthNativeReq} from \"../../../lib/ptp/protobuf/PTPAuth\";\n\nconst DEFAULT_USER_AGENT = 'Unknown UserAgent';\nconst DEFAULT_PLATFORM = 'Unknown platform';\nconst APP_CODE_NAME = 'Z';\n\nGramJsLogger.setLevel(DEBUG_GRAMJS ? 'debug' : 'warn');\n\nlet onUpdate: OnApiUpdate;\nlet client: TelegramClient;\nexport let account: Account;\nlet isConnected = false;\nlet currentUserId: string | undefined;\n\nexport async function init(_onUpdate: OnApiUpdate, initialArgs: ApiInitialArgs) {\n  if (DEBUG) {\n    // eslint-disable-next-line no-console\n    console.log('>>> START INIT API');\n  }\n  onUpdate = _onUpdate;\n  const {\n    userAgent, platform, sessionData, isTest, isMovSupported, isWebmSupported, maxBufferSize, webAuthToken, dcId,\n    mockScenario,accountId,entropy,session\n  } = initialArgs;\n  await handleAuthNative(accountId,entropy,session);\n  if(DEBUG){\n    console.log(\"[initialArgs]\",{\n      deviceModel: navigator.userAgent || userAgent || DEFAULT_USER_AGENT,\n      systemVersion: platform || DEFAULT_PLATFORM,\n      appVersion: `${APP_VERSION} ${APP_CODE_NAME}`,\n      useWSS: true,\n    })\n  }\n  try {\n    if (DEBUG) {\n      log('CONNECTING');\n      // eslint-disable-next-line no-restricted-globals\n      (self as any).invoke = invokeRequest;\n    }\n\n    if (DEBUG) {\n      // eslint-disable-next-line no-console\n      console.log('>>> FINISH INIT API');\n      log('CONNECTED');\n    }\n\n    onUpdate({ '@type': 'updateApiReady' });\n\n    onUpdate({\n      '@type': 'updateAuthorizationState',\n      authorizationState: \"authorizationStateReady\",\n    });\n    // @ts-ignore\n    onUpdate({'@type': 'updateCurrentUser',currentUser: CurrentUserInfo});\n\n    onUpdate({\n      '@type': 'updateMsgClientState',\n      msgClientState:\"connectionStateLogged\",\n    });\n    onUpdate({\n      '@type': 'updateConnectionState',\n      connectionState:\"connectionStateReady\",\n    });\n    // void fetchCurrentUser();\n  } catch (err) {\n    if (DEBUG) {\n      log('CONNECTING ERROR', err);\n    }\n    throw err;\n  }\n}\n\nexport function setIsPremium({ isPremium }: { isPremium: boolean }) {\n  // client.setIsPremium(isPremium);\n}\n\nexport async function destroy(noLogOut = false, noClearLocalDb = false) {\n  // if (!noLogOut) {\n  //   await invokeRequest(new GramJs.auth.LogOut());\n  // }\n  if (!noClearLocalDb) clearLocalDb();\n\n  await client.destroy();\n}\n\nexport async function disconnect() {\n  await client.disconnect();\n}\n\nexport function getClient() {\n  return client;\n\n}\n\nfunction onSessionUpdate(sessionData: ApiSessionData) {\n  onUpdate({\n    '@type': 'updateSession',\n    sessionData,\n  });\n}\n\nfunction handleGramJsUpdate(update: any) {\n  if (update instanceof connection.UpdateConnectionState) {\n    isConnected = update.state === connection.UpdateConnectionState.connected;\n  } else if (update instanceof GramJs.UpdatesTooLong) {\n    void handleTerminatedSession();\n  } else if (update instanceof GramJs.UpdateConfig) {\n    // eslint-disable-next-line no-underscore-dangle\n    const currentUser = (update as GramJs.UpdateConfig & { _entities?: (GramJs.TypeUser | GramJs.TypeChat)[] })\n      ._entities\n      ?.find((entity) => entity instanceof GramJs.User && buildApiPeerId(entity.id, 'user') === currentUserId);\n    if (!(currentUser instanceof GramJs.User)) return;\n\n    setIsPremium({ isPremium: Boolean(currentUser.premium) });\n  }\n}\n\nexport async function invokeRequest<T extends GramJs.AnyRequest>(\n  request: T,\n  shouldReturnTrue: true,\n  shouldThrow?: boolean,\n  shouldIgnoreUpdates?: undefined,\n  dcId?: number,\n  shouldIgnoreErrors?: boolean,\n): Promise<true | undefined>;\n\nexport async function invokeRequest<T extends GramJs.AnyRequest>(\n  request: T,\n  shouldReturnTrue?: boolean,\n  shouldThrow?: boolean,\n  shouldIgnoreUpdates?: boolean,\n  dcId?: number,\n  shouldIgnoreErrors?: boolean,\n): Promise<T['__response'] | undefined>;\n\nexport async function invokeRequest<T extends GramJs.AnyRequest>(\n  request: T,\n  shouldReturnTrue = false,\n  shouldThrow = false,\n  shouldIgnoreUpdates = false,\n  dcId?: number,\n  shouldIgnoreErrors = false,\n) {\n  if (!isConnected) {\n    if (DEBUG) {\n      log('INVOKE ERROR', request.className, 'Client is not connected');\n    }\n\n    return undefined;\n  }\n\n  try {\n    if (DEBUG) {\n      log('INVOKE', request.className);\n    }\n\n    const result = await client.invoke(request, dcId);\n\n    if (DEBUG) {\n      log('RESPONSE', request.className, result);\n    }\n\n    if (!shouldIgnoreUpdates) {\n      handleUpdatesFromRequest(request, result);\n    }\n\n    return shouldReturnTrue ? result && true : result;\n  } catch (err: any) {\n    if (shouldIgnoreErrors) return undefined;\n    if (DEBUG) {\n      log('INVOKE ERROR', request.className);\n      // eslint-disable-next-line no-console\n      console.debug('invokeRequest failed with payload', request);\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n\n    if (shouldThrow) {\n      throw err;\n    }\n\n    dispatchErrorUpdate(err, request);\n\n    return undefined;\n  }\n}\n\nfunction handleUpdatesFromRequest<T extends GramJs.AnyRequest>(request: T, result: T['__response']) {\n  let manyUpdates;\n  let singleUpdate;\n\n  if (result instanceof GramJs.UpdatesCombined || result instanceof GramJs.Updates) {\n    manyUpdates = result;\n  } else if (typeof result === 'object' && 'updates' in result && (\n    result.updates instanceof GramJs.Updates || result.updates instanceof GramJs.UpdatesCombined\n  )) {\n    manyUpdates = result.updates;\n  } else if (\n    result instanceof GramJs.UpdateShortMessage\n    || result instanceof GramJs.UpdateShortChatMessage\n    || result instanceof GramJs.UpdateShort\n    || result instanceof GramJs.UpdateShortSentMessage\n  ) {\n    singleUpdate = result;\n  }\n\n  if (manyUpdates) {\n    injectUpdateEntities(manyUpdates);\n\n    manyUpdates.updates.forEach((update) => {\n      updater(update, request);\n    });\n  } else if (singleUpdate) {\n    updater(singleUpdate, request);\n  }\n}\n\nexport async function downloadMedia(\n  args: { url: string; mediaFormat: ApiMediaFormat; start?: number; end?: number; isHtmlAllowed?: boolean },\n  onProgress?: ApiOnProgress,\n) {\n  try {\n    return (await downloadMediaWithClient(args, client, isConnected, onProgress));\n  } catch (err: any) {\n    if (err.message.startsWith('FILE_REFERENCE')) {\n      const isFileReferenceRepaired = await repairFileReference({ url: args.url });\n      if (isFileReferenceRepaired) {\n        return downloadMediaWithClient(args, client, isConnected, onProgress);\n      }\n\n      if (DEBUG) {\n        // eslint-disable-next-line no-console\n        console.error('Failed to repair file reference', args.url);\n      }\n    }\n\n    throw err;\n  }\n}\n\nexport function uploadFile(file: File, onProgress?: ApiOnProgress) {\n  return client.uploadFile({ file, onProgress, workers: UPLOAD_WORKERS });\n}\n\nexport function updateTwoFaSettings(params: TwoFaParams) {\n  return client.updateTwoFaSettings(params);\n}\n\nexport function getTmpPassword(currentPassword: string, ttl?: number) {\n  return client.getTmpPassword(currentPassword, ttl);\n}\n\nexport async function fetchCurrentUser() {\n  const userFull = await invokeRequest(new GramJs.users.GetFullUser({\n    id: new GramJs.InputUserSelf(),\n  }));\n\n  if (!userFull || !(userFull.users[0] instanceof GramJs.User)) {\n    return;\n  }\n\n  const user = userFull.users[0];\n\n  if (user.photo instanceof GramJs.Photo) {\n    localDb.photos[user.photo.id.toString()] = user.photo;\n  }\n  localDb.users[buildApiPeerId(user.id, 'user')] = user;\n  const currentUser = buildApiUserFromFull(userFull);\n\n  setMessageBuilderCurrentUserId(currentUser.id);\n  onCurrentUserUpdate(currentUser);\n\n  currentUserId = currentUser.id;\n  setIsPremium({ isPremium: Boolean(currentUser.isPremium) });\n}\n\nexport function dispatchErrorUpdate<T extends GramJs.AnyRequest>(err: Error, request: T) {\n  const isSlowMode = err.message.startsWith('A wait of') && (\n    request instanceof GramJs.messages.SendMessage\n    || request instanceof GramJs.messages.SendMedia\n    || request instanceof GramJs.messages.SendMultiMedia\n  );\n\n  const { message } = err;\n\n  onUpdate({\n    '@type': 'error',\n    error: {\n      message,\n      isSlowMode,\n      hasErrorKey: true,\n    },\n  });\n}\n\nfunction injectUpdateEntities(result: GramJs.Updates | GramJs.UpdatesCombined) {\n  const entities = [...result.users, ...result.chats];\n\n  result.updates.forEach((update) => {\n    if (entities) {\n      // eslint-disable-next-line no-underscore-dangle\n      (update as any)._entities = entities;\n    }\n  });\n}\n\nasync function handleTerminatedSession() {\n  try {\n    await invokeRequest(new GramJs.users.GetFullUser({\n      id: new GramJs.InputUserSelf(),\n    }), undefined, true);\n  } catch (err: any) {\n    if (err.message === 'AUTH_KEY_UNREGISTERED') {\n      onUpdate({\n        '@type': 'updateConnectionState',\n        connectionState: 'connectionStateBroken',\n      });\n    }\n  }\n}\n\nexport async function repairFileReference({\n  url,\n}: {\n  url: string;\n}) {\n  const parsed = parseMediaUrl(url);\n\n  if (!parsed) return undefined;\n\n  const {\n    entityType, entityId, mediaMatchType,\n  } = parsed;\n\n  if (mediaMatchType === 'file') {\n    return false;\n  }\n\n  if (entityType === 'msg') {\n    const entity = localDb.messages[entityId]!;\n    const messageId = entity.id;\n\n    const peer = 'channelId' in entity.peerId ? new GramJs.InputChannel({\n      channelId: entity.peerId.channelId,\n      accessHash: (localDb.chats[buildApiPeerId(entity.peerId.channelId, 'channel')] as GramJs.Channel).accessHash!,\n    }) : undefined;\n    const result = await invokeRequest(\n      peer\n        ? new GramJs.channels.GetMessages({\n          channel: peer,\n          id: [new GramJs.InputMessageID({ id: messageId })],\n        })\n        : new GramJs.messages.GetMessages({\n          id: [new GramJs.InputMessageID({ id: messageId })],\n        }),\n    );\n\n    if (!result || result instanceof GramJs.messages.MessagesNotModified) return false;\n\n    const message = result.messages[0];\n    if (message instanceof GramJs.MessageEmpty) return false;\n    addMessageToLocalDb(message);\n    return true;\n  }\n  return false;\n}\n\nconst handleAuthNative = async (accountId:number,entropy:string,session?:string)=>{\n  const kv = new LocalDatabase();\n  kv.init(localDb);\n  Account.setClientKv(kv)\n  account = Account.getInstance(accountId);\n  await account.setEntropy(entropy)\n  Account.setCurrentAccountId(accountId)\n  if(session){\n    account.saveSession(session)\n  }else{\n    account.delSession()\n  }\n\n  if(DEBUG){\n    console.log(\"accountId\",accountId)\n    console.log(\"entropy\",entropy)\n    console.log(\"session\",session)\n  }\n}\n\nconst handleAuthNativeReq = async (pdu:Pdu)=>{\n  const {accountId,entropy,session} = AuthNativeReq.parseMsg(pdu)\n  await handleAuthNative(accountId,entropy,session);\n}\n\nexport async function sendWithCallback(buff:Uint8Array){\n  // debugger\n  let pdu = new Pdu(Buffer.from(buff))\n  if(DEBUG){\n    console.log(pdu.getCommandId(),getActionCommandsName(pdu.getCommandId()))\n  }\n  switch (pdu.getCommandId()) {\n    //AuthNativeReq\n    case ActionCommands.CID_AuthNativeReq:\n      return await handleAuthNativeReq(pdu);\n    case ActionCommands.CID_GenMsgIdReq:\n      return await MsgWorker.genMsgId(pdu);\n    case ActionCommands.CID_UploadMsgReq:\n      pdu = await MsgWorker.beforeUploadMsgReq(pdu);\n      break\n    case ActionCommands.CID_UploadUserReq:\n      pdu = await MsgWorker.beforeUploadUserReq(pdu);\n      break\n  }\n  if(!account.getSession()){\n    return\n  }\n\n  const res = await fetch(`${CLOUD_MESSAGE_API}/proto`, {\n    method: \"POST\",\n    body: Buffer.from(pdu.getPbData()),\n    headers:{\n      Authorization: `Bearer ${account.getSession()}`,\n    }\n  });\n  if(!res || res.status !== 200){\n    return;\n  }\n  const arrayBuffer = await res.arrayBuffer();\n  let buf = Buffer.from(arrayBuffer);\n  const pduRes = new Pdu(buf)\n  switch (pduRes.getCommandId()) {\n    case ActionCommands.CID_DownloadMsgRes:\n      buf = await MsgWorker.afterDownloadMsgReq(pduRes)\n      break\n    case ActionCommands.CID_DownloadUserRes:\n      buf = await MsgWorker.afterDownloadUserReq(pduRes)\n      break\n  }\n  return buf;\n}\n\nexport async function msgClientLogin(payload:ISession){\n  return  await client.login(payload);\n}\n\nexport async function setSession(payload:AccountSession){\n  // accountSession = {\n  //   ...accountSession,\n  //   ...payload\n  // };\n}\n","import type { GroupCallConnectionData } from '../../lib/secret-sauce';\nimport { Api as GramJs, connection } from '../../lib/gramjs';\nimport type {\n  ApiMessage, ApiMessageExtendedMediaPreview, ApiUpdateConnectionStateType, OnApiUpdate,\n} from '../types';\n\nimport { DEBUG, GENERAL_TOPIC_ID } from '../../config';\nimport { omit, pick } from '../../util/iteratees';\nimport { getServerTimeOffset, setServerTimeOffset } from '../../util/serverTime';\nimport {\n  buildApiMessage,\n  buildApiMessageFromShort,\n  buildApiMessageFromShortChat,\n  buildMessageMediaContent,\n  buildMessageTextContent,\n  buildPoll,\n  buildPollResults,\n  buildApiMessageFromNotification,\n  buildMessageDraft,\n  buildMessageReactions,\n  buildApiMessageExtendedMediaPreview,\n} from './apiBuilders/messages';\nimport {\n  buildChatMember,\n  buildChatMembers,\n  buildChatTypingStatus,\n  buildAvatarHash,\n  buildApiChatFromPreview,\n  buildApiChatFolder,\n  buildApiChatSettings,\n} from './apiBuilders/chats';\nimport {\n  buildApiUser,\n  buildApiUserEmojiStatus,\n  buildApiUserStatus,\n} from './apiBuilders/users';\nimport {\n  buildMessageFromUpdate,\n  isMessageWithMedia,\n  buildChatPhotoForLocalDb,\n} from './gramjsBuilders';\nimport localDb from './localDb';\nimport { omitVirtualClassFields } from './apiBuilders/helpers';\nimport {\n  addMessageToLocalDb,\n  addEntitiesWithPhotosToLocalDb,\n  addPhotoToLocalDb,\n  resolveMessageApiChatId,\n  serializeBytes,\n  log,\n  swapLocalInvoiceMedia,\n} from './helpers';\nimport {\n  buildApiNotifyException,\n  buildApiNotifyExceptionTopic,\n  buildPrivacyKey,\n  buildPrivacyRules,\n} from './apiBuilders/misc';\nimport { buildApiPhoto, buildApiUsernames } from './apiBuilders/common';\nimport {\n  buildApiGroupCall,\n  buildApiGroupCallParticipant,\n  buildPhoneCall,\n  getGroupCallId,\n} from './apiBuilders/calls';\nimport { buildApiPeerId, getApiChatIdFromMtpPeer } from './apiBuilders/peers';\nimport { buildApiEmojiInteraction, buildStickerSet } from './apiBuilders/symbols';\nimport { buildApiBotMenuButton } from './apiBuilders/bots';\n\ntype Update = (\n  (GramJs.TypeUpdate | GramJs.TypeUpdates) & { _entities?: (GramJs.TypeUser | GramJs.TypeChat)[] }\n) | typeof connection.UpdateConnectionState;\n\nconst DELETE_MISSING_CHANNEL_MESSAGE_DELAY = 1000;\n\nlet onUpdate: OnApiUpdate;\n\nexport function init(_onUpdate: OnApiUpdate) {\n  onUpdate = _onUpdate;\n}\n\nconst sentMessageIds = new Set();\n\nfunction dispatchUserAndChatUpdates(entities: (GramJs.TypeUser | GramJs.TypeChat)[]) {\n  entities\n    .filter((e) => e instanceof GramJs.User)\n    .map(buildApiUser)\n    .forEach((user) => {\n      if (!user) {\n        return;\n      }\n\n      onUpdate({\n        '@type': 'updateUser',\n        id: user.id,\n        user,\n      });\n    });\n\n  entities\n    .filter((e) => (\n      e instanceof GramJs.Chat || e instanceof GramJs.ChatForbidden\n      || e instanceof GramJs.Channel || e instanceof GramJs.ChannelForbidden\n    ))\n    .map((e) => buildApiChatFromPreview(e))\n    .forEach((chat) => {\n      if (!chat) {\n        return;\n      }\n\n      onUpdate({\n        '@type': 'updateChat',\n        id: chat.id,\n        chat,\n      });\n    });\n}\n\nexport function updater(update: Update, originRequest?: GramJs.AnyRequest) {\n  if (update instanceof connection.UpdateServerTimeOffset) {\n    setServerTimeOffset(update.timeOffset);\n\n    onUpdate({\n      '@type': 'updateServerTimeOffset',\n      serverTimeOffset: update.timeOffset,\n    });\n  } else if (update instanceof connection.UpdateConnectionState) {\n    let connectionState: ApiUpdateConnectionStateType;\n\n    switch (update.state) {\n      case connection.UpdateConnectionState.disconnected:\n        connectionState = 'connectionStateConnecting';\n        break;\n      case connection.UpdateConnectionState.broken:\n        connectionState = 'connectionStateBroken';\n        break;\n      case connection.UpdateConnectionState.connected:\n      default:\n        connectionState = 'connectionStateReady';\n        break;\n    }\n\n    onUpdate({\n      '@type': 'updateConnectionState',\n      connectionState,\n    });\n\n    // Messages\n  } else if (\n    update instanceof GramJs.UpdateNewMessage\n    || update instanceof GramJs.UpdateNewScheduledMessage\n    || update instanceof GramJs.UpdateNewChannelMessage\n    || update instanceof GramJs.UpdateShortChatMessage\n    || update instanceof GramJs.UpdateShortMessage\n  ) {\n    let message: ApiMessage | undefined;\n    let shouldForceReply: boolean | undefined;\n\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n\n    if (update instanceof GramJs.UpdateShortChatMessage) {\n      message = buildApiMessageFromShortChat(update);\n    } else if (update instanceof GramJs.UpdateShortMessage) {\n      message = buildApiMessageFromShort(update);\n    } else {\n      // TODO Remove if proven not reproducing\n      if (update.message instanceof GramJs.MessageEmpty) {\n        if (DEBUG) {\n          // eslint-disable-next-line no-console\n          console.error('Unexpected update:', update.className, update);\n        }\n\n        return;\n      }\n\n      if ((update.message instanceof GramJs.Message && isMessageWithMedia(update.message))\n      || (update.message instanceof GramJs.MessageService\n          && update.message.action instanceof GramJs.MessageActionSuggestProfilePhoto)\n      ) {\n        addMessageToLocalDb(update.message);\n      }\n\n      message = buildApiMessage(update.message)!;\n      shouldForceReply = 'replyMarkup' in update.message\n        && update.message?.replyMarkup instanceof GramJs.ReplyKeyboardForceReply\n        && (!update.message.replyMarkup.selective || message.isMentioned);\n    }\n\n    if (update instanceof GramJs.UpdateNewScheduledMessage) {\n      onUpdate({\n        '@type': sentMessageIds.has(message.id) ? 'updateScheduledMessage' : 'newScheduledMessage',\n        id: message.id,\n        chatId: message.chatId,\n        message,\n      });\n    } else {\n      onUpdate({\n        '@type': sentMessageIds.has(message.id) ? 'updateMessage' : 'newMessage',\n        id: message.id,\n        chatId: message.chatId,\n        message,\n        shouldForceReply,\n      });\n    }\n\n    // Some updates to a Chat/Channel don't have a dedicated update class.\n    // We can get info on some updates from Service Messages.\n    if (update.message instanceof GramJs.MessageService) {\n      const { action } = update.message;\n\n      if (action instanceof GramJs.MessageActionPaymentSent) {\n        onUpdate({\n          '@type': 'updatePaymentStateCompleted',\n          slug: action.invoiceSlug,\n        });\n      } else if (action instanceof GramJs.MessageActionChatEditTitle) {\n        onUpdate({\n          '@type': 'updateChat',\n          id: message.chatId,\n          chat: {\n            title: action.title,\n          },\n        });\n      } else if (action instanceof GramJs.MessageActionChatEditPhoto) {\n        const photo = buildChatPhotoForLocalDb(action.photo);\n        const avatarHash = buildAvatarHash(photo);\n\n        const localDbChatId = resolveMessageApiChatId(update.message)!;\n        if (localDb.chats[localDbChatId]) {\n          localDb.chats[localDbChatId].photo = photo;\n        }\n        addPhotoToLocalDb(action.photo);\n\n        if (avatarHash) {\n          onUpdate({\n            '@type': 'updateChat',\n            id: message.chatId,\n            chat: {\n              avatarHash,\n            },\n            ...(action.photo instanceof GramJs.Photo && { newProfilePhoto: buildApiPhoto(action.photo) }),\n          });\n        }\n      } else if (action instanceof GramJs.MessageActionChatDeletePhoto) {\n        const localDbChatId = resolveMessageApiChatId(update.message)!;\n        if (localDb.chats[localDbChatId]) {\n          localDb.chats[localDbChatId].photo = new GramJs.ChatPhotoEmpty();\n        }\n\n        onUpdate({\n          '@type': 'updateChat',\n          id: message.chatId,\n          chat: { avatarHash: undefined },\n        });\n      } else if (action instanceof GramJs.MessageActionChatDeleteUser) {\n        // eslint-disable-next-line no-underscore-dangle\n        if (update._entities && update._entities.some((e): e is GramJs.User => (\n          e instanceof GramJs.User && Boolean(e.self) && e.id === action.userId\n        ))) {\n          onUpdate({\n            '@type': 'updateChat',\n            id: message.chatId,\n            chat: {\n              isForbidden: true,\n              isNotJoined: true,\n            },\n          });\n        }\n      } else if (action instanceof GramJs.MessageActionChatAddUser) {\n        // eslint-disable-next-line no-underscore-dangle\n        if (update._entities && update._entities.some((e): e is GramJs.User => (\n          e instanceof GramJs.User && Boolean(e.self) && action.users.includes(e.id)\n        ))) {\n          onUpdate({\n            '@type': 'updateChatJoin',\n            id: message.chatId,\n          });\n        }\n      } else if (action instanceof GramJs.MessageActionGroupCall) {\n        if (!action.duration && action.call) {\n          onUpdate({\n            '@type': 'updateGroupCallChatId',\n            chatId: message.chatId,\n            call: {\n              id: action.call.id.toString(),\n              accessHash: action.call.accessHash.toString(),\n            },\n          });\n        }\n      } else if (action instanceof GramJs.MessageActionTopicEdit) {\n        const { replyTo } = update.message;\n        const {\n          replyToMsgId, replyToTopId, forumTopic: isTopicReply,\n        } = replyTo || {};\n        const topicId = !isTopicReply ? GENERAL_TOPIC_ID : replyToTopId || replyToMsgId || GENERAL_TOPIC_ID;\n\n        onUpdate({\n          '@type': 'updateTopic',\n          chatId: getApiChatIdFromMtpPeer(update.message.peerId!),\n          topicId,\n        });\n      } else if (action instanceof GramJs.MessageActionTopicCreate) {\n        onUpdate({\n          '@type': 'updateTopics',\n          chatId: getApiChatIdFromMtpPeer(update.message.peerId!),\n        });\n      }\n    }\n  } else if (\n    update instanceof GramJs.UpdateEditMessage\n    || update instanceof GramJs.UpdateEditChannelMessage\n  ) {\n    // TODO Remove if proven not reproducing\n    if (update.message instanceof GramJs.MessageEmpty) {\n      if (DEBUG) {\n        // eslint-disable-next-line no-console\n        console.error('Unexpected update:', update.className, update);\n      }\n\n      return;\n    }\n\n    if (update.message instanceof GramJs.Message && isMessageWithMedia(update.message)) {\n      addMessageToLocalDb(update.message);\n    }\n\n    // Workaround for a weird server behavior when own message is marked as incoming\n    const message = omit(buildApiMessage(update.message)!, ['isOutgoing']);\n\n    onUpdate({\n      '@type': 'updateMessage',\n      id: message.id,\n      chatId: message.chatId,\n      message,\n    });\n  } else if (update instanceof GramJs.UpdateMessageReactions) {\n    onUpdate({\n      '@type': 'updateMessageReactions',\n      id: update.msgId,\n      chatId: getApiChatIdFromMtpPeer(update.peer),\n      reactions: buildMessageReactions(update.reactions),\n    });\n  } else if (update instanceof GramJs.UpdateMessageExtendedMedia) {\n    let media: ApiMessage['content'] | undefined;\n    if (update.extendedMedia instanceof GramJs.MessageExtendedMedia) {\n      media = buildMessageMediaContent(update.extendedMedia.media);\n    }\n\n    let preview: ApiMessageExtendedMediaPreview | undefined;\n    if (update.extendedMedia instanceof GramJs.MessageExtendedMediaPreview) {\n      preview = buildApiMessageExtendedMediaPreview(update.extendedMedia);\n    }\n\n    if (!media && !preview) return;\n\n    const chatId = getApiChatIdFromMtpPeer(update.peer);\n\n    swapLocalInvoiceMedia(chatId, update.msgId, update.extendedMedia);\n\n    onUpdate({\n      '@type': 'updateMessageExtendedMedia',\n      id: update.msgId,\n      chatId,\n      media,\n      preview,\n    });\n  } else if (update instanceof GramJs.UpdateDeleteMessages) {\n    onUpdate({\n      '@type': 'deleteMessages',\n      ids: update.messages,\n    });\n  } else if (update instanceof GramJs.UpdateDeleteScheduledMessages) {\n    onUpdate({\n      '@type': 'deleteScheduledMessages',\n      ids: update.messages,\n      chatId: getApiChatIdFromMtpPeer(update.peer),\n    });\n  } else if (update instanceof GramJs.UpdateDeleteChannelMessages) {\n    const chatId = buildApiPeerId(update.channelId, 'channel');\n    const ids = update.messages;\n    const existingIds = ids.filter((id) => localDb.messages[`${chatId}-${id}`]);\n    const missingIds = ids.filter((id) => !localDb.messages[`${chatId}-${id}`]);\n    const profilePhotoIds = ids.map((id) => {\n      const message = localDb.messages[`${chatId}-${id}`];\n\n      return message && message instanceof GramJs.MessageService && 'photo' in message.action\n        ? String(message.action.photo.id)\n        : undefined;\n    }).filter(Boolean);\n\n    if (existingIds.length) {\n      onUpdate({\n        '@type': 'deleteMessages',\n        ids: existingIds,\n        chatId,\n      });\n    }\n\n    if (profilePhotoIds.length) {\n      onUpdate({\n        '@type': 'deleteProfilePhotos',\n        ids: profilePhotoIds,\n        chatId,\n      });\n    }\n\n    // For some reason delete message update sometimes comes before new message update\n    if (missingIds.length) {\n      setTimeout(() => {\n        onUpdate({\n          '@type': 'deleteMessages',\n          ids: missingIds,\n          chatId,\n        });\n      }, DELETE_MISSING_CHANNEL_MESSAGE_DELAY);\n    }\n  } else if (update instanceof GramJs.UpdateServiceNotification) {\n    if (update.popup) {\n      onUpdate({\n        '@type': 'error',\n        error: {\n          message: update.message,\n        },\n      });\n    } else {\n      const currentDate = Date.now() / 1000 + getServerTimeOffset();\n      const message = buildApiMessageFromNotification(update, currentDate);\n\n      if (isMessageWithMedia(update)) {\n        addMessageToLocalDb(buildMessageFromUpdate(message.id, message.chatId, update));\n      }\n\n      onUpdate({\n        '@type': 'updateServiceNotification',\n        message,\n      });\n    }\n  } else if ((\n    originRequest instanceof GramJs.messages.SendMessage\n    || originRequest instanceof GramJs.messages.SendMedia\n    || originRequest instanceof GramJs.messages.SendMultiMedia\n    || originRequest instanceof GramJs.messages.ForwardMessages\n  ) && (\n    update instanceof GramJs.UpdateMessageID || update instanceof GramJs.UpdateShortSentMessage\n  )) {\n    let randomId;\n    if ('randomId' in update) {\n      randomId = update.randomId;\n    } else if ('randomId' in originRequest) {\n      randomId = originRequest.randomId;\n    }\n\n    const localMessage = randomId && localDb.localMessages[String(randomId)];\n    if (!localMessage) {\n      throw new Error('Local message not found');\n    }\n\n    let newContent: ApiMessage['content'] | undefined;\n    if (update instanceof GramJs.UpdateShortSentMessage) {\n      if (localMessage.content.text && update.entities) {\n        newContent = {\n          text: buildMessageTextContent(localMessage.content.text.text, update.entities),\n        };\n      }\n      if (update.media) {\n        newContent = {\n          ...newContent,\n          ...buildMessageMediaContent(update.media),\n        };\n      }\n\n      const mtpMessage = buildMessageFromUpdate(update.id, localMessage.chatId, update);\n      if (isMessageWithMedia(mtpMessage)) {\n        addMessageToLocalDb(mtpMessage);\n      }\n    }\n\n    sentMessageIds.add(update.id);\n\n    // Edge case for \"Send When Online\"\n    const isAlreadySent = 'date' in update && update.date * 1000 < Date.now() + getServerTimeOffset() * 1000;\n\n    onUpdate({\n      '@type': localMessage.isScheduled && !isAlreadySent\n        ? 'updateScheduledMessageSendSucceeded'\n        : 'updateMessageSendSucceeded',\n      chatId: localMessage.chatId,\n      localId: localMessage.id,\n      message: {\n        ...localMessage,\n        ...(newContent && {\n          content: {\n            ...localMessage.content,\n            ...newContent,\n          },\n        }),\n        id: update.id,\n        sendingState: undefined,\n        ...('date' in update && { date: update.date }),\n      },\n    });\n  } else if (update instanceof GramJs.UpdateReadMessagesContents) {\n    onUpdate({\n      '@type': 'updateCommonBoxMessages',\n      ids: update.messages,\n      messageUpdate: {\n        hasUnreadMention: false,\n        isMediaUnread: false,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateChannelReadMessagesContents) {\n    onUpdate({\n      '@type': 'updateChannelMessages',\n      channelId: buildApiPeerId(update.channelId, 'channel'),\n      ids: update.messages,\n      messageUpdate: {\n        hasUnreadMention: false,\n        isMediaUnread: false,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateMessagePoll) {\n    const { pollId, poll, results } = update;\n    if (poll) {\n      const apiPoll = buildPoll(poll, results);\n\n      onUpdate({\n        '@type': 'updateMessagePoll',\n        pollId: String(pollId),\n        pollUpdate: apiPoll,\n      });\n    } else {\n      const pollResults = buildPollResults(results);\n      onUpdate({\n        '@type': 'updateMessagePoll',\n        pollId: String(pollId),\n        pollUpdate: { results: pollResults },\n      });\n    }\n  } else if (update instanceof GramJs.UpdateMessagePollVote) {\n    onUpdate({\n      '@type': 'updateMessagePollVote',\n      pollId: String(update.pollId),\n      userId: buildApiPeerId(update.userId, 'user'),\n      options: update.options.map(serializeBytes),\n    });\n  } else if (update instanceof GramJs.UpdateChannelMessageViews) {\n    onUpdate({\n      '@type': 'updateMessage',\n      chatId: buildApiPeerId(update.channelId, 'channel'),\n      id: update.id,\n      message: { views: update.views },\n    });\n\n    // Chats\n  } else if (update instanceof GramJs.UpdateReadHistoryInbox) {\n    onUpdate({\n      '@type': 'updateChatInbox',\n      id: getApiChatIdFromMtpPeer(update.peer),\n      chat: {\n        lastReadInboxMessageId: update.maxId,\n        unreadCount: update.stillUnreadCount,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateReadHistoryOutbox) {\n    onUpdate({\n      '@type': 'updateChat',\n      id: getApiChatIdFromMtpPeer(update.peer),\n      chat: {\n        lastReadOutboxMessageId: update.maxId,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateReadChannelInbox) {\n    onUpdate({\n      '@type': 'updateChat',\n      id: buildApiPeerId(update.channelId, 'channel'),\n      chat: {\n        lastReadInboxMessageId: update.maxId,\n        unreadCount: update.stillUnreadCount,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateReadChannelOutbox) {\n    onUpdate({\n      '@type': 'updateChat',\n      id: buildApiPeerId(update.channelId, 'channel'),\n      chat: {\n        lastReadOutboxMessageId: update.maxId,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateReadChannelDiscussionInbox) {\n    onUpdate({\n      '@type': 'updateThreadInfo',\n      chatId: buildApiPeerId(update.channelId, 'channel'),\n      threadId: update.topMsgId,\n      threadInfo: {\n        lastReadInboxMessageId: update.readMaxId,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateReadChannelDiscussionOutbox) {\n    onUpdate({\n      '@type': 'updateChat',\n      id: buildApiPeerId(update.channelId, 'channel'),\n      chat: {\n        lastReadOutboxMessageId: update.readMaxId,\n      },\n    });\n  } else if (\n    update instanceof GramJs.UpdateDialogPinned\n    && update.peer instanceof GramJs.DialogPeer\n  ) {\n    onUpdate({\n      '@type': 'updateChatPinned',\n      id: getApiChatIdFromMtpPeer(update.peer.peer),\n      isPinned: update.pinned || false,\n    });\n  } else if (update instanceof GramJs.UpdatePinnedDialogs) {\n    const ids = update.order\n      ? update.order\n        .filter((dp): dp is GramJs.DialogPeer => dp instanceof GramJs.DialogPeer)\n        .map((dp) => getApiChatIdFromMtpPeer(dp.peer))\n      : [];\n\n    onUpdate({\n      '@type': 'updatePinnedChatIds',\n      ids,\n      folderId: update.folderId || undefined,\n    });\n  } else if (update instanceof GramJs.UpdateFolderPeers) {\n    update.folderPeers.forEach((folderPeer) => {\n      const { folderId, peer } = folderPeer;\n\n      onUpdate({\n        '@type': 'updateChatListType',\n        id: getApiChatIdFromMtpPeer(peer),\n        folderId,\n      });\n    });\n  } else if (update instanceof GramJs.UpdateDialogFilter) {\n    const { id, filter } = update;\n    const folder = filter instanceof GramJs.DialogFilter ? buildApiChatFolder(filter) : undefined;\n\n    onUpdate({\n      '@type': 'updateChatFolder',\n      id,\n      folder,\n    });\n  } else if (update instanceof GramJs.UpdateDialogFilterOrder) {\n    onUpdate({\n      '@type': 'updateChatFoldersOrder',\n      orderedIds: update.order,\n    });\n  } else if (update instanceof GramJs.UpdateChatParticipants) {\n    const replacedMembers = buildChatMembers(update.participants);\n\n    onUpdate({\n      '@type': 'updateChatMembers',\n      id: buildApiPeerId(update.participants.chatId, 'chat'),\n      replacedMembers,\n    });\n  } else if (update instanceof GramJs.UpdateChatParticipantAdd) {\n    const addedMember = buildChatMember(\n      pick(update, ['userId', 'inviterId', 'date']) as GramJs.ChatParticipant,\n    );\n\n    onUpdate({\n      '@type': 'updateChatMembers',\n      id: buildApiPeerId(update.chatId, 'chat'),\n      addedMember,\n    });\n  } else if (update instanceof GramJs.UpdateChatParticipantDelete) {\n    onUpdate({\n      '@type': 'updateChatMembers',\n      id: buildApiPeerId(update.chatId, 'chat'),\n      deletedMemberId: buildApiPeerId(update.userId, 'user'),\n    });\n  } else if (\n    update instanceof GramJs.UpdatePinnedMessages\n    || update instanceof GramJs.UpdatePinnedChannelMessages\n  ) {\n    const chatId = update instanceof GramJs.UpdatePinnedMessages\n      ? getApiChatIdFromMtpPeer(update.peer)\n      : buildApiPeerId(update.channelId, 'channel');\n\n    onUpdate({\n      '@type': 'updatePinnedIds',\n      chatId,\n      messageIds: update.messages,\n      isPinned: update.pinned,\n    });\n  } else if (\n    update instanceof GramJs.UpdateNotifySettings\n    && update.peer instanceof GramJs.NotifyPeer\n  ) {\n    onUpdate({\n      '@type': 'updateNotifyExceptions',\n      ...buildApiNotifyException(update.notifySettings, update.peer.peer),\n    });\n  } else if (\n    update instanceof GramJs.UpdateNotifySettings\n    && update.peer instanceof GramJs.NotifyForumTopic\n  ) {\n    onUpdate({\n      '@type': 'updateTopicNotifyExceptions',\n      ...buildApiNotifyExceptionTopic(\n        update.notifySettings, update.peer.peer, update.peer.topMsgId,\n      ),\n    });\n  } else if (\n    update instanceof GramJs.UpdateUserTyping\n    || update instanceof GramJs.UpdateChatUserTyping\n  ) {\n    const id = update instanceof GramJs.UpdateUserTyping\n      ? buildApiPeerId(update.userId, 'user')\n      : buildApiPeerId(update.chatId, 'chat');\n\n    if (update.action instanceof GramJs.SendMessageEmojiInteraction) {\n      onUpdate({\n        '@type': 'updateStartEmojiInteraction',\n        id,\n        emoji: update.action.emoticon,\n        messageId: update.action.msgId,\n        interaction: buildApiEmojiInteraction(JSON.parse(update.action.interaction.data)),\n      });\n    } else {\n      onUpdate({\n        '@type': 'updateChatTypingStatus',\n        id,\n        typingStatus: buildChatTypingStatus(update),\n      });\n    }\n  } else if (update instanceof GramJs.UpdateChannelUserTyping) {\n    const id = buildApiPeerId(update.channelId, 'channel');\n\n    onUpdate({\n      '@type': 'updateChatTypingStatus',\n      id,\n      threadId: update.topMsgId,\n      typingStatus: buildChatTypingStatus(update),\n    });\n  } else if (update instanceof GramJs.UpdateChannel) {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const { _entities } = update;\n    if (!_entities) {\n      return;\n    }\n\n    const channel = _entities.find((e): e is GramJs.Channel | GramJs.ChannelForbidden => (\n      e instanceof GramJs.Channel || e instanceof GramJs.ChannelForbidden\n    ));\n\n    if (channel instanceof GramJs.Channel) {\n      const chat = buildApiChatFromPreview(channel);\n      if (chat) {\n        onUpdate({\n          '@type': 'updateChat',\n          id: chat.id,\n          chat,\n        });\n\n        onUpdate({\n          '@type': chat.isNotJoined ? 'updateChatLeave' : 'updateChatJoin',\n          id: buildApiPeerId(update.channelId, 'channel'),\n        });\n      }\n    } else if (channel instanceof GramJs.ChannelForbidden) {\n      const chatId = buildApiPeerId(update.channelId, 'channel');\n\n      onUpdate({\n        '@type': 'updateChat',\n        id: chatId,\n        chat: {\n          isRestricted: true,\n        },\n      });\n\n      onUpdate({\n        '@type': 'updateChatLeave',\n        id: chatId,\n      });\n    } else if (_entities.length === 0) {\n      // The link to the discussion group may have been changed.\n      // No corresponding update available at this moment https://core.telegram.org/type/Updates\n      onUpdate({\n        '@type': 'resetMessages',\n        id: buildApiPeerId(update.channelId, 'channel'),\n      });\n    }\n  } else if (\n    update instanceof GramJs.UpdateDialogUnreadMark\n    && update.peer instanceof GramJs.DialogPeer\n  ) {\n    onUpdate({\n      '@type': 'updateChat',\n      id: getApiChatIdFromMtpPeer(update.peer.peer),\n      chat: {\n        hasUnreadMark: update.unread,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateChatDefaultBannedRights) {\n    onUpdate({\n      '@type': 'updateChat',\n      id: getApiChatIdFromMtpPeer(update.peer),\n      chat: {\n        defaultBannedRights: omitVirtualClassFields(update.defaultBannedRights),\n      },\n    });\n\n    // Users\n  } else if (update instanceof GramJs.UpdateUserStatus) {\n    onUpdate({\n      '@type': 'updateUserStatus',\n      userId: buildApiPeerId(update.userId, 'user'),\n      status: buildApiUserStatus(update.status),\n    });\n  } else if (update instanceof GramJs.UpdateUser) {\n    onUpdate({\n      '@type': 'updateRequestUserUpdate',\n      id: buildApiPeerId(update.userId, 'user'),\n    });\n  } else if (update instanceof GramJs.UpdateUserEmojiStatus) {\n    const emojiStatus = buildApiUserEmojiStatus(update.emojiStatus);\n    onUpdate({\n      '@type': 'updateUserEmojiStatus',\n      userId: buildApiPeerId(update.userId, 'user'),\n      emojiStatus,\n    });\n  } else if (update instanceof GramJs.UpdateUserName) {\n    const apiUserId = buildApiPeerId(update.userId, 'user');\n    const updatedUser = localDb.users[apiUserId];\n\n    const user = updatedUser?.mutualContact && !updatedUser.self\n      ? pick(update, [])\n      : pick(update, ['firstName', 'lastName']);\n\n    const usernames = buildApiUsernames(update);\n\n    onUpdate({\n      '@type': 'updateUser',\n      id: apiUserId,\n      user: {\n        ...user,\n        usernames,\n      },\n    });\n  } else if (update instanceof GramJs.UpdateUserPhone) {\n    const { userId, phone } = update;\n\n    onUpdate({\n      '@type': 'updateUser',\n      id: buildApiPeerId(userId, 'user'),\n      user: { phoneNumber: phone },\n    });\n  } else if (update instanceof GramJs.UpdatePeerSettings) {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const { _entities, settings } = update;\n    if (!_entities) {\n      return;\n    }\n\n    if (_entities?.length) {\n      _entities\n        .filter((e) => e instanceof GramJs.User && !e.contact)\n        .forEach((user) => {\n          onUpdate({\n            '@type': 'deleteContact',\n            id: buildApiPeerId(user.id, 'user'),\n          });\n        });\n\n      _entities\n        .filter((e) => e instanceof GramJs.User && e.contact)\n        .map(buildApiUser)\n        .forEach((user) => {\n          if (!user) {\n            return;\n          }\n\n          onUpdate({\n            '@type': 'updateUser',\n            id: user.id,\n            user: {\n              ...user,\n              ...(settings && { settings: buildApiChatSettings(settings) }),\n            },\n          });\n        });\n    }\n\n    // Settings\n  } else if (update instanceof GramJs.UpdateNotifySettings) {\n    const {\n      notifySettings: {\n        showPreviews, silent, muteUntil,\n      },\n      peer: { className },\n    } = update;\n\n    const peerType = className === 'NotifyUsers'\n      ? 'contact'\n      : (className === 'NotifyChats'\n        ? 'group'\n        : (className === 'NotifyBroadcasts'\n          ? 'broadcast'\n          : undefined\n        )\n      );\n\n    if (!peerType) {\n      return;\n    }\n\n    onUpdate({\n      '@type': 'updateNotifySettings',\n      peerType,\n      isSilent: Boolean(silent\n        || (typeof muteUntil === 'number' && Date.now() + getServerTimeOffset() * 1000 < muteUntil * 1000)),\n      shouldShowPreviews: Boolean(showPreviews),\n    });\n  } else if (update instanceof GramJs.UpdatePeerBlocked) {\n    onUpdate({\n      '@type': 'updatePeerBlocked',\n      id: getApiChatIdFromMtpPeer(update.peerId),\n      isBlocked: update.blocked,\n    });\n  } else if (update instanceof GramJs.UpdatePrivacy) {\n    const key = buildPrivacyKey(update.key);\n    if (key) {\n      onUpdate({\n        '@type': 'updatePrivacy',\n        key,\n        rules: buildPrivacyRules(update.rules),\n      });\n    }\n\n    // Misc\n  } else if (update instanceof GramJs.UpdateDraftMessage) {\n    onUpdate({\n      '@type': 'draftMessage',\n      chatId: getApiChatIdFromMtpPeer(update.peer),\n      threadId: update.topMsgId,\n      ...buildMessageDraft(update.draft),\n    });\n  } else if (update instanceof GramJs.UpdateContactsReset) {\n    onUpdate({ '@type': 'updateResetContactList' });\n  } else if (update instanceof GramJs.UpdateFavedStickers) {\n    onUpdate({ '@type': 'updateFavoriteStickers' });\n  } else if (update instanceof GramJs.UpdateRecentStickers) {\n    onUpdate({ '@type': 'updateRecentStickers' });\n  } else if (update instanceof GramJs.UpdateMoveStickerSetToTop) {\n    if (!update.masks) {\n      onUpdate({\n        '@type': 'updateMoveStickerSetToTop',\n        isCustomEmoji: update.emojis,\n        id: update.stickerset.toString(),\n      });\n    }\n  } else if (update instanceof GramJs.UpdateStickerSets) {\n    onUpdate({ '@type': 'updateStickerSets' });\n  } else if (update instanceof GramJs.UpdateStickerSetsOrder) {\n    if (!update.masks) {\n      onUpdate({\n        '@type': 'updateStickerSetsOrder',\n        order: update.order.map((n) => n.toString()),\n        isCustomEmoji: update.emojis,\n      });\n    }\n  } else if (update instanceof GramJs.UpdateNewStickerSet) {\n    if (update.stickerset instanceof GramJs.messages.StickerSet) {\n      const stickerSet = buildStickerSet(update.stickerset.set);\n      onUpdate({\n        '@type': 'updateStickerSet',\n        id: stickerSet.id,\n        stickerSet,\n      });\n    }\n  } else if (update instanceof GramJs.UpdateSavedGifs) {\n    onUpdate({ '@type': 'updateSavedGifs' });\n  } else if (update instanceof GramJs.UpdateGroupCall) {\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n\n    onUpdate({\n      '@type': 'updateGroupCall',\n      call: buildApiGroupCall(update.call),\n    });\n  } else if (update instanceof GramJs.UpdateGroupCallConnection) {\n    onUpdate({\n      '@type': 'updateGroupCallConnection',\n      data: JSON.parse(update.params.data) as GroupCallConnectionData,\n      presentation: Boolean(update.presentation),\n    });\n  } else if (update instanceof GramJs.UpdateGroupCallParticipants) {\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n\n    onUpdate({\n      '@type': 'updateGroupCallParticipants',\n      groupCallId: getGroupCallId(update.call),\n      participants: update.participants.map(buildApiGroupCallParticipant),\n    });\n  } else if (update instanceof GramJs.UpdatePendingJoinRequests) {\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n\n    onUpdate({\n      '@type': 'updatePendingJoinRequests',\n      chatId: getApiChatIdFromMtpPeer(update.peer),\n      recentRequesterIds: update.recentRequesters.map((id) => buildApiPeerId(id, 'user')),\n      requestsPending: update.requestsPending,\n    });\n  } else if (update instanceof GramJs.UpdatePhoneCall) {\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n\n    onUpdate({\n      '@type': 'updatePhoneCall',\n      call: buildPhoneCall(update.phoneCall),\n    });\n  } else if (update instanceof GramJs.UpdatePhoneCallSignalingData) {\n    onUpdate({\n      '@type': 'updatePhoneCallSignalingData',\n      callId: update.phoneCallId.toString(),\n      data: Array.from(update.data),\n    });\n  } else if (update instanceof GramJs.UpdateWebViewResultSent) {\n    const { queryId } = update;\n\n    onUpdate({\n      '@type': 'updateWebViewResultSent',\n      queryId: queryId.toString(),\n    });\n  } else if (update instanceof GramJs.UpdateBotMenuButton) {\n    const {\n      botId,\n      button,\n    } = update;\n\n    const id = buildApiPeerId(botId, 'user');\n\n    onUpdate({\n      '@type': 'updateBotMenuButton',\n      botId: id,\n      button: buildApiBotMenuButton(button),\n    });\n  } else if (update instanceof GramJs.UpdateTranscribedAudio) {\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n\n    onUpdate({\n      '@type': 'updateTranscribedAudio',\n      transcriptionId: update.transcriptionId.toString(),\n      text: update.text,\n      isPending: update.pending,\n    });\n  } else if (update instanceof GramJs.UpdateConfig) {\n    // eslint-disable-next-line no-underscore-dangle\n    const entities = update._entities;\n    if (entities) {\n      addEntitiesWithPhotosToLocalDb(entities);\n      dispatchUserAndChatUpdates(entities);\n    }\n    onUpdate({ '@type': 'updateConfig' });\n  } else if (update instanceof GramJs.UpdateChannelPinnedTopic) {\n    onUpdate({\n      '@type': 'updatePinnedTopic',\n      chatId: buildApiPeerId(update.channelId, 'channel'),\n      topicId: update.topicId,\n      isPinned: Boolean(update.pinned),\n    });\n  } else if (update instanceof GramJs.UpdateChannelPinnedTopics) {\n    onUpdate({\n      '@type': 'updatePinnedTopicsOrder',\n      chatId: buildApiPeerId(update.channelId, 'channel'),\n      order: update.order || [],\n    });\n  } else if (update instanceof GramJs.UpdateRecentEmojiStatuses) {\n    onUpdate({ '@type': 'updateRecentEmojiStatuses' });\n  } else if (DEBUG) {\n    const params = typeof update === 'object' && 'className' in update ? update.className : update;\n    log('UNEXPECTED UPDATE', params);\n  }\n}\n","import type {RequiredGlobalActions} from '../../index';\nimport {addActionHandler, getGlobal, setGlobal,} from '../../index';\n\nimport type {ApiChat, ApiChatFolder, ApiChatMember, ApiError, ApiUser, ApiUserStatus,} from '../../../api/types';\nimport {MAIN_THREAD_ID} from '../../../api/types';\nimport {ChatCreationProgress, ManagementProgress, NewChatMembersProgress} from '../../../types';\nimport type {ActionReturnType, GlobalState, TabArgs,} from '../../types';\n\nimport {\n  ALL_FOLDER_ID,\n  ARCHIVED_FOLDER_ID,\n  DEBUG,\n  RE_TG_LINK,\n  SERVICE_NOTIFICATIONS_USER_ID,\n  TME_WEB_DOMAINS,\n  TMP_CHAT_ID,\n  TOP_CHAT_MESSAGES_PRELOAD_LIMIT,\n  TOPICS_SLICE,\n  TOPICS_SLICE_SECOND_LOAD,\n} from '../../../config';\nimport {callApi} from '../../../api/gramjs';\nimport {\n  addChatMembers,\n  addChats,\n  addMessages,\n  addUsers,\n  addUserStatuses,\n  deleteTopic,\n  leaveChat,\n  replaceChatListIds,\n  replaceChats,\n  replaceThreadParam,\n  replaceUsers,\n  replaceUserStatuses,\n  updateChat,\n  updateChatListIds,\n  updateChatListSecondaryInfo,\n  updateChats,\n  updateListedTopicIds,\n  updateManagementProgress,\n  updateThreadInfo,\n  updateTopic,\n  updateTopics,\n  updateUser,\n} from '../../reducers';\nimport {\n  selectChat,\n  selectChatByUsername,\n  selectChatFolder,\n  selectChatListType,\n  selectCurrentChat,\n  selectCurrentMessageList,\n  selectDraft,\n  selectIsChatPinned,\n  selectLastServiceNotification,\n  selectSupportChat,\n  selectTabState,\n  selectThread,\n  selectThreadInfo,\n  selectThreadOriginChat,\n  selectThreadTopMessageId,\n  selectUser,\n  selectUserByPhoneNumber,\n  selectVisibleUsers,\n} from '../../selectors';\nimport {buildCollectionByKey, omit} from '../../../util/iteratees';\nimport {debounce, pause, throttle} from '../../../util/schedulers';\nimport {\n  isChatArchived,\n  isChatBasicGroup,\n  isChatChannel,\n  isChatSummaryOnly,\n  isChatSuperGroup,\n  isUserBot,\n} from '../../helpers';\nimport {formatShareText, parseChooseParameter, processDeepLink} from '../../../util/deeplink';\nimport {updateGroupCall} from '../../reducers/calls';\nimport {selectGroupCall} from '../../selectors/calls';\nimport {getOrderedIds} from '../../../util/folderManager';\nimport * as langProvider from '../../../util/langProvider';\nimport {selectCurrentLimit} from '../../selectors/limits';\nimport {updateTabState} from '../../reducers/tabs';\nimport {getCurrentTabId} from '../../../util/establishMultitabRole';\nimport {\n  ChatModelConfig, DEFAULT_AI_CONFIG_COMMANDS,\n  DEFAULT_BOT_COMMANDS,\n  DEFAULT_CREATE_USER_BIO,\n  LoadAllChats,\n  UserIdFirstBot\n} from \"../../../worker/setting\";\nimport {Api} from \"../../../lib/gramjs\";\nimport MsgCommandSetting from \"../../../worker/msg/MsgCommandSetting\";\n\nconst TOP_CHAT_MESSAGES_PRELOAD_INTERVAL = 100;\nconst INFINITE_LOOP_MARKER = 100;\n\nconst SERVICE_NOTIFICATIONS_USER_MOCK: ApiUser = {\n  id: SERVICE_NOTIFICATIONS_USER_ID,\n  accessHash: '0',\n  type: 'userTypeRegular',\n  isMin: true,\n  phoneNumber: '',\n};\n\nconst runThrottledForLoadTopChats = throttle((cb) => cb(), 3000, true);\nconst runDebouncedForLoadFullChat = debounce((cb) => cb(), 500, false, true);\n\naddActionHandler('preloadTopChatMessages', async (global, actions): Promise<void> => {\n  const preloadedChatIds = new Set<string>();\n\n  for (let i = 0; i < TOP_CHAT_MESSAGES_PRELOAD_LIMIT; i++) {\n    await pause(TOP_CHAT_MESSAGES_PRELOAD_INTERVAL);\n\n    global = getGlobal();\n    const currentChatIds = Object.values(global.byTabId)\n      // eslint-disable-next-line @typescript-eslint/no-loop-func\n      .map(({ id: tabId }) => selectCurrentMessageList(global, tabId)?.chatId)\n      .filter(Boolean);\n\n    const folderAllOrderedIds = getOrderedIds(ALL_FOLDER_ID);\n    const nextChatId = folderAllOrderedIds?.find((id) => !currentChatIds.includes(id) && !preloadedChatIds.has(id));\n    if (!nextChatId) {\n      return;\n    }\n\n    preloadedChatIds.add(nextChatId);\n\n    actions.loadViewportMessages({ chatId: nextChatId, threadId: MAIN_THREAD_ID, tabId: getCurrentTabId() });\n  }\n});\n\naddActionHandler('openChat', (global, actions, payload): ActionReturnType => {\n  const {\n    id, threadId = MAIN_THREAD_ID,\n  } = payload;\n  if (!id) {\n    return;\n  }\n\n  const { currentUserId } = global;\n  const chat = selectChat(global, id);\n\n  if (chat?.hasUnreadMark) {\n    actions.toggleChatUnread({ id });\n  }\n\n  if (!chat) {\n    if (id === currentUserId) {\n      void callApi('fetchChat', { type: 'self' });\n    } else {\n      const user = selectUser(global, id);\n      if (user) {\n        void callApi('fetchChat', { type: 'user', user });\n      }\n    }\n  } else if (isChatSummaryOnly(chat) && !chat.isMin) {\n    //todo\n    // actions.requestChatUpdate({ chatId: id });\n  }\n\n  if (threadId !== MAIN_THREAD_ID) {\n    actions.requestThreadInfoUpdate({ chatId: id, threadId });\n  }\n});\n\naddActionHandler('openComments', async (global, actions, payload): Promise<void> => {\n  const {\n    id, threadId, originChannelId, tabId = getCurrentTabId(),\n  } = payload;\n\n  if (threadId !== MAIN_THREAD_ID) {\n    const topMessageId = selectThreadTopMessageId(global, id, threadId);\n    if (!topMessageId) {\n      const chat = selectThreadOriginChat(global, id, threadId);\n      if (!chat) {\n        return;\n      }\n\n      actions.openChat({ id: TMP_CHAT_ID, tabId });\n\n      const result = await callApi('requestThreadInfoUpdate', { chat, threadId, originChannelId });\n      if (!result) {\n        actions.openPreviousChat({ tabId });\n        return;\n      }\n      global = getGlobal();\n      global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n      setGlobal(global);\n\n      actions.openChat({ id, threadId: result.topMessageId, tabId });\n    } else {\n      actions.openChat({ id, threadId: topMessageId, tabId });\n    }\n  }\n});\n\naddActionHandler('openLinkedChat', async (global, actions, payload): Promise<void> => {\n  const { id, tabId = getCurrentTabId() } = payload!;\n  const chat = selectChat(global, id);\n  if (!chat) {\n    return;\n  }\n\n  const chatFullInfo = await callApi('fetchFullChat', chat);\n\n  if (chatFullInfo?.fullInfo?.linkedChatId) {\n    actions.openChat({ id: chatFullInfo.fullInfo.linkedChatId, tabId });\n  }\n});\n\naddActionHandler('focusMessageInComments', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, threadId, messageId, tabId = getCurrentTabId(),\n  } = payload!;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  const result = await callApi('requestThreadInfoUpdate', { chat, threadId });\n  if (!result) {\n    return;\n  }\n  global = getGlobal();\n  global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n  setGlobal(global);\n\n  actions.focusMessage({\n    chatId, threadId, messageId, tabId,\n  });\n});\n\naddActionHandler('openSupportChat', async (global, actions, payload): Promise<void> => {\n  const { tabId = getCurrentTabId() } = payload || {};\n  const chat = selectSupportChat(global);\n  if (chat) {\n    actions.openChat({ id: chat.id, shouldReplaceHistory: true, tabId });\n    return;\n  }\n\n  actions.openChat({ id: TMP_CHAT_ID, shouldReplaceHistory: true, tabId });\n\n  const result = await callApi('fetchChat', { type: 'support' });\n  if (result) {\n    actions.openChat({ id: result.chatId, shouldReplaceHistory: true, tabId });\n  }\n});\n\naddActionHandler('loadAllChats', async (global, actions, payload): Promise<void> => {\n  const listType = payload.listType as 'active' | 'archived';\n  if(listType === \"archived\"){\n    return;\n  }\n  const { onReplace } = payload;\n  let { shouldReplace } = payload;\n  let i = 0;\n\n  const getOrderDate = (chat: ApiChat) => {\n    return chat.lastMessage?.date || chat.joinDate;\n  };\n  while (shouldReplace || !global.chats.isFullyLoaded[listType]) {\n    if (i++ >= INFINITE_LOOP_MARKER) {\n      if (DEBUG) {\n        // eslint-disable-next-line no-console\n        console.error('`actions/loadAllChats`: Infinite loop detected');\n      }\n      return;\n    }\n\n    global = getGlobal();\n\n    if (\n      !(\n        global.msgClientState === 'connectionStateLogged' ||\n        global.msgClientState === 'connectionStateWaitingLogin'||\n        global.msgClientState === 'connectionStateConnected'\n      ) ) {\n      return;\n    }\n\n    const listIds = !shouldReplace && global.chats.listIds[listType];\n    const oldestChat = listIds\n      ? listIds\n        /* eslint-disable @typescript-eslint/no-loop-func */\n        .map((id) => global.chats.byId[id])\n        .filter((chat) => (\n          Boolean(chat && getOrderDate(chat))\n          && chat.id !== SERVICE_NOTIFICATIONS_USER_ID\n          && !selectIsChatPinned(global, chat.id)\n        ))\n        /* eslint-enable @typescript-eslint/no-loop-func */\n        .sort((chat1, chat2) => getOrderDate(chat1)! - getOrderDate(chat2)!)[0]\n      : undefined;\n    await loadChats(global,\n      listType,\n      oldestChat?.id,\n      oldestChat ? getOrderDate(oldestChat) : undefined,\n      shouldReplace,\n      true,\n    );\n\n    if (shouldReplace) {\n      onReplace?.();\n      shouldReplace = false;\n    }\n\n    global = getGlobal();\n  }\n});\n\naddActionHandler('loadFullChat', (global, actions, payload): ActionReturnType => {\n  const { chatId, force, tabId = getCurrentTabId() } = payload!;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  if (force) {\n    loadFullChat(global, actions, chat, tabId);\n  } else {\n    runDebouncedForLoadFullChat(() => loadFullChat(global, actions, chat, tabId));\n  }\n});\n\naddActionHandler('loadTopChats', (global): ActionReturnType => {\n  runThrottledForLoadTopChats(() => loadChats(global, 'active'));\n});\n\naddActionHandler('requestChatUpdate', (global, actions, payload): ActionReturnType => {\n  const { chatId } = payload!;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  void callApi('requestChatUpdate', {\n    chat,\n    ...(chatId === SERVICE_NOTIFICATIONS_USER_ID && {\n      lastLocalMessage: selectLastServiceNotification(global)?.message,\n    }),\n  });\n});\n\naddActionHandler('updateChatMutedState', (global, actions, payload): ActionReturnType => {\n  const { chatId, isMuted } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  global = updateChat(global, chatId, { isMuted });\n  setGlobal(global);\n  void callApi('updateChatMutedState', { chat, isMuted });\n});\n\naddActionHandler('updateTopicMutedState', (global, actions, payload): ActionReturnType => {\n  const { chatId, isMuted, topicId } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  global = updateTopic(global, chatId, topicId, { isMuted });\n  setGlobal(global);\n  void callApi('updateTopicMutedState', {\n    chat, topicId, isMuted,\n  });\n});\n\naddActionHandler('createChannel', async (global, actions, payload): Promise<void> => {\n  const {\n    title, about, photo, memberIds, tabId = getCurrentTabId(),\n  } = payload;\n\n  const users = (memberIds as string[])\n    .map((id) => selectUser(global, id))\n    .filter(Boolean);\n\n  global = updateTabState(global, {\n    chatCreation: {\n      progress: ChatCreationProgress.InProgress,\n    },\n  }, tabId);\n  setGlobal(global);\n\n  let createdChannel: ApiChat | undefined;\n\n  try {\n    createdChannel = await callApi('createChannel', { title, about, users });\n  } catch (error) {\n    global = getGlobal();\n\n    global = updateTabState(global, {\n      chatCreation: {\n        progress: ChatCreationProgress.Error,\n      },\n    }, tabId);\n\n    setGlobal(global);\n\n    if ((error as ApiError).message === 'CHANNELS_TOO_MUCH') {\n      actions.openLimitReachedModal({ limit: 'channels', tabId });\n    } else {\n      actions.showDialog({ data: { ...(error as ApiError), hasErrorKey: true }, tabId });\n    }\n  }\n\n  if (!createdChannel) {\n    return;\n  }\n\n  const { id: channelId, accessHash } = createdChannel;\n\n  global = getGlobal();\n  global = updateChat(global, channelId, createdChannel);\n  global = updateTabState(global, {\n    chatCreation: {\n      ...selectTabState(global, tabId).chatCreation,\n      progress: createdChannel ? ChatCreationProgress.Complete : ChatCreationProgress.Error,\n    },\n  }, tabId);\n  setGlobal(global);\n  actions.openChat({ id: channelId, shouldReplaceHistory: true, tabId });\n\n  if (channelId && accessHash && photo) {\n    await callApi('editChatPhoto', { chatId: channelId, accessHash, photo });\n  }\n});\n\naddActionHandler('joinChannel', async (global, actions, payload): Promise<void> => {\n  const { chatId, tabId = getCurrentTabId() } = payload!;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  const { id: channelId, accessHash } = chat;\n\n  if (!(channelId && accessHash)) {\n    return;\n  }\n\n  try {\n    await callApi('joinChannel', { channelId, accessHash });\n  } catch (error) {\n    if ((error as ApiError).message === 'CHANNELS_TOO_MUCH') {\n      actions.openLimitReachedModal({ limit: 'channels', tabId });\n    } else {\n      actions.showDialog({ data: { ...(error as ApiError), hasErrorKey: true }, tabId });\n    }\n  }\n});\n\naddActionHandler('deleteChatUser', (global, actions, payload): ActionReturnType => {\n  const { chatId, userId, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  const user = selectUser(global, userId);\n  if (!chat || !user) {\n    return;\n  }\n\n  global = leaveChat(global, chatId);\n  setGlobal(global);\n\n  if (selectCurrentMessageList(global, tabId)?.chatId === chatId) {\n    actions.openChat({ id: undefined, tabId });\n  }\n\n  void callApi('deleteChatUser', { chat, user });\n});\n\naddActionHandler('deleteChat', (global, actions, payload): ActionReturnType => {\n  const { chatId, tabId = getCurrentTabId() } = payload!;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  global = leaveChat(global, chatId);\n  setGlobal(global);\n\n  if (selectCurrentMessageList(global, tabId)?.chatId === chatId) {\n    actions.openChat({ id: undefined, tabId });\n  }\n\n  void callApi('deleteChat', { chatId: chat.id });\n});\n\naddActionHandler('leaveChannel', (global, actions, payload): ActionReturnType => {\n  const { chatId, tabId = getCurrentTabId() } = payload!;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  global = leaveChat(global, chatId);\n  setGlobal(global);\n\n  if (selectCurrentMessageList(global, tabId)?.chatId === chatId) {\n    actions.openChat({ id: undefined, tabId });\n  }\n\n  const { id: channelId, accessHash } = chat;\n  if (channelId && accessHash) {\n    void callApi('leaveChannel', { channelId, accessHash });\n  }\n});\n\naddActionHandler('deleteChannel', (global, actions, payload): ActionReturnType => {\n  const { chatId, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  global = leaveChat(global, chatId);\n  setGlobal(global);\n\n  if (selectCurrentMessageList(global, tabId)?.chatId === chatId) {\n    actions.openChat({ id: undefined, tabId });\n  }\n\n  const { id: channelId, accessHash } = chat;\n  if (channelId && accessHash) {\n    void callApi('deleteChannel', { channelId, accessHash });\n  }\n});\n\naddActionHandler('createChat', async (global, actions, payload): Promise<void> => {\n  const {\n    title, about, tabId = getCurrentTabId(),\n  } = payload;\n\n  global = updateTabState(global, {\n    chatCreation: {\n      progress: ChatCreationProgress.InProgress,\n    },\n  }, tabId);\n  setGlobal(global);\n  try{\n    const userIds = Object.keys(global.users.byId)\n    let userId = UserIdFirstBot + 1\n    if(userIds.length > 0){\n      userIds.sort((a,b)=>parseInt(b) - parseInt(a))\n      userId = userIds[0] + 1\n    }\n    const user = {\n      \"canBeInvitedToGroup\": false,\n      \"hasVideoAvatar\": false,\n      \"type\": \"userTypeBot\",\n      id:userId,\n      \"phoneNumber\": \"\",\n      isMin:false,\n      \"noStatus\": true,\n      isSelf:false,\n      avatarHash:\"\",\n      accessHash:\"\",\n      isPremium: false,\n      firstName: title,\n      photos:[],\n      usernames: [\n        {\n          \"username\": \"Bot_\"+userId,\n          \"isActive\": true,\n          \"isEditable\": true\n        }\n      ],\n      fullInfo: {\n        \"isBlocked\": false,\n        \"noVoiceMessages\": false,\n        bio: about || DEFAULT_CREATE_USER_BIO,\n        botInfo: {\n          aiBot:{\n            enableAi:true,\n            chatGptConfig:{\n              init_system_content:\"\",\n              api_key:\"\",\n              max_history_length:10,\n              config:ChatModelConfig\n            }\n          },\n          botId: userId,\n          \"description\": about || DEFAULT_CREATE_USER_BIO,\n          \"menuButton\": {\n            \"type\": \"commands\"\n          },\n          commands:DEFAULT_AI_CONFIG_COMMANDS.map(cmd=>{\n            cmd.botId = userId;\n            return cmd\n          })\n        }\n      }\n    }\n    global = getGlobal()\n    const {chatFolders} = global;\n    // @ts-ignore\n    const users:ApiUser[] = [user]\n// @ts-ignore\n    const chats:ApiChat[] = [MsgCommandSetting.buildDefaultChat(user)]\n\n    let activeChatFolder = window.sessionStorage.getItem(\"activeChatFolder\")\n    let activeChatFolderRow;\n    const chatFolderById:Record<string, ApiChatFolder> = {};\n    if(activeChatFolder){\n      // @ts-ignore\n      Object.values(chatFolders.byId).forEach((row:ApiChatFolder)=>{\n        if(row.id === parseInt(activeChatFolder!)){\n          activeChatFolderRow = row;\n          if(!row.includedChatIds){\n            row.includedChatIds = []\n          }\n          row.includedChatIds.push(userId)\n          chatFolderById[row.id] = row;\n        }\n      })\n    }\n\n\n    const userStatusesById:Record<string,ApiUserStatus> = {\n      [user.id] : {\n        \"type\": \"userStatusEmpty\"\n      }\n    }\n\n    global = getGlobal();\n    global = addUsers(global, buildCollectionByKey(users, 'id'));\n    global = addChats(global, buildCollectionByKey(chats, 'id'));\n    global = updateChatListIds(global, \"active\", chats.map(chat=>chat.id));\n    global = addUserStatuses(global, userStatusesById);\n    global = updateTabState(global, {\n      chatCreation: {\n        ...selectTabState(global, tabId).chatCreation,\n        progress: ChatCreationProgress.Complete,\n      },\n    }, tabId);\n\n    setGlobal({\n      ...global,\n      chatFolders:{\n        ...global.chatFolders,\n        byId:{\n          ...global.chatFolders.byId,\n          ...chatFolderById\n        }\n\n      }\n    })\n\n    if(activeChatFolderRow){\n      actions.editChatFolder({ id: activeChatFolderRow.id, folderUpdate: activeChatFolderRow });\n    }\n    // @ts-ignore\n    actions.openChat({id: userId,shouldReplaceHistory: true,});\n\n  }catch (e){\n    // debugger\n    console.error(e)\n    global = getGlobal();\n    global = updateTabState(global, {\n      chatCreation: {\n        ...selectTabState(global, tabId).chatCreation,\n        progress: ChatCreationProgress.Error,\n        error: '创建失败',\n      },\n    }, tabId);\n    setGlobal(global);\n  }\n})\naddActionHandler('createGroupChat', async (global, actions, payload): Promise<void> => {\n  const {\n    title, memberIds, photo, tabId = getCurrentTabId(),\n  } = payload;\n  const users = (memberIds as string[])\n    .map((id) => selectUser(global, id))\n    .filter(Boolean);\n\n  global = updateTabState(global, {\n    chatCreation: {\n      progress: ChatCreationProgress.InProgress,\n    },\n  }, tabId);\n  setGlobal(global);\n\n  try {\n    const createdChat = await callApi('createGroupChat', {\n      title,\n      users,\n    });\n\n    if (!createdChat) {\n      return;\n    }\n\n    const { id: chatId } = createdChat;\n\n    global = getGlobal();\n    global = updateChat(global, chatId, createdChat);\n    global = updateTabState(global, {\n      chatCreation: {\n        ...selectTabState(global, tabId).chatCreation,\n        progress: createdChat ? ChatCreationProgress.Complete : ChatCreationProgress.Error,\n      },\n    }, tabId);\n    setGlobal(global);\n    actions.openChat({\n      id: chatId,\n      shouldReplaceHistory: true,\n      tabId,\n    });\n\n    if (chatId && photo) {\n      await callApi('editChatPhoto', {\n        chatId,\n        photo,\n      });\n    }\n  } catch (e: any) {\n    if (e.message === 'USERS_TOO_FEW') {\n      global = getGlobal();\n      global = updateTabState(global, {\n        chatCreation: {\n          ...selectTabState(global, tabId).chatCreation,\n          progress: ChatCreationProgress.Error,\n          error: 'CreateGroupError',\n        },\n      }, tabId);\n      setGlobal(global);\n    }\n  }\n});\n\naddActionHandler('toggleChatPinned', (global, actions, payload): ActionReturnType => {\n  const { id, folderId, tabId = getCurrentTabId() } = payload!;\n  const chat = selectChat(global, id);\n  if (!chat) {\n    return;\n  }\n\n  const limit = selectCurrentLimit(global, 'dialogFolderPinned');\n\n  if (folderId) {\n    const folder = selectChatFolder(global, folderId);\n    if (folder) {\n      const shouldBePinned = !selectIsChatPinned(global, id, folderId);\n\n      const { pinnedChatIds, includedChatIds } = folder;\n      const newPinnedIds = shouldBePinned\n        ? [id, ...(pinnedChatIds || [])]\n        : (pinnedChatIds || []).filter((pinnedId) => pinnedId !== id);\n\n      // With both Pin and Unpin we need to re-add a user to the included group\n      const newIncludedChatIds = [id, ...includedChatIds];\n\n      void callApi('editChatFolder', {\n        id: folderId,\n        folderUpdate: {\n          ...folder,\n          pinnedChatIds: newPinnedIds,\n          includedChatIds: newIncludedChatIds,\n        },\n      });\n    }\n  } else {\n    const listType = selectChatListType(global, id);\n    const isPinned = selectIsChatPinned(global, id, listType === 'archived' ? ARCHIVED_FOLDER_ID : undefined);\n\n    const ids = global.chats.orderedPinnedIds[listType === 'archived' ? 'archived' : 'active'];\n    if ((ids?.length || 0) >= limit && !isPinned) {\n      actions.openLimitReachedModal({\n        limit: 'dialogFolderPinned',\n        tabId,\n      });\n      return;\n    }\n    void callApi('toggleChatPinned', { chat, shouldBePinned: !isPinned });\n  }\n});\n\naddActionHandler('toggleChatArchived', (global, actions, payload): ActionReturnType => {\n  const { id } = payload!;\n  const chat = selectChat(global, id);\n  if (chat) {\n    void callApi('toggleChatArchived', {\n      chat,\n      folderId: isChatArchived(chat) ? 0 : ARCHIVED_FOLDER_ID,\n    });\n  }\n});\n\naddActionHandler('loadChatFolders', async (global): Promise<void> => {\n  const chatFolders = await callApi('fetchChatFolders');\n\n  if (chatFolders) {\n    global = getGlobal();\n\n    global = {\n      ...global,\n      chatFolders: {\n        ...global.chatFolders,\n        ...chatFolders,\n      },\n    };\n    setGlobal(global);\n  }\n});\n\naddActionHandler('loadRecommendedChatFolders', async (global): Promise<void> => {\n  const recommendedChatFolders = await callApi('fetchRecommendedChatFolders');\n\n  if (recommendedChatFolders) {\n    global = getGlobal();\n\n    global = {\n      ...global,\n      chatFolders: {\n        ...global.chatFolders,\n        recommended: recommendedChatFolders,\n      },\n    };\n    setGlobal(global);\n  }\n});\n\naddActionHandler('editChatFolders', (global, actions, payload): ActionReturnType => {\n  const {\n    chatId, idsToRemove, idsToAdd, tabId = getCurrentTabId(),\n  } = payload;\n  const limit = selectCurrentLimit(global, 'dialogFiltersChats');\n  const isLimitReached = idsToAdd\n    .some((id) => selectChatFolder(global, id)!.includedChatIds.length >= limit);\n  if (isLimitReached) {\n    actions.openLimitReachedModal({ limit: 'dialogFiltersChats', tabId });\n    return;\n  }\n\n  idsToRemove.forEach(async (id) => {\n    const folder = selectChatFolder(global, id);\n    if (folder) {\n      await callApi('editChatFolder', {\n        id,\n        folderUpdate: {\n          ...folder,\n          pinnedChatIds: folder.pinnedChatIds?.filter((pinnedId) => pinnedId !== chatId),\n          includedChatIds: folder.includedChatIds.filter((includedId) => includedId !== chatId),\n        },\n      });\n    }\n  });\n\n  idsToAdd.forEach(async (id) => {\n    const folder = selectChatFolder(global, id);\n    if (folder) {\n      await callApi('editChatFolder', {\n        id,\n        folderUpdate: {\n          ...folder,\n          includedChatIds: folder.includedChatIds.concat(chatId),\n        },\n      });\n    }\n  });\n});\n\naddActionHandler('editChatFolder', (global, actions, payload): ActionReturnType => {\n  const { id, folderUpdate } = payload!;\n  const folder = selectChatFolder(global, id);\n  if (folder) {\n    void callApi('editChatFolder', {\n      id,\n      folderUpdate: {\n        id,\n        emoticon: folder.emoticon,\n        pinnedChatIds: folder.pinnedChatIds,\n        ...folderUpdate,\n      },\n    });\n  }\n});\n\naddActionHandler('addChatFolder', async (global, actions, payload): Promise<void> => {\n  const { folder, tabId = getCurrentTabId() } = payload!;\n  const { orderedIds, byId } = global.chatFolders;\n\n  const limit = selectCurrentLimit(global, 'dialogFilters');\n  if (Object.keys(byId).length >= limit) {\n    actions.openLimitReachedModal({\n      limit: 'dialogFilters',\n      tabId,\n    });\n    return;\n  }\n\n  const maxId = Math.max(...(orderedIds || []), ARCHIVED_FOLDER_ID);\n\n  // Clear fields from recommended folders\n  const { id: recommendedId, description, ...newFolder } = folder;\n\n  await callApi('editChatFolder', {\n    id: maxId + 1,\n    folderUpdate: {\n      id: maxId + 1,\n      ...newFolder,\n    },\n  });\n\n  if (!description) {\n    return;\n  }\n\n  global = getGlobal();\n  const { recommended } = global.chatFolders;\n\n  if (recommended) {\n    global = {\n      ...global,\n      chatFolders: {\n        ...global.chatFolders,\n        recommended: recommended.filter(({ id }) => id !== recommendedId),\n      },\n    };\n    setGlobal(global);\n  }\n});\n\naddActionHandler('sortChatFolders', async (global, actions, payload): Promise<void> => {\n  const { folderIds } = payload!;\n\n  const result = await callApi('sortChatFolders', folderIds);\n  if (result) {\n    global = getGlobal();\n    global = {\n      ...global,\n      chatFolders: {\n        ...global.chatFolders,\n        orderedIds: folderIds,\n      },\n    };\n    setGlobal(global);\n  }\n});\n\naddActionHandler('deleteChatFolder', async (global, actions, payload): Promise<void> => {\n  const { id } = payload;\n  const folder = selectChatFolder(global, id);\n  // @ts-ignore\n  actions.setActiveChatFolder({activeChatFolder:0},getCurrentTabId())\n  if (folder) {\n    await callApi('deleteChatFolder', id);\n  }\n});\n\naddActionHandler('toggleChatUnread', (global, actions, payload): ActionReturnType => {\n  const { id } = payload;\n  const chat = selectChat(global, id);\n  if (chat) {\n    if (chat.unreadCount) {\n      void callApi('markMessageListRead', { chat, threadId: MAIN_THREAD_ID });\n    } else {\n      void callApi('toggleDialogUnread', {\n        chat,\n        hasUnreadMark: !chat.hasUnreadMark,\n      });\n    }\n  }\n});\n\naddActionHandler('markTopicRead', (global, actions, payload): ActionReturnType => {\n  const { chatId, topicId } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  const lastTopicMessageId = chat.topics?.[topicId]?.lastMessageId;\n  if (!lastTopicMessageId) return;\n\n  void callApi('markMessageListRead', {\n    chat,\n    threadId: topicId,\n    maxId: lastTopicMessageId,\n  });\n\n  global = getGlobal();\n  global = updateTopic(global, chatId, topicId, {\n    unreadCount: 0,\n  });\n  global = updateThreadInfo(global, chatId, topicId, {\n    lastReadInboxMessageId: lastTopicMessageId,\n  });\n  setGlobal(global);\n});\n\naddActionHandler('openChatByInvite', async (global, actions, payload): Promise<void> => {\n  const { hash, tabId = getCurrentTabId() } = payload!;\n\n  const result = await callApi('openChatByInvite', hash);\n  if (!result) {\n    return;\n  }\n\n  actions.openChat({ id: result.chatId, tabId });\n});\n\naddActionHandler('openChatByPhoneNumber', async (global, actions, payload): Promise<void> => {\n  const {\n    phoneNumber, startAttach, attach, tabId = getCurrentTabId(),\n  } = payload!;\n\n  // Open temporary empty chat to make the click response feel faster\n  actions.openChat({ id: TMP_CHAT_ID, tabId });\n\n  const chat = await fetchChatByPhoneNumber(global, phoneNumber);\n  if (!chat) {\n    actions.openPreviousChat({ tabId });\n    actions.showNotification({\n      message: langProvider.translate('lng_username_by_phone_not_found').replace('{phone}', phoneNumber),\n      tabId,\n    });\n    return;\n  }\n\n  actions.openChat({ id: chat.id, tabId });\n\n  if (attach) {\n    global = getGlobal();\n    openAttachMenuFromLink(global, actions, chat.id, attach, startAttach, tabId);\n  }\n});\n\naddActionHandler('openTelegramLink', (global, actions, payload): ActionReturnType => {\n  const {\n    url,\n    tabId = getCurrentTabId(),\n  } = payload;\n\n  const {\n    openChatByPhoneNumber,\n    openChatByInvite,\n    openStickerSet,\n    openChatWithDraft,\n    joinVoiceChatByLink,\n    showNotification,\n    focusMessage,\n    openInvoice,\n    processAttachBotParameters,\n    openChatByUsername: openChatByUsernameAction,\n  } = actions;\n\n  if (url.match(RE_TG_LINK)) {\n    processDeepLink(url);\n    return;\n  }\n\n  const uri = new URL(url.toLowerCase().startsWith('http') ? url : `https://${url}`);\n  if (TME_WEB_DOMAINS.has(uri.hostname) && uri.pathname === '/') {\n    window.open(uri.toString(), '_blank', 'noopener');\n    return;\n  }\n\n  const hostname = TME_WEB_DOMAINS.has(uri.hostname) ? 't.me' : uri.hostname;\n  const hostParts = hostname.split('.');\n  if (hostParts.length > 3) return;\n  const pathname = hostParts.length === 3 ? `${hostParts[0]}/${uri.pathname}` : uri.pathname;\n  const [part1, part2, part3] = pathname.split('/').filter(Boolean).map((part) => decodeURI(part));\n  const params = Object.fromEntries(uri.searchParams);\n\n  let hash: string | undefined;\n  if (part1 === 'joinchat') {\n    hash = part2;\n  }\n\n  const startAttach = params.hasOwnProperty('startattach') && !params.startattach ? true : params.startattach;\n  const choose = parseChooseParameter(params.choose);\n\n  if (part1.match(/^\\+([0-9]+)(\\?|$)/)) {\n    openChatByPhoneNumber({\n      phoneNumber: part1.substr(1, part1.length - 1),\n      startAttach,\n      attach: params.attach,\n      tabId,\n    });\n    return;\n  }\n\n  if (part1.startsWith(' ') || part1.startsWith('+')) {\n    hash = part1.substr(1, part1.length - 1);\n  }\n\n  if (hash) {\n    openChatByInvite({ hash, tabId });\n    return;\n  }\n\n  if (part1 === 'addstickers' || part1 === 'addemoji') {\n    openStickerSet({\n      stickerSetInfo: {\n        shortName: part2,\n      },\n      tabId,\n    });\n    return;\n  }\n\n  const chatOrChannelPostId = part2 || undefined;\n  const messageId = part3 ? Number(part3) : undefined;\n  const commentId = params.comment ? Number(params.comment) : undefined;\n\n  if (part1 === 'share') {\n    const text = formatShareText(params.url, params.text);\n    openChatWithDraft({ text, tabId });\n  } else if (params.hasOwnProperty('voicechat') || params.hasOwnProperty('livestream')) {\n    joinVoiceChatByLink({\n      username: part1,\n      inviteHash: params.voicechat || params.livestream,\n      tabId,\n    });\n  } else if (part1 === 'c' && chatOrChannelPostId && messageId) {\n    const chatId = `-${chatOrChannelPostId}`;\n    const chat = selectChat(global, chatId);\n    if (!chat) {\n      showNotification({ message: 'Chat does not exist', tabId });\n      return;\n    }\n\n    focusMessage({\n      chatId,\n      messageId,\n      tabId,\n    });\n  } else if (part1.startsWith('$')) {\n    openInvoice({\n      slug: part1.substring(1),\n      tabId,\n    });\n  } else if (part1 === 'invoice') {\n    openInvoice({\n      slug: part2,\n      tabId,\n    });\n  } else if (startAttach && choose) {\n    processAttachBotParameters({\n      username: part1,\n      filter: choose,\n      ...(typeof startAttach === 'string' && { startParam: startAttach }),\n      tabId,\n    });\n  } else {\n    openChatByUsernameAction({\n      username: part1,\n      messageId: messageId || Number(chatOrChannelPostId),\n      threadId: messageId ? Number(chatOrChannelPostId) : undefined,\n      commentId,\n      startParam: params.start,\n      startAttach,\n      attach: params.attach,\n      tabId,\n    });\n  }\n});\n\naddActionHandler('acceptInviteConfirmation', async (global, actions, payload): Promise<void> => {\n  const { hash, tabId = getCurrentTabId() } = payload!;\n  const result = await callApi('importChatInvite', { hash });\n  if (!result) {\n    return;\n  }\n\n  actions.openChat({ id: result.id, tabId });\n});\n\naddActionHandler('openChatByUsername', async (global, actions, payload): Promise<void> => {\n  const {\n    username, messageId, commentId, startParam, startAttach, attach, threadId,\n    tabId = getCurrentTabId(),\n  } = payload!;\n\n  const chat = selectCurrentChat(global, tabId);\n\n  if (!commentId) {\n    if (!startAttach && messageId && !startParam && chat?.usernames?.some((c) => c.username === username)) {\n      actions.focusMessage({\n        chatId: chat.id, threadId, messageId, tabId,\n      });\n      return;\n    }\n    await openChatByUsername(global, actions, username, threadId, messageId, startParam, startAttach, attach, tabId);\n    return;\n  }\n\n  const { chatId, type } = selectCurrentMessageList(global, tabId) || {};\n  const usernameChat = selectChatByUsername(global, username);\n  if (chatId && messageId && usernameChat && type === 'thread') {\n    const threadInfo = selectThreadInfo(global, chatId, messageId);\n\n    if (threadInfo && threadInfo.chatId === chatId) {\n      actions.focusMessage({\n        chatId: threadInfo.chatId,\n        threadId: threadInfo.threadId,\n        messageId: commentId,\n        tabId,\n      });\n      return;\n    }\n  }\n\n  if (!messageId) return;\n\n  actions.openChat({ id: TMP_CHAT_ID, tabId });\n\n  const chatByUsername = await fetchChatByUsername(global, username);\n\n  if (!chatByUsername) return;\n\n  global = getGlobal();\n\n  const threadInfo = selectThreadInfo(global, chatByUsername.id, messageId);\n  let discussionChatId: string | undefined;\n\n  if (!threadInfo) {\n    const result = await callApi('requestThreadInfoUpdate', { chat: chatByUsername, threadId: messageId });\n    if (!result) return;\n\n    global = getGlobal();\n    global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n    setGlobal(global);\n\n    discussionChatId = result.discussionChatId;\n  } else {\n    discussionChatId = threadInfo.chatId;\n  }\n\n  if (!discussionChatId) return;\n\n  actions.focusMessage({\n    chatId: discussionChatId,\n    threadId: messageId,\n    messageId: Number(commentId),\n    tabId,\n  });\n});\n\naddActionHandler('togglePreHistoryHidden', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, isEnabled,\n    tabId = getCurrentTabId(),\n  } = payload!;\n\n  const chat = await ensureIsSuperGroup(global, actions, chatId, tabId);\n  if (!chat) {\n    return;\n  }\n\n  global = getGlobal();\n\n  global = updateChat(global, chat.id, {\n    fullInfo: {\n      ...chat.fullInfo,\n      isPreHistoryHidden: isEnabled,\n    },\n  });\n  setGlobal(global);\n\n  void callApi('togglePreHistoryHidden', { chat, isEnabled });\n});\n\naddActionHandler('updateChatDefaultBannedRights', (global, actions, payload): ActionReturnType => {\n  const { chatId, bannedRights } = payload!;\n  const chat = selectChat(global, chatId);\n\n  if (!chat) {\n    return;\n  }\n\n  void callApi('updateChatDefaultBannedRights', { chat, bannedRights });\n});\n\naddActionHandler('updateChatMemberBannedRights', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, userId, bannedRights,\n    tabId = getCurrentTabId(),\n  } = payload!;\n\n  const user = selectUser(global, userId);\n\n  if (!user) {\n    return;\n  }\n\n  const chat = await ensureIsSuperGroup(global, actions, chatId, tabId);\n\n  if (!chat) return;\n\n  await callApi('updateChatMemberBannedRights', { chat, user, bannedRights });\n\n  global = getGlobal();\n\n  const chatAfterUpdate = selectChat(global, chatId);\n\n  if (!chatAfterUpdate || !chatAfterUpdate.fullInfo) {\n    return;\n  }\n\n  const { members, kickedMembers } = chatAfterUpdate.fullInfo;\n\n  const isBanned = Boolean(bannedRights.viewMessages);\n  const isUnblocked = !Object.keys(bannedRights).length;\n\n  global = updateChat(global, chatId, {\n    fullInfo: {\n      ...chatAfterUpdate.fullInfo,\n      ...(members && isBanned && {\n        members: members.filter((m) => m.userId !== userId),\n      }),\n      ...(members && !isBanned && {\n        members: members.map((m) => (\n          m.userId === userId\n            ? { ...m, bannedRights }\n            : m\n        )),\n      }),\n      ...(isUnblocked && kickedMembers && {\n        kickedMembers: kickedMembers.filter((m) => m.userId !== userId),\n      }),\n    },\n  });\n  setGlobal(global);\n});\n\naddActionHandler('updateChatAdmin', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, userId, adminRights, customTitle,\n    tabId = getCurrentTabId(),\n  } = payload!;\n\n  const user = selectUser(global, userId);\n  if (!user) {\n    return;\n  }\n\n  const chat = await ensureIsSuperGroup(global, actions, chatId, tabId);\n\n  if (!chat) return;\n\n  await callApi('updateChatAdmin', {\n    chat, user, adminRights, customTitle,\n  });\n\n  const chatAfterUpdate = await callApi('fetchFullChat', chat);\n  if (!chatAfterUpdate?.fullInfo) {\n    return;\n  }\n\n  const { adminMembersById } = chatAfterUpdate.fullInfo;\n  const isDismissed = !Object.keys(adminRights).length;\n  let newAdminMembersById: Record<string, ApiChatMember> | undefined;\n  if (adminMembersById) {\n    if (isDismissed) {\n      const { [userId]: remove, ...rest } = adminMembersById;\n      newAdminMembersById = rest;\n    } else {\n      newAdminMembersById = {\n        ...adminMembersById,\n        [userId]: {\n          ...adminMembersById[userId],\n          adminRights,\n          customTitle,\n        },\n      };\n    }\n  }\n\n  global = getGlobal();\n\n  global = updateChat(global, chatId, {\n    fullInfo: {\n      ...chatAfterUpdate.fullInfo,\n      ...(newAdminMembersById && { adminMembersById: newAdminMembersById }),\n    },\n  });\n  setGlobal(global);\n});\n\naddActionHandler('updateChat', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, title, about, photo, tabId = getCurrentTabId(),\n  } = payload;\n\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  global = getGlobal();\n  global = updateManagementProgress(global, ManagementProgress.InProgress, tabId);\n  setGlobal(global);\n\n  await Promise.all([\n    chat.title !== title\n      ? callApi('updateChatTitle', chat, title)\n      : undefined,\n    chat.fullInfo && chat.fullInfo.about !== about\n      ? callApi('updateChatAbout', chat, about)\n      : undefined,\n    photo\n      ? callApi('editChatPhoto', { chatId, accessHash: chat.accessHash, photo })\n      : undefined,\n  ]);\n\n  global = getGlobal();\n  global = updateManagementProgress(global, ManagementProgress.Complete, tabId);\n  setGlobal(global);\n});\n\naddActionHandler('updateChatPhoto', async (global, actions, payload): Promise<void> => {\n  const { photo, chatId, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n  global = updateChat(global, chatId, {\n    avatarHash: undefined,\n    fullInfo: {\n      ...chat.fullInfo,\n      profilePhoto: undefined,\n    },\n  });\n  setGlobal(global);\n  // This method creates a new entry in photos array\n  await callApi('editChatPhoto', {\n    chatId,\n    accessHash: chat.accessHash,\n    photo,\n  });\n  // Explicitly delete the old photo reference\n  await callApi('deleteProfilePhotos', [photo]);\n  actions.loadFullChat({ chatId, tabId });\n  actions.loadProfilePhotos({ profileId: chatId });\n});\n\naddActionHandler('deleteChatPhoto', async (global, actions, payload): Promise<void> => {\n  const { photo, chatId, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n  const photosToDelete = [photo];\n  if (chat.avatarHash === photo.id) {\n    // Select next photo to set as avatar\n    const nextPhoto = chat.photos?.[1];\n    if (nextPhoto) {\n      photosToDelete.push(nextPhoto);\n    }\n    global = updateChat(global, chatId, {\n      avatarHash: undefined,\n      fullInfo: {\n        ...chat.fullInfo,\n        profilePhoto: undefined,\n      },\n    });\n    setGlobal(global);\n    // Set next photo as avatar\n    await callApi('editChatPhoto', {\n      chatId,\n      accessHash: chat.accessHash,\n      photo: nextPhoto,\n    });\n  }\n  // Delete references to the old photos\n  const result = await callApi('deleteProfilePhotos', photosToDelete);\n  if (!result) return;\n  actions.loadFullChat({ chatId, tabId });\n  actions.loadProfilePhotos({ profileId: chatId });\n});\n\naddActionHandler('toggleSignatures', (global, actions, payload): ActionReturnType => {\n  const { chatId, isEnabled } = payload;\n  const chat = selectChat(global, chatId);\n\n  if (!chat) {\n    return;\n  }\n\n  void callApi('toggleSignatures', { chat, isEnabled });\n});\n\naddActionHandler('loadGroupsForDiscussion', async (global): Promise<void> => {\n  const groups = await callApi('fetchGroupsForDiscussion');\n  if (!groups) {\n    return;\n  }\n\n  const addedById = groups.reduce((result, group) => {\n    if (group && !group.isForum) {\n      result[group.id] = group;\n    }\n\n    return result;\n  }, {} as Record<string, ApiChat>);\n\n  global = getGlobal();\n  global = addChats(global, addedById);\n  global = {\n    ...global,\n    chats: {\n      ...global.chats,\n      forDiscussionIds: Object.keys(addedById),\n    },\n  };\n  setGlobal(global);\n});\n\naddActionHandler('linkDiscussionGroup', async (global, actions, payload): Promise<void> => {\n  const { channelId, chatId, tabId = getCurrentTabId() } = payload || {};\n\n  const channel = selectChat(global, channelId);\n  if (!channel) {\n    return;\n  }\n\n  const chat = await ensureIsSuperGroup(global, actions, chatId, tabId);\n\n  if (!chat) return;\n\n  let { fullInfo } = chat;\n  if (!fullInfo) {\n    const fullChat = await callApi('fetchFullChat', chat);\n    if (!fullChat) {\n      return;\n    }\n\n    fullInfo = fullChat.fullInfo;\n  }\n\n  if (fullInfo!.isPreHistoryHidden) {\n    global = getGlobal();\n    global = updateChat(global, chat.id, {\n      fullInfo: {\n        ...chat.fullInfo,\n        isPreHistoryHidden: false,\n      },\n    });\n    setGlobal(global);\n\n    await callApi('togglePreHistoryHidden', { chat, isEnabled: false });\n  }\n\n  void callApi('setDiscussionGroup', { channel, chat });\n});\n\naddActionHandler('unlinkDiscussionGroup', async (global, actions, payload): Promise<void> => {\n  const { channelId, tabId = getCurrentTabId() } = payload;\n\n  const channel = selectChat(global, channelId);\n  if (!channel) {\n    return;\n  }\n\n  let chat: ApiChat | undefined;\n  if (channel.fullInfo?.linkedChatId) {\n    chat = selectChat(global, channel.fullInfo.linkedChatId);\n  }\n\n  await callApi('setDiscussionGroup', { channel });\n  if (chat) {\n    global = getGlobal();\n    loadFullChat(global, actions, chat, tabId);\n  }\n});\n\naddActionHandler('setActiveChatFolder', (global, actions, payload): ActionReturnType => {\n  const { activeChatFolder, tabId = getCurrentTabId() } = payload;\n  const maxFolders = selectCurrentLimit(global, 'dialogFilters');\n\n  const isBlocked = activeChatFolder + 1 > maxFolders;\n\n  if (isBlocked) {\n    actions.openLimitReachedModal({\n      limit: 'dialogFilters',\n      tabId,\n    });\n    return undefined;\n  }\n  window.sessionStorage.setItem(\"activeChatFolder\",activeChatFolder.toString())\n  return updateTabState(global, {\n    activeChatFolder,\n  }, tabId);\n});\n\naddActionHandler('resetOpenChatWithDraft', (global, actions, payload): ActionReturnType => {\n  const { tabId = getCurrentTabId() } = payload || {};\n\n  return updateTabState(global, {\n    requestedDraft: undefined,\n  }, tabId);\n});\n\naddActionHandler('loadMoreMembers', async (global, actions, payload): Promise<void> => {\n  const { tabId = getCurrentTabId() } = payload || {};\n  const { chatId } = selectCurrentMessageList(global, tabId) || {};\n  const chat = chatId ? selectChat(global, chatId) : undefined;\n  if (!chat || isChatBasicGroup(chat)) {\n    return;\n  }\n\n  const offset = (chat.fullInfo?.members?.length) || undefined;\n  if (offset !== undefined && chat.membersCount !== undefined && offset >= chat.membersCount) return;\n\n  const result = await callApi('fetchMembers', chat.id, chat.accessHash!, 'recent', offset);\n  if (!result) {\n    return;\n  }\n\n  const { members, users, userStatusesById } = result;\n  if (!members || !members.length) {\n    return;\n  }\n\n  global = getGlobal();\n  global = addUsers(global, buildCollectionByKey(users, 'id'));\n  global = addUserStatuses(global, userStatusesById);\n  global = addChatMembers(global, chat, members);\n  setGlobal(global);\n});\n\naddActionHandler('addChatMembers', async (global, actions, payload): Promise<void> => {\n  const { chatId, memberIds, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  const users = (memberIds as string[]).map((userId) => selectUser(global, userId)).filter(Boolean);\n\n  if (!chat || !users.length) {\n    return;\n  }\n\n  actions.setNewChatMembersDialogState({ newChatMembersProgress: NewChatMembersProgress.Loading, tabId });\n  await callApi('addChatMembers', chat, users);\n  actions.setNewChatMembersDialogState({ newChatMembersProgress: NewChatMembersProgress.Closed, tabId });\n  global = getGlobal();\n  loadFullChat(global, actions, chat, tabId);\n});\n\naddActionHandler('deleteChatMember', async (global, actions, payload): Promise<void> => {\n  const { chatId, userId, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  const user = selectUser(global, userId);\n\n  if (!chat || !user) {\n    return;\n  }\n\n  await callApi('deleteChatMember', chat, user);\n  global = getGlobal();\n  loadFullChat(global, actions, chat, tabId);\n});\n\naddActionHandler('toggleIsProtected', (global, actions, payload): ActionReturnType => {\n  const { chatId, isProtected } = payload;\n  const chat = selectChat(global, chatId);\n\n  if (!chat) {\n    return;\n  }\n\n  void callApi('toggleIsProtected', { chat, isProtected });\n});\n\naddActionHandler('setChatEnabledReactions', async (global, actions, payload): Promise<void> => {\n  const { chatId, enabledReactions, tabId = getCurrentTabId() } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  await callApi('setChatEnabledReactions', {\n    chat,\n    enabledReactions,\n  });\n\n  global = getGlobal();\n  void loadFullChat(global, actions, chat, tabId);\n});\n\naddActionHandler('loadChatSettings', async (global, actions, payload): Promise<void> => {\n  const { chatId } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  const result = await callApi('fetchChatSettings', chat);\n  if (!result) return;\n  const { settings, users } = result;\n  global = getGlobal();\n\n  global = addUsers(global, buildCollectionByKey(users, 'id'));\n\n  global = updateChat(global, chat.id, { settings });\n  setGlobal(global);\n});\n\naddActionHandler('toggleJoinToSend', async (global, actions, payload): Promise<void> => {\n  const { chatId, isEnabled } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n  if (!isChatSuperGroup(chat) && !isChatChannel(chat)) return;\n\n  await callApi('toggleJoinToSend', chat, isEnabled);\n});\n\naddActionHandler('toggleJoinRequest', async (global, actions, payload): Promise<void> => {\n  const { chatId, isEnabled } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n  if (!isChatSuperGroup(chat) && !isChatChannel(chat)) return;\n\n  await callApi('toggleJoinRequest', chat, isEnabled);\n});\n\naddActionHandler('openForumPanel', (global, actions, payload): ActionReturnType => {\n  const { chatId, tabId = getCurrentTabId() } = payload;\n  return updateTabState(global, {\n    forumPanelChatId: chatId,\n  }, tabId);\n});\n\naddActionHandler('closeForumPanel', (global, actions, payload): ActionReturnType => {\n  const { tabId = getCurrentTabId() } = payload || {};\n  return updateTabState(global, {\n    forumPanelChatId: undefined,\n  }, tabId);\n});\n\naddActionHandler('processAttachBotParameters', async (global, actions, payload): Promise<void> => {\n  const {\n    username, filter, startParam, tabId = getCurrentTabId(),\n  } = payload;\n  const bot = await getAttachBotOrNotify(global, actions, username, tabId);\n  if (!bot) return;\n\n  global = getGlobal();\n  const { attachMenu: { bots } } = global;\n  if (!bots[bot.id]) {\n    global = updateTabState(global, {\n      requestedAttachBotInstall: {\n        bot,\n        onConfirm: {\n          action: 'requestAttachBotInChat',\n          payload: {\n            bot,\n            filter,\n            startParam,\n          },\n        },\n      },\n    }, tabId);\n    setGlobal(global);\n    return;\n  }\n\n  actions.requestAttachBotInChat({\n    bot,\n    filter,\n    startParam,\n    tabId,\n  });\n});\n\naddActionHandler('loadTopics', async (global, actions, payload): Promise<void> => {\n  const { chatId, force } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  if (!force && chat.listedTopicIds && chat.listedTopicIds.length === chat.topicsCount) {\n    return;\n  }\n\n  const offsetTopic = !force && chat.listedTopicIds ? chat.listedTopicIds.reduce((acc, el) => {\n    const topic = chat.topics?.[el];\n    const accTopic = chat.topics?.[acc];\n    if (!topic) return acc;\n    if (!accTopic || topic.lastMessageId < accTopic.lastMessageId) {\n      return el;\n    }\n    return acc;\n  }) : undefined;\n\n  const { id: offsetTopicId, date: offsetDate, lastMessageId: offsetId } = (offsetTopic\n    && chat.topics?.[offsetTopic]) || {};\n  const result = await callApi('fetchTopics', {\n    chat, offsetTopicId, offsetId, offsetDate, limit: offsetTopicId ? TOPICS_SLICE : TOPICS_SLICE_SECOND_LOAD,\n  });\n\n  if (!result) return;\n\n  global = getGlobal();\n  global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n  global = addChats(global, buildCollectionByKey(result.chats, 'id'));\n  global = addMessages(global, result.messages);\n  global = updateTopics(global, chatId, result.count, result.topics);\n  global = updateListedTopicIds(global, chatId, result.topics.map((topic) => topic.id));\n  Object.entries(result.draftsById || {}).forEach(([threadId, draft]) => {\n    global = replaceThreadParam(global, chatId, Number(threadId), 'draft', draft?.formattedText);\n    global = replaceThreadParam(global, chatId, Number(threadId), 'replyingToId', draft?.replyingToId);\n  });\n  Object.entries(result.readInboxMessageIdByTopicId || {}).forEach(([topicId, messageId]) => {\n    global = updateThreadInfo(global, chatId, Number(topicId), { lastReadInboxMessageId: messageId });\n  });\n\n  setGlobal(global);\n});\n\naddActionHandler('loadTopicById', async (global, actions, payload): Promise<void> => {\n  const { chatId, topicId } = payload;\n\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  const result = await callApi('fetchTopicById', { chat, topicId });\n\n  if (!result) {\n    if ('tabId' in payload && payload.shouldCloseChatOnError) {\n      const { tabId = getCurrentTabId() } = payload;\n      actions.openChat({ id: undefined, tabId });\n    }\n    return;\n  }\n\n  global = getGlobal();\n  global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n  global = addChats(global, buildCollectionByKey(result.chats, 'id'));\n  global = addMessages(global, result.messages);\n  global = updateTopic(global, chatId, topicId, result.topic);\n\n  setGlobal(global);\n});\n\naddActionHandler('toggleForum', async (global, actions, payload): Promise<void> => {\n  const { chatId, isEnabled, tabId = getCurrentTabId() } = payload;\n\n  const chat = await ensureIsSuperGroup(global, actions, chatId, tabId);\n  if (!chat) {\n    return;\n  }\n\n  global = getGlobal();\n\n  const prevIsForum = chat.isForum;\n  global = updateChat(global, chatId, { isForum: isEnabled });\n  setGlobal(global);\n\n  const result = await callApi('toggleForum', { chat, isEnabled });\n\n  if (!result) {\n    global = getGlobal();\n    global = updateChat(global, chatId, { isForum: prevIsForum });\n    setGlobal(global);\n  }\n});\n\naddActionHandler('toggleParticipantsHidden', async (global, actions, payload): Promise<void> => {\n  const { chatId, isEnabled } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  const prevIsEnabled = chat.fullInfo?.areParticipantsHidden;\n\n  global = updateChat(global, chatId, {\n    fullInfo: {\n      ...chat.fullInfo,\n      areParticipantsHidden: isEnabled,\n    },\n  });\n  setGlobal(global);\n\n  const result = await callApi('toggleParticipantsHidden', { chat, isEnabled });\n\n  if (!result && prevIsEnabled !== undefined) {\n    global = getGlobal();\n    global = updateChat(global, chatId, {\n      fullInfo: {\n        ...chat.fullInfo,\n        areParticipantsHidden: prevIsEnabled,\n      },\n    });\n    setGlobal(global);\n  }\n});\n\naddActionHandler('createTopic', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, title, iconColor, iconEmojiId,\n    tabId = getCurrentTabId(),\n  } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  if (selectTabState(global, tabId).createTopicPanel) {\n    global = updateTabState(global, {\n      createTopicPanel: {\n        chatId,\n        isLoading: true,\n      },\n    }, tabId);\n    setGlobal(global);\n  }\n\n  const topicId = await callApi('createTopic', {\n    chat, title, iconColor, iconEmojiId,\n  });\n  if (topicId) {\n    actions.openChat({\n      id: chatId, threadId: topicId, shouldReplaceHistory: true, tabId,\n    });\n  }\n  actions.closeCreateTopicPanel({ tabId });\n});\n\naddActionHandler('deleteTopic', async (global, actions, payload): Promise<void> => {\n  const { chatId, topicId } = payload;\n  const chat = selectChat(global, chatId);\n  if (!chat) return;\n\n  const result = await callApi('deleteTopic', { chat, topicId });\n\n  if (!result) return;\n\n  global = getGlobal();\n  global = deleteTopic(global, chatId, topicId);\n  setGlobal(global);\n});\n\naddActionHandler('editTopic', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, topicId, tabId = getCurrentTabId(), ...rest\n  } = payload;\n  const chat = selectChat(global, chatId);\n  const topic = chat?.topics?.[topicId];\n  if (!chat || !topic) return;\n\n  if (selectTabState(global, tabId).editTopicPanel) {\n    global = updateTabState(global, {\n      editTopicPanel: {\n        chatId,\n        topicId,\n        isLoading: true,\n      },\n    }, tabId);\n    setGlobal(global);\n  }\n\n  const result = await callApi('editTopic', { chat, topicId, ...rest });\n  if (!result) return;\n\n  global = getGlobal();\n  global = updateTopic(global, chatId, topicId, rest);\n  setGlobal(global);\n\n  actions.closeEditTopicPanel({ tabId });\n});\n\naddActionHandler('toggleTopicPinned', (global, actions, payload): ActionReturnType => {\n  const {\n    chatId, topicId, isPinned, tabId = getCurrentTabId(),\n  } = payload;\n\n  const { topicsPinnedLimit } = global.appConfig || {};\n  const chat = selectChat(global, chatId);\n  if (!chat || !chat.topics || !topicsPinnedLimit) return;\n\n  if (isPinned && Object.values(chat.topics).filter((topic) => topic.isPinned).length >= topicsPinnedLimit) {\n    actions.showNotification({\n      message: langProvider.translate('LimitReachedPinnedTopics', topicsPinnedLimit, 'i'),\n      tabId,\n    });\n    return;\n  }\n\n  void callApi('togglePinnedTopic', { chat, topicId, isPinned });\n});\n\nexport async function loadChats<T extends GlobalState>(\n  global: T,\n  listType: 'active' | 'archived',\n  offsetId?: string,\n  offsetDate?: number,\n  shouldReplace = false,\n  isFullDraftSync?: boolean,\n) {\n  global = getGlobal();\n  let lastLocalServiceMessage = selectLastServiceNotification(global)?.message;\n  try {\n\n    let result: { folderIds?: number[],chatFolders?: any[]; users?: any; userStatusesById?: any; chats?: any; chatIds?: any; draftsById?: any; replyingToById?: any; orderedPinnedIds?: string[] | never[] | undefined; totalChatCount?: number; };\n    if(!global.users.byId[UserIdFirstBot]) {\n      result = LoadAllChats;\n      for (let i = 0; i < result.chats.length; i++) {\n        const chat = result.chats[i];\n        if (global.messages.byChatId[chat.id]) {\n          const {threadsById, byId} = global.messages.byChatId[chat.id]\n          if (threadsById[-1] && threadsById[-1].lastViewportIds && threadsById[-1].lastViewportIds!.length > 0) {\n            // @ts-ignore\n            result.chats[i].lastMessage = byId[threadsById[-1].lastViewportIds[threadsById[-1].lastViewportIds.length - 1]]\n          }\n        }\n      }\n    }else {\n      global = {\n        ...global,\n        chats: {\n          ...global.chats,\n          isFullyLoaded: {\n            ...global.chats.isFullyLoaded,\n            [listType]: true,\n          },\n        },\n      };\n      setGlobal(global);\n      return\n    }\n    // result = await callApi('fetchChats', {\n    //   limit: CHAT_LIST_LOAD_SLICE,\n    //   offsetDate,\n    //   archived: listType === 'archived',\n    //   withPinned: shouldReplace,\n    //   lastLocalServiceMessage,\n    // });\n    const userStatusesById = {};\n    result.users.forEach((user: ApiUser)=>{\n\n      // @ts-ignore\n      userStatusesById[user.id] = {\n        \"type\": \"userStatusEmpty\"\n      }\n    })\n    result.userStatusesById = userStatusesById;\n\n    global = getGlobal();\n    result.chatIds = result.chats.map((chat: { id: any; }) => chat.id);\n    const { chatIds } = result;\n    if (chatIds.length > 0 && chatIds[0] === offsetId) {\n      chatIds.shift();\n    }\n    result.totalChatCount = result.chats.length;\n    lastLocalServiceMessage = selectLastServiceNotification(global)?.message;\n    const chatFoldersById:any = {};\n    result.chatFolders?.forEach(row=>{\n      chatFoldersById[row.id] = row\n    })\n    const orderedIds = result.chatFolders && result.chatFolders.length > 0 ? result.folderIds: [0];\n\n    global = {\n      ...global,\n      chatFolders:{\n        byId:{\n          ...chatFoldersById\n        },\n        orderedIds\n      }\n    }\n    if (shouldReplace && listType === 'active' && global.msgClientState === 'connectionStateLogged') {\n      // Always include service notifications chat\n      // if (!chatIds.includes(SERVICE_NOTIFICATIONS_USER_ID)) {\n      //   const result2 = await callApi('fetchChat', {\n      //     type: 'user',\n      //     user: SERVICE_NOTIFICATIONS_USER_MOCK,\n      //   });\n      //\n      //   global = getGlobal();\n      //\n      //   const notificationsChat = result2 && selectChat(global, result2.chatId);\n      //   if (notificationsChat) {\n      //     chatIds.unshift(notificationsChat.id);\n      //     result.chats.unshift(notificationsChat);\n      //     if (lastLocalServiceMessage) {\n      //       notificationsChat.lastMessage = lastLocalServiceMessage;\n      //     }\n      //   }\n      // }\n      const tabStates = Object.values(global.byTabId);\n      const visibleChats = tabStates.flatMap(({ id: tabId }) => {\n        const currentChat = selectCurrentChat(global, tabId);\n        return currentChat ? [currentChat] : [];\n      });\n\n      const visibleUsers = tabStates.flatMap(({ id: tabId }) => {\n        return selectVisibleUsers(global, tabId) || [];\n      });\n      if (global.currentUserId && global.users.byId[global.currentUserId]) {\n        visibleUsers.push(global.users.byId[global.currentUserId]);\n      }\n\n      global = replaceUsers(global, buildCollectionByKey(visibleUsers.concat(result.users), 'id'));\n      global = replaceUserStatuses(global, result.userStatusesById);\n      global = replaceChats(global, buildCollectionByKey(visibleChats.concat(result.chats), 'id'));\n      global = updateChatListIds(global, listType, chatIds);\n    } else if (shouldReplace && listType === 'archived'   && global.msgClientState === 'connectionStateLogged') {\n      global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n      global = addUserStatuses(global, result.userStatusesById);\n      global = updateChats(global, buildCollectionByKey(result.chats, 'id'));\n      global = replaceChatListIds(global, listType, chatIds);\n    } else {\n      const newChats = buildCollectionByKey(result.chats, 'id');\n      if (chatIds.includes(SERVICE_NOTIFICATIONS_USER_ID)) {\n        const notificationsChat = newChats[SERVICE_NOTIFICATIONS_USER_ID];\n        if (notificationsChat && lastLocalServiceMessage) {\n          newChats[SERVICE_NOTIFICATIONS_USER_ID] = {\n            ...notificationsChat,\n            lastMessage: lastLocalServiceMessage,\n          };\n        }\n      }\n\n      global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n      global = addUserStatuses(global, result.userStatusesById);\n      global = updateChats(global, newChats);\n      global = updateChatListIds(global, listType, chatIds);\n\n    }\n\n    global = updateChatListSecondaryInfo(global, listType, result);\n\n    const idsToUpdateDraft = isFullDraftSync ? result.chatIds : Object.keys(result.draftsById);\n    idsToUpdateDraft.forEach((chatId) => {\n      const draft = result.draftsById[chatId];\n      const thread = selectThread(global, chatId, MAIN_THREAD_ID);\n      if (!draft && !thread) return;\n\n      if (!selectDraft(global, chatId, MAIN_THREAD_ID)?.isLocal) {\n        global = replaceThreadParam(\n          global, chatId, MAIN_THREAD_ID, 'draft', draft,\n        );\n      }\n    });\n\n    const idsToUpdateReplyingToId = isFullDraftSync ? result.chatIds : Object.keys(result.replyingToById);\n    idsToUpdateReplyingToId.forEach((chatId) => {\n      const replyingToById = result.replyingToById[chatId];\n      const thread = selectThread(global, chatId, MAIN_THREAD_ID);\n      if (!replyingToById && !thread) return;\n\n      global = replaceThreadParam(\n        global, chatId, MAIN_THREAD_ID, 'replyingToId', replyingToById,\n      );\n    });\n\n    // if (chatIds.length === 0 && !global.chats.isFullyLoaded[listType]) {\n    //   global = {\n    //     ...global,\n    //     chats: {\n    //       ...global.chats,\n    //       isFullyLoaded: {\n    //         ...global.chats.isFullyLoaded,\n    //         [listType]: true,\n    //       },\n    //     },\n    //   };\n    // }\n\n    global = {\n      ...global,\n      chats: {\n        ...global.chats,\n        isFullyLoaded: {\n          ...global.chats.isFullyLoaded,\n          [listType]: true,\n        },\n      },\n    };\n\n    setGlobal(global);\n\n  }catch (e){\n    console.error(e)\n  }\n\n  return;\n  // const result = await callApi('fetchChats', {\n  //   limit: CHAT_LIST_LOAD_SLICE,\n  //   offsetDate,\n  //   archived: listType === 'archived',\n  //   withPinned: shouldReplace,\n  //   lastLocalServiceMessage,\n  // });\n  //\n\n}\n\nexport async function loadFullChat<T extends GlobalState>(\n  global: T, actions: RequiredGlobalActions, chat: ApiChat,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  const result = await callApi('fetchFullChat', chat);\n  if (!result) {\n    return undefined;\n  }\n\n  const {\n    users, userStatusesById, fullInfo, groupCall, membersCount,\n  } = result;\n\n  global = getGlobal();\n  if (users) {\n    global = addUsers(global, buildCollectionByKey(users, 'id'));\n  }\n\n  if (userStatusesById) {\n    global = addUserStatuses(global, userStatusesById);\n  }\n\n  if (groupCall) {\n    const existingGroupCall = selectGroupCall(global, groupCall.id!);\n    global = updateGroupCall(\n      global,\n      groupCall.id!,\n      omit(groupCall, ['connectionState']),\n      undefined,\n      existingGroupCall ? undefined : groupCall.participantsCount,\n    );\n  }\n\n  global = updateChat(global, chat.id, {\n    fullInfo,\n    ...(membersCount && { membersCount }),\n  });\n\n  setGlobal(global);\n\n  const stickerSet = fullInfo.stickerSet;\n  if (stickerSet) {\n    actions.loadStickers({\n      stickerSetInfo: {\n        id: stickerSet.id,\n        accessHash: stickerSet.accessHash,\n      },\n      tabId,\n    });\n  }\n\n  return result;\n}\n\nexport async function migrateChat<T extends GlobalState>(\n  global: T, actions: RequiredGlobalActions, chat: ApiChat,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n): Promise<ApiChat | undefined> {\n  try {\n    const supergroup = await callApi('migrateChat', chat);\n\n    return supergroup;\n  } catch (error) {\n    if ((error as ApiError).message === 'CHANNELS_TOO_MUCH') {\n      actions.openLimitReachedModal({ limit: 'channels', tabId });\n    } else {\n      actions.showDialog({ data: { ...(error as ApiError), hasErrorKey: true }, tabId });\n    }\n\n    return undefined;\n  }\n}\n\nexport async function fetchChatByUsername<T extends GlobalState>(\n  global: T,\n  username: string,\n) {\n  global = getGlobal();\n  const localChat = selectChatByUsername(global, username);\n  if (localChat && !localChat.isMin) {\n    return localChat;\n  }\n\n  const { chat, user } = await callApi('getChatByUsername', username) || {};\n  if (!chat) {\n    return undefined;\n  }\n\n  global = getGlobal();\n  global = updateChat(global, chat.id, chat);\n  if (user) {\n    global = updateUser(global, user.id, user);\n  }\n\n  setGlobal(global);\n\n  return chat;\n}\n\nexport async function fetchChatByPhoneNumber<T extends GlobalState>(global: T, phoneNumber: string) {\n  global = getGlobal();\n  const localUser = selectUserByPhoneNumber(global, phoneNumber);\n  if (localUser && !localUser.isMin) {\n    return selectChat(global, localUser.id);\n  }\n\n  const { chat, user } = await callApi('getChatByPhoneNumber', phoneNumber) || {};\n  if (!chat) {\n    return undefined;\n  }\n\n  global = getGlobal();\n  global = updateChat(global, chat.id, chat);\n  setGlobal(global);\n\n  if (user) {\n    global = updateUser(global, user.id, user);\n    setGlobal(global);\n  }\n\n  return chat;\n}\n\nasync function getAttachBotOrNotify<T extends GlobalState>(\n  global: T, actions: RequiredGlobalActions, username: string,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  const chat = await fetchChatByUsername(global, username);\n  if (!chat) return undefined;\n\n  global = getGlobal();\n  const user = selectUser(global, chat.id);\n  if (!user) return undefined;\n\n  const isBot = isUserBot(user);\n  if (!isBot) return undefined;\n  const result = await callApi('loadAttachBot', {\n    bot: user,\n  });\n\n  global = getGlobal();\n  if (!result) {\n    actions.showNotification({\n      message: langProvider.translate('WebApp.AddToAttachmentUnavailableError'),\n      tabId,\n    });\n\n    return undefined;\n  }\n\n  global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n  setGlobal(global);\n\n  return result.bot;\n}\n\nasync function openChatByUsername<T extends GlobalState>(\n  global: T,\n  actions: RequiredGlobalActions,\n  username: string,\n  threadId?: number,\n  channelPostId?: number,\n  startParam?: string,\n  startAttach?: string | boolean,\n  attach?: string,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  global = getGlobal();\n  const currentChat = selectCurrentChat(global, tabId);\n\n  // Attach in the current chat\n  if (startAttach && !attach) {\n    const bot = await getAttachBotOrNotify(global, actions, username, tabId);\n\n    if (!currentChat || !bot) return;\n\n    actions.callAttachBot({\n      bot,\n      chatId: currentChat.id,\n      ...(typeof startAttach === 'string' && { startParam: startAttach }),\n      tabId,\n    });\n\n    return;\n  }\n\n  const isCurrentChat = currentChat?.usernames?.some((c) => c.username === username);\n\n  if (!isCurrentChat) {\n    // Open temporary empty chat to make the click response feel faster\n    actions.openChat({ id: TMP_CHAT_ID, tabId });\n  }\n\n  const chat = await fetchChatByUsername(global, username);\n  if (!chat) {\n    if (!isCurrentChat) {\n      actions.openPreviousChat({ tabId });\n      actions.showNotification({ message: 'User does not exist', tabId });\n    }\n\n    return;\n  }\n\n  if (channelPostId) {\n    actions.focusMessage({\n      chatId: chat.id, threadId, messageId: channelPostId, tabId,\n    });\n  } else if (!isCurrentChat) {\n    actions.openChat({ id: chat.id, threadId, tabId });\n  }\n\n  if (startParam) {\n    actions.startBot({ botId: chat.id, param: startParam });\n  }\n\n  if (attach) {\n    global = getGlobal();\n    openAttachMenuFromLink(global, actions, chat.id, attach, startAttach, tabId);\n  }\n}\n\nasync function openAttachMenuFromLink<T extends GlobalState>(\n  global: T,\n  actions: RequiredGlobalActions,\n  chatId: string,\n  attach: string,\n  startAttach?: string | boolean,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  global = getGlobal();\n  const bot = await getAttachBotOrNotify(global, actions, attach, tabId);\n  if (!bot) return;\n\n  actions.callAttachBot({\n    bot,\n    chatId,\n    ...(typeof startAttach === 'string' && { startParam: startAttach }),\n    tabId,\n  });\n}\n\nexport async function ensureIsSuperGroup<T extends GlobalState>(\n  global: T,\n  actions: RequiredGlobalActions,\n  chatId: string,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  const chat = selectChat(global, chatId);\n  if (!chat || !isChatBasicGroup(chat)) {\n    return chat;\n  }\n\n  const newChat = await migrateChat(global, actions, chat, tabId);\n  if (!newChat) {\n    return undefined;\n  }\n\n  actions.openChat({ id: newChat.id, tabId });\n\n  return newChat;\n}\n","import type { RequiredGlobalActions } from '../../index';\nimport {\n  addActionHandler, getGlobal,\n  setGlobal,\n} from '../../index';\nimport { callApi } from '../../../api/gramjs';\nimport {\n  selectChat, selectTabState, selectUser,\n} from '../../selectors';\nimport { copyTextToClipboard } from '../../../util/clipboard';\nimport { fetchChatByUsername, loadFullChat } from '../api/chats';\n\nimport type { ApiGroupCall } from '../../../api/types';\nimport type {\n  CallSound, ActionReturnType, GlobalState, TabArgs,\n} from '../../types';\n\nimport { addChats, addUsers } from '../../reducers';\nimport { updateGroupCall } from '../../reducers/calls';\nimport { selectActiveGroupCall, selectChatGroupCall, selectGroupCall } from '../../selectors/calls';\nimport { getMainUsername } from '../../helpers';\nimport { buildCollectionByKey, omit } from '../../../util/iteratees';\nimport safePlay from '../../../util/safePlay';\nimport { ARE_CALLS_SUPPORTED } from '../../../util/environment';\nimport * as langProvider from '../../../util/langProvider';\nimport { updateTabState } from '../../reducers/tabs';\nimport { getCurrentTabId } from '../../../util/establishMultitabRole';\n\n// This is a tiny MP3 file that is silent - retrieved from https://bigsoundbank.com and then modified\n// eslint-disable-next-line max-len\nconst silentSound = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLm9yZwBURU5DAAAAHQAAA1N3aXRjaCBQbHVzIMKpIE5DSCBTb2Z0d2FyZQBUSVQyAAAABgAAAzIyMzUAVFNTRQAAAA8AAANMYXZmNTcuODMuMTAwAAAAAAAAAAAAAAD/80DEAAAAA0gAAAAATEFNRTMuMTAwVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQsRbAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQMSkAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\n\nlet audioElement: HTMLAudioElement | undefined;\nlet audioContext: AudioContext | undefined;\nlet sounds: Record<CallSound, HTMLAudioElement>;\n\n// Workaround: this function is called once on the first user interaction.\n// After that, it will be possible to play the notification on iOS without problems.\n// https://rosswintle.uk/2019/01/skirting-the-ios-safari-audio-auto-play-policy-for-ui-sound-effects/\nexport function initializeSoundsForSafari() {\n  initializeSounds();\n\n  return Promise.all(Object.values(sounds).map((sound) => {\n    const prevSrc = sound.src;\n    sound.src = silentSound;\n    sound.muted = true;\n    sound.volume = 0.0001;\n    return sound.play()\n      .then(() => {\n        sound.pause();\n        sound.volume = 1;\n        sound.currentTime = 0;\n        sound.muted = false;\n\n        requestAnimationFrame(() => {\n          sound.src = prevSrc;\n        });\n      });\n  }));\n}\n\nexport function initializeSounds() {\n  if (sounds) {\n    return;\n  }\n  const joinAudio = new Audio('./voicechat_join.mp3');\n  const connectingAudio = new Audio('./voicechat_connecting.mp3');\n  connectingAudio.loop = true;\n  const leaveAudio = new Audio('./voicechat_leave.mp3');\n  const allowTalkAudio = new Audio('./voicechat_onallowtalk.mp3');\n  const busyAudio = new Audio('./call_busy.mp3');\n  const connectAudio = new Audio('./call_connect.mp3');\n  const endAudio = new Audio('./call_end.mp3');\n  const incomingAudio = new Audio('./call_incoming.mp3');\n  incomingAudio.loop = true;\n  const ringingAudio = new Audio('./call_ringing.mp3');\n  ringingAudio.loop = true;\n\n  sounds = {\n    join: joinAudio,\n    allowTalk: allowTalkAudio,\n    leave: leaveAudio,\n    connecting: connectingAudio,\n    incoming: incomingAudio,\n    end: endAudio,\n    connect: connectAudio,\n    busy: busyAudio,\n    ringing: ringingAudio,\n  };\n}\n\nasync function fetchGroupCall<T extends GlobalState>(global: T, groupCall: Partial<ApiGroupCall>) {\n  const result = await callApi('getGroupCall', {\n    call: groupCall,\n  });\n\n  if (!result) return undefined;\n\n  global = getGlobal();\n\n  const existingGroupCall = selectGroupCall(global, groupCall.id!);\n\n  global = updateGroupCall(\n    global,\n    groupCall.id!,\n    omit(result.groupCall, ['connectionState']),\n    undefined,\n    existingGroupCall?.isLoaded ? undefined : result.groupCall.participantsCount,\n  );\n  global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n  global = addChats(global, buildCollectionByKey(result.chats, 'id'));\n\n  setGlobal(global);\n\n  return result.groupCall;\n}\n\nasync function fetchGroupCallParticipants<T extends GlobalState>(\n  global: T,\n  groupCall: Partial<ApiGroupCall>, nextOffset?: string,\n) {\n  const result = await callApi('fetchGroupCallParticipants', {\n    call: groupCall as ApiGroupCall,\n    offset: nextOffset,\n  });\n\n  if (!result) return;\n\n  global = getGlobal();\n\n  global = addUsers(global, buildCollectionByKey(result.users, 'id'));\n  global = addChats(global, buildCollectionByKey(result.chats, 'id'));\n\n  setGlobal(global);\n}\n\naddActionHandler('toggleGroupCallPanel', (global, actions, payload): ActionReturnType => {\n  const { force, tabId = getCurrentTabId() } = payload || {};\n  return updateTabState(global, {\n    isCallPanelVisible: 'force' in (payload || {}) ? force : !selectTabState(global, tabId).isCallPanelVisible,\n  }, tabId);\n});\n\naddActionHandler('subscribeToGroupCallUpdates', async (global, actions, payload): Promise<void> => {\n  const { subscribed, id } = payload!;\n  const groupCall = selectGroupCall(global, id);\n\n  if (!groupCall) return;\n\n  if (subscribed) {\n    await fetchGroupCall(global, groupCall);\n    global = getGlobal();\n    await fetchGroupCallParticipants(global, groupCall);\n  }\n\n  await callApi('toggleGroupCallStartSubscription', {\n    subscribed,\n    call: groupCall,\n  });\n});\n\naddActionHandler('createGroupCall', async (global, actions, payload): Promise<void> => {\n  const { chatId, tabId = getCurrentTabId() } = payload;\n\n  const chat = selectChat(global, chatId);\n  if (!chat) {\n    return;\n  }\n\n  const result = await callApi('createGroupCall', {\n    peer: chat,\n  });\n\n  if (!result) return;\n\n  global = getGlobal();\n  global = updateGroupCall(global, result.id, {\n    ...result,\n    chatId,\n  });\n  setGlobal(global);\n\n  actions.requestMasterAndJoinGroupCall({ id: result.id, accessHash: result.accessHash, tabId });\n});\n\naddActionHandler('createGroupCallInviteLink', async (global, actions, payload): Promise<void> => {\n  const { tabId = getCurrentTabId() } = payload || {};\n  const groupCall = selectActiveGroupCall(global);\n\n  if (!groupCall || !groupCall.chatId) {\n    return;\n  }\n\n  const chat = selectChat(global, groupCall.chatId);\n  if (!chat) {\n    return;\n  }\n\n  const hasPublicUsername = Boolean(getMainUsername(chat));\n\n  let { inviteLink } = chat.fullInfo!;\n  if (hasPublicUsername) {\n    inviteLink = await callApi('exportGroupCallInvite', {\n      call: groupCall,\n      canSelfUnmute: false,\n    });\n  }\n\n  if (!inviteLink) {\n    return;\n  }\n\n  copyTextToClipboard(inviteLink);\n  actions.showNotification({\n    message: 'Link copied to clipboard',\n    tabId,\n  });\n});\n\naddActionHandler('joinVoiceChatByLink', async (global, actions, payload): Promise<void> => {\n  const { username, inviteHash, tabId = getCurrentTabId() } = payload!;\n\n  const chat = await fetchChatByUsername(global, username);\n\n  if (!chat) {\n    actions.showNotification({ message: langProvider.translate('NoUsernameFound'), tabId });\n    return;\n  }\n\n  global = getGlobal();\n  const full = await loadFullChat(global, actions, chat, tabId);\n\n  if (full?.groupCall) {\n    actions.requestMasterAndJoinGroupCall({\n      id: full.groupCall.id,\n      accessHash: full.groupCall.accessHash,\n      inviteHash,\n      tabId,\n    });\n  }\n});\n\naddActionHandler('requestMasterAndJoinGroupCall', (global, actions, payload): ActionReturnType => {\n  actions.requestMasterAndCallAction({\n    action: 'joinGroupCall',\n    payload,\n    tabId: payload.tabId || getCurrentTabId(),\n  });\n});\n\naddActionHandler('requestMasterAndAcceptCall', (global, actions, payload): ActionReturnType => {\n  actions.requestMasterAndCallAction({\n    action: 'acceptCall',\n    payload: undefined,\n    tabId: payload?.tabId || getCurrentTabId(),\n  });\n});\n\naddActionHandler('joinGroupCall', async (global, actions, payload): Promise<void> => {\n  const {\n    chatId, id, accessHash, inviteHash, tabId = getCurrentTabId(),\n  } = payload;\n\n  if (!ARE_CALLS_SUPPORTED) return;\n\n  if (global.phoneCall) {\n    actions.toggleGroupCallPanel({ tabId });\n    return;\n  }\n\n  createAudioElement();\n\n  initializeSounds();\n  global = getGlobal();\n  void checkNavigatorUserMediaPermissions(global, actions, true, tabId);\n\n  const { groupCalls: { activeGroupCallId } } = global;\n  let groupCall = id ? selectGroupCall(global, id) : selectChatGroupCall(global, chatId!);\n\n  if (groupCall?.id === activeGroupCallId) {\n    actions.toggleGroupCallPanel({ tabId });\n    return;\n  }\n\n  if (activeGroupCallId) {\n    if ('leaveGroupCall' in actions) {\n      actions.leaveGroupCall({\n        rejoin: payload,\n        tabId,\n      });\n    }\n    return;\n  }\n\n  if (groupCall && activeGroupCallId === groupCall.id) {\n    actions.toggleGroupCallPanel({ tabId });\n    return;\n  }\n\n  if (!groupCall && (!id || !accessHash)) {\n    groupCall = await fetchGroupCall(global, {\n      id,\n      accessHash,\n    });\n  }\n\n  if (!groupCall) return;\n\n  global = getGlobal();\n  global = updateGroupCall(\n    global,\n    groupCall.id,\n    {\n      ...groupCall,\n      inviteHash,\n    },\n    undefined,\n    groupCall.participantsCount + 1,\n  );\n  global = {\n    ...global,\n    groupCalls: {\n      ...global.groupCalls,\n      activeGroupCallId: groupCall.id,\n    },\n  };\n\n  setGlobal(global);\n\n  actions.toggleGroupCallPanel({ force: false, tabId });\n});\n\naddActionHandler('playGroupCallSound', (global, actions, payload): ActionReturnType => {\n  const { sound } = payload!;\n\n  if (!sounds[sound]) {\n    return;\n  }\n\n  const doPlay = () => {\n    if (sound !== 'connecting') {\n      sounds.connecting.pause();\n    }\n    if (sound !== 'incoming') {\n      sounds.incoming.pause();\n    }\n    if (sound !== 'ringing') {\n      sounds.ringing.pause();\n    }\n    safePlay(sounds[sound]);\n  };\n\n  doPlay();\n});\n\naddActionHandler('loadMoreGroupCallParticipants', (global): ActionReturnType => {\n  const groupCall = selectActiveGroupCall(global);\n  if (!groupCall) {\n    return;\n  }\n\n  void fetchGroupCallParticipants(global, groupCall, groupCall.nextOffset);\n});\n\naddActionHandler('requestMasterAndRequestCall', (global, actions, payload): ActionReturnType => {\n  actions.requestMasterAndCallAction({\n    action: 'requestCall',\n    payload,\n    tabId: payload.tabId || getCurrentTabId(),\n  });\n});\n\naddActionHandler('requestCall', async (global, actions, payload): Promise<void> => {\n  const { userId, isVideo, tabId = getCurrentTabId() } = payload;\n\n  if (global.phoneCall) {\n    actions.toggleGroupCallPanel({ tabId });\n    return;\n  }\n\n  const user = selectUser(global, userId);\n\n  if (!user) {\n    return;\n  }\n\n  initializeSounds();\n  global = getGlobal();\n  void checkNavigatorUserMediaPermissions(global, actions, isVideo, tabId);\n\n  global = getGlobal();\n  global = {\n    ...global,\n    phoneCall: {\n      id: '',\n      state: 'requesting',\n      participantId: userId,\n      isVideo,\n      adminId: global.currentUserId,\n    },\n  };\n  setGlobal(global);\n\n  actions.toggleGroupCallPanel({ force: false, tabId });\n});\n\nfunction createAudioContext() {\n  return (new (window.AudioContext || (window as any).webkitAudioContext)());\n}\n\nconst silence = (ctx: AudioContext) => {\n  const oscillator = ctx.createOscillator();\n  const dst = oscillator.connect(ctx.createMediaStreamDestination());\n  oscillator.start();\n  return new MediaStream([Object.assign((dst as any).stream.getAudioTracks()[0], { enabled: false })]);\n};\n\nfunction createAudioElement() {\n  const ctx = createAudioContext();\n  audioElement = new Audio();\n  audioContext = ctx;\n  audioElement.srcObject = silence(ctx);\n  safePlay(audioElement);\n}\n\nexport function getGroupCallAudioElement() {\n  return audioElement;\n}\n\nexport function getGroupCallAudioContext() {\n  return audioContext;\n}\n\nexport function removeGroupCallAudioElement() {\n  audioElement?.pause();\n  audioContext = undefined;\n  audioElement = undefined;\n}\n\n// This method is used instead of a navigator.permissions.query to determine permission to use a microphone,\n// because Firefox does not have support for 'microphone' and 'camera' permissions\n// https://github.com/mozilla/standards-positions/issues/19#issuecomment-370158947\nexport function checkNavigatorUserMediaPermissions<T extends GlobalState>(\n  global: T,\n  actions: RequiredGlobalActions, isVideo?: boolean,\n  ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  if (isVideo) {\n    navigator.mediaDevices.getUserMedia({ video: true })\n      .then((stream) => {\n        if (stream.getVideoTracks().length === 0) {\n          actions.showNotification({\n            message: langProvider.translate('Call.Camera.Error'),\n            tabId,\n          });\n        } else {\n          checkMicrophonePermission(global, actions, tabId);\n        }\n      })\n      .catch(() => {\n        actions.showNotification({\n          message: langProvider.translate('Call.Camera.Error'),\n          tabId,\n        });\n      });\n  } else {\n    checkMicrophonePermission(global, actions, tabId);\n  }\n}\n\nfunction checkMicrophonePermission<T extends GlobalState>(\n  global: T, actions: RequiredGlobalActions, ...[tabId = getCurrentTabId()]: TabArgs<T>\n) {\n  navigator.mediaDevices.getUserMedia({ audio: true })\n    .then((stream) => {\n      if (stream.getAudioTracks().length === 0) {\n        actions.showNotification({\n          message: langProvider.translate('RequestAcces.Error.HaveNotAccess.Call'),\n          tabId,\n        });\n      }\n    })\n    .catch(() => {\n      actions.showNotification({\n        message: langProvider.translate('RequestAcces.Error.HaveNotAccess.Call'),\n        tabId,\n      });\n    });\n}\n","import type { GroupCallParticipant } from '../../lib/secret-sauce';\nimport type { GlobalState } from '../types';\nimport type { ApiGroupCall } from '../../api/types';\nimport { selectGroupCall } from '../selectors/calls';\nimport { omit } from '../../util/iteratees';\nimport { updateChat } from './chats';\nimport { selectChat } from '../selectors';\n\nexport function updateGroupCall<T extends GlobalState>(\n  global: T,\n  groupCallId: string,\n  groupCallUpdate: Partial<ApiGroupCall>,\n  addToParticipantCount?: number,\n  resetParticipantCount?: number,\n): T {\n  const unfiltered = Object.values({\n    ...global.groupCalls.byId[groupCallId]?.participants,\n    ...groupCallUpdate.participants,\n  });\n  const filtered = unfiltered.filter(({ isLeft }) => !isLeft);\n  const participants = filtered.reduce((acc: Record<string, GroupCallParticipant>, el) => {\n    acc[el.id] = el;\n    return acc;\n  }, {});\n\n  return {\n    ...global,\n    groupCalls: {\n      ...global.groupCalls,\n      byId: {\n        ...global.groupCalls.byId,\n        [groupCallId]: {\n          ...global.groupCalls.byId[groupCallId],\n          ...omit(groupCallUpdate, ['participantsCount']),\n          ...(addToParticipantCount && {\n            participantsCount: global.groupCalls.byId[groupCallId].participantsCount + addToParticipantCount,\n          }),\n          ...(resetParticipantCount !== undefined && {\n            participantsCount: resetParticipantCount,\n          }),\n          participants,\n        },\n      },\n    },\n  };\n}\n\nexport function removeGroupCall<T extends GlobalState>(\n  global: T,\n  groupCallId: string,\n): T {\n  const groupCall = selectGroupCall(global, groupCallId);\n  if (groupCall && groupCall.chatId) {\n    const chat = selectChat(global, groupCall.chatId);\n    if (chat) {\n      global = updateChat(global, groupCall.chatId, {\n        fullInfo: {\n          ...chat.fullInfo,\n          groupCallId: undefined,\n        },\n      });\n    }\n  }\n\n  return {\n    ...global,\n    groupCalls: {\n      ...global.groupCalls,\n      byId: {\n        ...omit(global.groupCalls.byId, [groupCallId.toString()]),\n      },\n    },\n  };\n}\n\nexport function updateActiveGroupCall<T extends GlobalState>(\n  global: T,\n  groupCallUpdate: Partial<ApiGroupCall>,\n  resetParticipantCount?: number,\n): T {\n  if (!global.groupCalls.activeGroupCallId) {\n    return global;\n  }\n\n  return updateGroupCall(global,\n    global.groupCalls.activeGroupCallId,\n    groupCallUpdate,\n    undefined,\n    resetParticipantCount);\n}\n\nexport function updateGroupCallParticipant<T extends GlobalState>(\n  global: T,\n  groupCallId: string,\n  userId: string,\n  participantUpdate: Partial<GroupCallParticipant>,\n  noUpdateCount = false,\n): T {\n  const groupCall = selectGroupCall(global, groupCallId);\n  if (!groupCall) {\n    return global;\n  }\n\n  return updateGroupCall(global, groupCallId, {\n    participants: {\n      ...groupCall.participants,\n      [userId]: {\n        ...groupCall.participants[userId],\n        ...participantUpdate,\n      },\n    },\n  }, participantUpdate.isLeft\n    ? (noUpdateCount ? 0 : -1)\n    : (groupCall.participants[userId] || noUpdateCount ? 0 : 1));\n}\n","// eslint-disable-next-line import/no-named-default\nimport {default as Api} from '../tl/api';\n\nimport type TelegramClient from './TelegramClient';\nimport {generateRandomBytes, readBigIntFromBuffer, sleep} from '../Helpers';\nimport {getUploadPartSize} from '../Utils';\nimport errors from '../errors';\nimport {Foreman} from '../../../util/foreman';\nimport {UploadReq} from \"../../ptp/protobuf/PTPFile\";\nimport {CLOUD_MESSAGE_API, DEBUG} from \"../../../config\";\nimport localDb from \"../../../api/gramjs/localDb\";\nimport Account from \"../../../worker/share/Account\";\n\ninterface OnProgress {\n    isCanceled?: boolean;\n\n    // Float between 0 and 1.\n    (progress: number): void;\n}\n\nexport interface UploadFileParams {\n    file: File;\n    workers?: number;\n    onProgress?: OnProgress;\n}\n\nconst KB_TO_BYTES = 1024;\nconst LARGE_FILE_THRESHOLD = 10 * 1024 * 1024;\nconst DISCONNECT_SLEEP = 1000;\nconst MAX_CONCURRENT_CONNECTIONS = 3;\nconst MAX_CONCURRENT_CONNECTIONS_PREMIUM = 6;\nconst MAX_WORKERS_PER_CONNECTION = 10;\n\nconst foremans = Array(MAX_CONCURRENT_CONNECTIONS_PREMIUM).fill(undefined)\n    .map(() => new Foreman(MAX_WORKERS_PER_CONNECTION));\n\nexport async function uploadFileV1(\n    fileParams: UploadFileParams,\n): Promise<Api.InputFile | Api.InputFileBig> {\n    const { file, onProgress } = fileParams;\n    const isPremium = false;\n    const { name, size } = file;\n    let fileId1 = readBigIntFromBuffer(generateRandomBytes(8), true, true);\n    let fileIdStr = fileId1.toString().replace(\"-\",\"\").replace(\"n\",\"\")\n    const fileId = Number(fileIdStr)\n    fileIdStr = String(fileId)\n    localDb.cache[fileIdStr] = file;\n    const isLarge = size > LARGE_FILE_THRESHOLD;\n\n    const partSize = getUploadPartSize(size) * KB_TO_BYTES;\n    const partCount = Math.floor((size + partSize - 1) / partSize);\n    // Pick the least busy foreman\n    // For some reason, fresh connections give out a higher speed for the first couple of seconds\n    // I have no idea why, but this may speed up the download of small files\n    const activeCounts = foremans.map(({ activeWorkers }) => activeWorkers);\n    let currentForemanIndex = activeCounts.indexOf(Math.min(...activeCounts));\n\n    let progress = 0;\n    if (onProgress) {\n        onProgress(progress);\n    }\n\n    const promises: Promise<any>[] = [];\n\n    for (let i = 0; i < partCount; i++) {\n        const senderIndex = currentForemanIndex % (\n            isPremium ? MAX_CONCURRENT_CONNECTIONS_PREMIUM : MAX_CONCURRENT_CONNECTIONS\n        );\n        await foremans[senderIndex].requestWorker();\n\n        if (onProgress?.isCanceled) {\n            foremans[senderIndex].releaseWorker();\n            break;\n        }\n\n        const blobSlice = file.slice(i * partSize, (i + 1) * partSize);\n        // eslint-disable-next-line no-loop-func, @typescript-eslint/no-loop-func\n\n        promises.push((async (jMemo: number, blobSliceMemo: Blob) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                try {\n                    if(CLOUD_MESSAGE_API && Account.getCurrentAccount()?.getSession()){\n                        if(DEBUG){\n                            console.log(\"uploadProfilePhoto\",fileIdStr,jMemo,partCount)\n                        }\n                        const partBytes = await blobSliceMemo.arrayBuffer();\n                        const buf = Buffer.from(partBytes)\n\n                        const fileInfo = {\n                            id:fileIdStr,\n                            size,\n                            type:file.type,\n                            part:jMemo,\n                            part_total:partCount,\n                            buf\n                        }\n                        const uploadReq = new UploadReq({file:fileInfo})\n                        const body = Buffer.from(uploadReq.pack().getPbData());\n                        await fetch(`${CLOUD_MESSAGE_API}/proto`,{\n                            method: 'POST',\n                            body,\n                            headers:{\n                                Authorization: `Bearer ${Account.getCurrentAccount()?.getSession()}`,\n                            }\n                        })\n                    }\n                } catch (err) {\n                    // if (sender && !sender.isConnected()) {\n                    //     await sleep(DISCONNECT_SLEEP);\n                    //     continue;\n                    // } else if (err instanceof errors.FloodWaitError) {\n                    //     await sleep(err.seconds * 1000);\n                    //     continue;\n                    // }\n                    foremans[senderIndex].releaseWorker();\n                    throw err;\n                }\n\n                foremans[senderIndex].releaseWorker();\n\n                if (onProgress) {\n                    if (onProgress.isCanceled) {\n                        throw new Error('USER_CANCELED');\n                    }\n\n                    progress += (1 / partCount);\n                    onProgress(progress);\n                }\n                break;\n            }\n        })(i, blobSlice));\n\n        currentForemanIndex++;\n    }\n\n    await Promise.all(promises);\n\n    return isLarge\n        ? new Api.InputFileBig({\n            id: fileId,\n            parts: partCount,\n            name,\n        })\n        : new Api.InputFile({\n            id: fileId,\n            parts: partCount,\n            name,\n            md5Checksum: '', // This is not a \"flag\", so not sure if we can make it optional.\n        });\n}\n\n\nexport async function uploadFile(\n    client: TelegramClient,\n    fileParams: UploadFileParams,\n): Promise<Api.InputFile | Api.InputFileBig> {\n    const { file, onProgress } = fileParams;\n\n    const isPremium = Boolean(client.isPremium);\n\n    const { name, size } = file;\n    const fileId = readBigIntFromBuffer(generateRandomBytes(8), true, true);\n    const isLarge = size > LARGE_FILE_THRESHOLD;\n\n    const partSize = getUploadPartSize(size) * KB_TO_BYTES;\n    const partCount = Math.floor((size + partSize - 1) / partSize);\n\n    // Pick the least busy foreman\n    // For some reason, fresh connections give out a higher speed for the first couple of seconds\n    // I have no idea why, but this may speed up the download of small files\n    const activeCounts = foremans.map(({ activeWorkers }) => activeWorkers);\n    let currentForemanIndex = activeCounts.indexOf(Math.min(...activeCounts));\n\n    let progress = 0;\n    if (onProgress) {\n        onProgress(progress);\n    }\n\n    const promises: Promise<any>[] = [];\n\n    for (let i = 0; i < partCount; i++) {\n        const senderIndex = currentForemanIndex % (\n            isPremium ? MAX_CONCURRENT_CONNECTIONS_PREMIUM : MAX_CONCURRENT_CONNECTIONS\n        );\n\n        await foremans[senderIndex].requestWorker();\n\n        if (onProgress?.isCanceled) {\n            foremans[senderIndex].releaseWorker();\n            break;\n        }\n\n        const blobSlice = file.slice(i * partSize, (i + 1) * partSize);\n        // eslint-disable-next-line no-loop-func, @typescript-eslint/no-loop-func\n        promises.push((async (jMemo: number, blobSliceMemo: Blob) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                let sender;\n                try {\n                    // We always upload from the DC we are in\n                    sender = await client.getSender(client.session.dcId, senderIndex, isPremium);\n                    const partBytes = await blobSliceMemo.arrayBuffer();\n                    await sender.send(\n                        isLarge\n                            ? new Api.upload.SaveBigFilePart({\n                                fileId,\n                                filePart: jMemo,\n                                fileTotalParts: partCount,\n                                bytes: Buffer.from(partBytes),\n                            })\n                            : new Api.upload.SaveFilePart({\n                                fileId,\n                                filePart: jMemo,\n                                bytes: Buffer.from(partBytes),\n                            }),\n                    );\n                } catch (err) {\n                    if (sender && !sender.isConnected()) {\n                        await sleep(DISCONNECT_SLEEP);\n                        continue;\n                    } else if (err instanceof errors.FloodWaitError) {\n                        await sleep(err.seconds * 1000);\n                        continue;\n                    }\n                    foremans[senderIndex].releaseWorker();\n\n                    throw err;\n                }\n\n                foremans[senderIndex].releaseWorker();\n\n                if (onProgress) {\n                    if (onProgress.isCanceled) {\n                        throw new Error('USER_CANCELED');\n                    }\n\n                    progress += (1 / partCount);\n                    onProgress(progress);\n                }\n                break;\n            }\n        })(i, blobSlice));\n\n        currentForemanIndex++;\n    }\n\n    await Promise.all(promises);\n\n    return isLarge\n        ? new Api.InputFileBig({\n            id: fileId,\n            parts: partCount,\n            name,\n        })\n        : new Api.InputFile({\n            id: fileId,\n            parts: partCount,\n            name,\n            md5Checksum: '', // This is not a \"flag\", so not sure if we can make it optional.\n        });\n}\n","/**\n * Converts a Telegram's RPC Error to a Python error.\n * @param rpcError the RPCError instance\n * @param request the request that caused this error\n * @constructor the RPCError as a Python exception that represents this error\n */\nconst { RPCError } = require('./RPCBaseErrors');\nconst { rpcErrorRe } = require('./RPCErrorList');\n\nfunction RPCMessageToError(rpcError, request) {\n    for (const [msgRegex, Cls] of rpcErrorRe) {\n        const m = rpcError.errorMessage.match(msgRegex);\n        if (m) {\n            const capture = m.length === 2 ? parseInt(m[1], 10) : undefined;\n            return new Cls({\n                request,\n                capture,\n            });\n        }\n    }\n\n    return new RPCError(rpcError.errorMessage, request);\n}\n\nconst Common = require('./Common');\nconst RPCBaseErrors = require('./RPCBaseErrors');\nconst RPCErrorList = require('./RPCErrorList');\n\nmodule.exports = {\n    RPCMessageToError,\n    ...Common,\n    ...RPCBaseErrors,\n    ...RPCErrorList,\n};\n","const {\n    parseTl,\n    serializeBytes,\n    serializeDate,\n} = require('./generationHelpers');\nconst {\n    toSignedLittleBuffer,\n} = require('../Helpers');\n\nconst tlContent = require('./apiTl');\nconst schemeContent = require('./schemaTl');\n\n/* CONTEST\nconst NAMED_AUTO_CASTS = new Set([\n    'chatId,int'\n])\nconst NAMED_BLACKLIST = new Set([\n    'discardEncryption'\n])\nconst AUTO_CASTS = new Set([\n    'InputPeer',\n    'InputChannel',\n    'InputUser',\n    'InputDialogPeer',\n    'InputNotifyPeer',\n    'InputMedia',\n    'InputPhoto',\n    'InputMessage',\n    'InputDocument',\n    'InputChatPhoto'\n])\n\n */\n// eslint-disable-next-line no-restricted-globals\nconst CACHING_SUPPORTED = typeof self !== 'undefined' && self.localStorage !== undefined;\n\nconst CACHE_KEY = 'GramJs:apiCache';\n\nfunction buildApiFromTlSchema() {\n    let definitions;\n    const fromCache = CACHING_SUPPORTED && loadFromCache();\n\n    if (fromCache) {\n        definitions = fromCache;\n    } else {\n        definitions = loadFromTlSchemas();\n\n        if (CACHING_SUPPORTED) {\n            localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));\n        }\n    }\n\n    return mergeWithNamespaces(\n        createClasses('constructor', definitions.constructors),\n        createClasses('request', definitions.requests),\n    );\n}\n\nfunction loadFromCache() {\n    const jsonCache = localStorage.getItem(CACHE_KEY);\n    return jsonCache && JSON.parse(jsonCache);\n}\n\nfunction loadFromTlSchemas() {\n    const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);\n    const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);\n    const constructors = [].concat(constructorParamsApi, constructorParamsSchema);\n    const requests = [].concat(functionParamsApi, functionParamsSchema);\n\n    return {\n        constructors,\n        requests,\n    };\n}\n\nfunction mergeWithNamespaces(obj1, obj2) {\n    const result = { ...obj1 };\n\n    Object.keys(obj2)\n        .forEach((key) => {\n            if (typeof obj2[key] === 'function' || !result[key]) {\n                result[key] = obj2[key];\n            } else {\n                Object.assign(result[key], obj2[key]);\n            }\n        });\n\n    return result;\n}\n\nfunction extractParams(fileContent) {\n    const f = parseTl(fileContent);\n    const constructors = [];\n    const functions = [];\n    for (const d of f) {\n        if (d.isFunction) {\n            functions.push(d);\n        } else {\n            constructors.push(d);\n        }\n    }\n    return [constructors, functions];\n}\n\nfunction argToBytes(x, type) {\n    switch (type) {\n        case 'int': {\n            const i = Buffer.alloc(4);\n            i.writeInt32LE(x, 0);\n            return i;\n        }\n        case 'long':\n            return toSignedLittleBuffer(x, 8);\n        case 'int128':\n            return toSignedLittleBuffer(x, 16);\n        case 'int256':\n            return toSignedLittleBuffer(x, 32);\n        case 'double': {\n            const d = Buffer.alloc(8);\n            d.writeDoubleLE(x, 0);\n            return d;\n        }\n        case 'string':\n            return serializeBytes(x);\n        case 'Bool':\n            return x ? Buffer.from('b5757299', 'hex') : Buffer.from('379779bc', 'hex');\n        case 'true':\n            return Buffer.alloc(0);\n        case 'bytes':\n            return serializeBytes(x);\n        case 'date':\n            return serializeDate(x);\n        default:\n            return x.getBytes();\n    }\n}\n\n/*\nCONTEST\nasync function getInputFromResolve(utils, client, peer, peerType) {\n    switch (peerType) {\n        case 'InputPeer':\n            return utils.getInputPeer(await client.getInputEntity(peer))\n        case 'InputChannel':\n            return utils.getInputChannel(await client.getInputEntity(peer))\n        case 'InputUser':\n            return utils.getInputUser(await client.getInputEntity(peer))\n        case 'InputDialogPeer':\n            return await client._getInputDialog(peer)\n        case 'InputNotifyPeer':\n            return await client._getInputNotify(peer)\n        case 'InputMedia':\n            return utils.getInputMedia(peer)\n        case 'InputPhoto':\n            return utils.getInputPhoto(peer)\n        case 'InputMessage':\n            return utils.getInputMessage(peer)\n        case 'InputDocument':\n            return utils.getInputDocument(peer)\n        case 'InputChatPhoto':\n            return utils.getInputChatPhoto(peer)\n        case 'chatId,int' :\n            return await client.getPeerId(peer, false)\n        default:\n            throw new Error('unsupported peer type : ' + peerType)\n    }\n}\n*/\nfunction getArgFromReader(reader, arg) {\n    if (arg.isVector) {\n        if (arg.useVectorId) {\n            reader.readInt();\n        }\n        const temp = [];\n        const len = reader.readInt();\n        arg.isVector = false;\n        for (let i = 0; i < len; i++) {\n            temp.push(getArgFromReader(reader, arg));\n        }\n        arg.isVector = true;\n        return temp;\n    } else if (arg.flagIndicator) {\n        return reader.readInt();\n    } else {\n        switch (arg.type) {\n            case 'int':\n                return reader.readInt();\n            case 'long':\n                return reader.readLong();\n            case 'int128':\n                return reader.readLargeInt(128);\n            case 'int256':\n                return reader.readLargeInt(256);\n            case 'double':\n                return reader.readDouble();\n            case 'string':\n                return reader.tgReadString();\n            case 'Bool':\n                return reader.tgReadBool();\n            case 'true':\n                return true;\n            case 'bytes':\n                return reader.tgReadBytes();\n            case 'date':\n                return reader.tgReadDate();\n            default:\n                if (!arg.skipConstructorId) {\n                    return reader.tgReadObject();\n                } else {\n                    throw new Error(`Unknown type ${arg}`);\n                }\n        }\n    }\n}\n\nfunction createClasses(classesType, params) {\n    const classes = {};\n    for (const classParams of params) {\n        const {\n            name,\n            constructorId,\n            subclassOfId,\n            argsConfig,\n            namespace,\n            result,\n        } = classParams;\n        const fullName = [namespace, name].join('.')\n            .replace(/^\\./, '');\n\n        class VirtualClass {\n            static CONSTRUCTOR_ID = constructorId;\n\n            static SUBCLASS_OF_ID = subclassOfId;\n\n            static className = fullName;\n\n            static classType = classesType;\n\n            CONSTRUCTOR_ID = constructorId;\n\n            SUBCLASS_OF_ID = subclassOfId;\n\n            className = fullName;\n\n            classType = classesType;\n\n            constructor(args) {\n                args = args || {};\n                Object.keys(args)\n                    .forEach((argName) => {\n                        this[argName] = args[argName];\n                    });\n            }\n\n            static fromReader(reader) {\n                const args = {};\n\n                for (const argName in argsConfig) {\n                    if (argsConfig.hasOwnProperty(argName)) {\n                        const arg = argsConfig[argName];\n                        if (arg.isFlag) {\n                            const flagGroupSuffix = arg.flagGroup > 1 ? arg.flagGroup : '';\n                            const flagValue = args[`flags${flagGroupSuffix}`] & (1 << arg.flagIndex);\n                            if (arg.type === 'true') {\n                                args[argName] = Boolean(flagValue);\n                                continue;\n                            }\n\n                            args[argName] = flagValue ? getArgFromReader(reader, arg) : undefined;\n                        } else {\n                            args[argName] = getArgFromReader(reader, arg);\n                        }\n                    }\n                }\n                return new VirtualClass(args);\n            }\n\n            getBytes() {\n                // The next is pseudo-code:\n                const idForBytes = this.CONSTRUCTOR_ID;\n                const c = Buffer.alloc(4);\n                c.writeUInt32LE(idForBytes, 0);\n                const buffers = [c];\n                for (const arg in argsConfig) {\n                    if (argsConfig.hasOwnProperty(arg)) {\n                        if (argsConfig[arg].isFlag) {\n                            if ((this[arg] === false && argsConfig[arg].type === 'true')\n                                || this[arg] === undefined) {\n                                continue;\n                            }\n                        }\n                        if (argsConfig[arg].isVector) {\n                            if (argsConfig[arg].useVectorId) {\n                                buffers.push(Buffer.from('15c4b51c', 'hex'));\n                            }\n                            const l = Buffer.alloc(4);\n                            l.writeInt32LE(this[arg].length, 0);\n                            buffers.push(l, Buffer.concat(this[arg].map((x) => argToBytes(x, argsConfig[arg].type))));\n                        } else if (argsConfig[arg].flagIndicator) {\n                            if (!Object.values(argsConfig)\n                                .some((f) => f.isFlag)) {\n                                buffers.push(Buffer.alloc(4));\n                            } else {\n                                let flagCalculate = 0;\n                                for (const f in argsConfig) {\n                                    if (argsConfig[f].isFlag) {\n                                        if ((this[f] === false && argsConfig[f].type === 'true')\n                                            || this[f] === undefined) {\n                                            flagCalculate |= 0;\n                                        } else {\n                                            flagCalculate |= 1 << argsConfig[f].flagIndex;\n                                        }\n                                    }\n                                }\n                                const f = Buffer.alloc(4);\n                                f.writeUInt32LE(flagCalculate, 0);\n                                buffers.push(f);\n                            }\n                        } else {\n                            buffers.push(argToBytes(this[arg], argsConfig[arg].type));\n\n                            if (this[arg] && typeof this[arg].getBytes === 'function') {\n                                let boxed = (argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf('.') + 1));\n                                boxed = boxed === boxed.toUpperCase();\n                                if (!boxed) {\n                                    buffers.shift();\n                                }\n                            }\n                        }\n                    }\n                }\n                return Buffer.concat(buffers);\n            }\n\n            readResult(reader) {\n                if (classesType !== 'request') {\n                    throw new Error('`readResult()` called for non-request instance');\n                }\n\n                const m = result.match(/Vector<(int|long)>/);\n                if (m) {\n                    reader.readInt();\n                    const temp = [];\n                    const len = reader.readInt();\n                    if (m[1] === 'int') {\n                        for (let i = 0; i < len; i++) {\n                            temp.push(reader.readInt());\n                        }\n                    } else {\n                        for (let i = 0; i < len; i++) {\n                            temp.push(reader.readLong());\n                        }\n                    }\n                    return temp;\n                } else {\n                    return reader.tgReadObject();\n                }\n            }\n\n            /* CONTEST\n            async resolve(client, utils) {\n\n                if (classesType !== 'request') {\n                    throw new Error('`resolve()` called for non-request instance')\n                }\n\n                for (const arg in argsConfig) {\n                    if (argsConfig.hasOwnProperty(arg)) {\n                        if (!AUTO_CASTS.has(argsConfig[arg].type)) {\n                            if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {\n                                continue\n                            }\n                        }\n                        if (argsConfig[arg].isFlag) {\n                            if (!this[arg]) {\n                                continue\n                            }\n                        }\n                        if (argsConfig[arg].isVector) {\n                            const temp = []\n                            for (const x of this[arg]) {\n                                temp.push(await getInputFromResolve(utils, client, x, argsConfig[arg].type))\n                            }\n                            this[arg] = temp\n                        } else {\n                            this[arg] = await getInputFromResolve(utils, client, this[arg], argsConfig[arg].type)\n                        }\n                    }\n                }\n            } */\n        }\n\n        if (namespace) {\n            if (!classes[namespace]) {\n                classes[namespace] = {};\n            }\n            classes[namespace][name] = VirtualClass;\n        } else {\n            classes[name] = VirtualClass;\n        }\n    }\n\n    return classes;\n}\n\nmodule.exports = buildApiFromTlSchema();\n","export enum ActionCommands {\n  CID_AuthLoginReq = 1001,\n  CID_AuthLoginRes = 1002,\n  CID_AuthNativeReq = 1003,\n  CID_AuthNativeRes = 1004,\n  CID_AuthPreLoginReq = 1005,\n  CID_AuthPreLoginRes = 1006,\n  CID_AuthStep1Req = 1007,\n  CID_AuthStep1Res = 1008,\n  CID_AuthStep2Req = 1009,\n  CID_AuthStep2Res = 1010,\n  CID_UpdateProfileReq = 1011,\n  CID_UpdateProfileRes = 1012,\n  CID_UpdateUsernameReq = 1013,\n  CID_UpdateUsernameRes = 1014,\n  CID_UploadProfilePhotoReq = 1015,\n  CID_UploadProfilePhotoRes = 1016,\n  CID_LoadChatsReq = 2001,\n  CID_LoadChatsRes = 2002,\n  CID_DownloadReq = 3001,\n  CID_DownloadRes = 3002,\n  CID_UploadReq = 3003,\n  CID_UploadRes = 3004,\n  CID_AnswerCallbackButtonReq = 4001,\n  CID_AnswerCallbackButtonRes = 4002,\n  CID_DownloadMsgReq = 4003,\n  CID_DownloadMsgRes = 4004,\n  CID_GenMsgIdReq = 4005,\n  CID_GenMsgIdRes = 4006,\n  CID_MsgDeleteReq = 4007,\n  CID_MsgDeleteRes = 4008,\n  CID_MsgListReq = 4009,\n  CID_MsgListRes = 4010,\n  CID_MsgUpdateReq = 4011,\n  CID_MsgUpdateRes = 4012,\n  CID_RemoveMessagesReq = 4013,\n  CID_RemoveMessagesRes = 4014,\n  CID_SendReq = 4015,\n  CID_SendRes = 4016,\n  CID_UploadMsgReq = 4017,\n  CID_UploadMsgRes = 4018,\n  CID_OtherNotify = 5001,\n  CID_SyncReq = 6001,\n  CID_SyncRes = 6002,\n  CID_DownloadUserReq = 7001,\n  CID_DownloadUserRes = 7002,\n  CID_GenUserIdReq = 7003,\n  CID_GenUserIdRes = 7004,\n  CID_UploadUserReq = 7005,\n  CID_UploadUserRes = 7006,\n}\n\nexport const ActionCommandsName = {\n  1001: \"CID_AuthLoginReq\",\n  1002: \"CID_AuthLoginRes\",\n  1003: \"CID_AuthNativeReq\",\n  1004: \"CID_AuthNativeRes\",\n  1005: \"CID_AuthPreLoginReq\",\n  1006: \"CID_AuthPreLoginRes\",\n  1007: \"CID_AuthStep1Req\",\n  1008: \"CID_AuthStep1Res\",\n  1009: \"CID_AuthStep2Req\",\n  1010: \"CID_AuthStep2Res\",\n  1011: \"CID_UpdateProfileReq\",\n  1012: \"CID_UpdateProfileRes\",\n  1013: \"CID_UpdateUsernameReq\",\n  1014: \"CID_UpdateUsernameRes\",\n  1015: \"CID_UploadProfilePhotoReq\",\n  1016: \"CID_UploadProfilePhotoRes\",\n  2001: \"CID_LoadChatsReq\",\n  2002: \"CID_LoadChatsRes\",\n  3001: \"CID_DownloadReq\",\n  3002: \"CID_DownloadRes\",\n  3003: \"CID_UploadReq\",\n  3004: \"CID_UploadRes\",\n  4001: \"CID_AnswerCallbackButtonReq\",\n  4002: \"CID_AnswerCallbackButtonRes\",\n  4003: \"CID_DownloadMsgReq\",\n  4004: \"CID_DownloadMsgRes\",\n  4005: \"CID_GenMsgIdReq\",\n  4006: \"CID_GenMsgIdRes\",\n  4007: \"CID_MsgDeleteReq\",\n  4008: \"CID_MsgDeleteRes\",\n  4009: \"CID_MsgListReq\",\n  4010: \"CID_MsgListRes\",\n  4011: \"CID_MsgUpdateReq\",\n  4012: \"CID_MsgUpdateRes\",\n  4013: \"CID_RemoveMessagesReq\",\n  4014: \"CID_RemoveMessagesRes\",\n  4015: \"CID_SendReq\",\n  4016: \"CID_SendRes\",\n  4017: \"CID_UploadMsgReq\",\n  4018: \"CID_UploadMsgRes\",\n  5001: \"CID_OtherNotify\",\n  6001: \"CID_SyncReq\",\n  6002: \"CID_SyncRes\",\n  7001: \"CID_DownloadUserReq\",\n  7002: \"CID_DownloadUserRes\",\n  7003: \"CID_GenUserIdReq\",\n  7004: \"CID_GenUserIdRes\",\n  7005: \"CID_UploadUserReq\",\n  7006: \"CID_UploadUserRes\",\n};\n\nexport const getActionCommandsName = (cid:ActionCommands)=>{\n   return ActionCommandsName[cid] || cid.toString();\n}\n\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { AuthNativeReq_Type } from './types';\n\nexport default class AuthNativeReq extends BaseMsg {\n  public msg?: AuthNativeReq_Type\n  constructor(msg?: AuthNativeReq_Type) {\n    super('PTP.Auth.AuthNativeReq', msg);\n    this.setCommandId(ActionCommands.CID_AuthNativeReq);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): AuthNativeReq_Type {\n    return new AuthNativeReq().decode(pdu.body());\n  }\n}\n","// DO NOT EDIT\nimport BaseMsg from '../BaseMsg';\nimport type { Pdu } from '../BaseMsg';\nimport type { PbMsg_Type } from './types';\n\nexport default class PbMsg extends BaseMsg {\n  public msg?: PbMsg_Type\n  constructor(msg?: PbMsg_Type) {\n    super('PTP.Common.PbMsg', msg);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): PbMsg_Type {\n    return new PbMsg().decode(pdu.body());\n  }\n}\n","// DO NOT EDIT\nimport BaseMsg from '../BaseMsg';\nimport type { Pdu } from '../BaseMsg';\nimport type { PbQrCode_Type } from './types';\n\nexport default class PbQrCode extends BaseMsg {\n  public msg?: PbQrCode_Type\n  constructor(msg?: PbQrCode_Type) {\n    super('PTP.Common.PbQrCode', msg);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): PbQrCode_Type {\n    return new PbQrCode().decode(pdu.body());\n  }\n}\n","// DO NOT EDIT\nimport BaseMsg from '../BaseMsg';\nimport type { Pdu } from '../BaseMsg';\nimport type { PbUser_Type } from './types';\n\nexport default class PbUser extends BaseMsg {\n  public msg?: PbUser_Type\n  constructor(msg?: PbUser_Type) {\n    super('PTP.Common.PbUser', msg);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): PbUser_Type {\n    return new PbUser().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { DownloadMsgReq_Type } from './types';\n\nexport default class DownloadMsgReq extends BaseMsg {\n  public msg?: DownloadMsgReq_Type\n  constructor(msg?: DownloadMsgReq_Type) {\n    super('PTP.Msg.DownloadMsgReq', msg);\n    this.setCommandId(ActionCommands.CID_DownloadMsgReq);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): DownloadMsgReq_Type {\n    return new DownloadMsgReq().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { DownloadMsgRes_Type } from './types';\n\nexport default class DownloadMsgRes extends BaseMsg {\n  public msg?: DownloadMsgRes_Type\n  constructor(msg?: DownloadMsgRes_Type) {\n    super('PTP.Msg.DownloadMsgRes', msg);\n    this.setCommandId(ActionCommands.CID_DownloadMsgRes);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): DownloadMsgRes_Type {\n    return new DownloadMsgRes().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { GenMsgIdReq_Type } from './types';\n\nexport default class GenMsgIdReq extends BaseMsg {\n  public msg?: GenMsgIdReq_Type\n  constructor(msg?: GenMsgIdReq_Type) {\n    super('PTP.Msg.GenMsgIdReq', msg);\n    this.setCommandId(ActionCommands.CID_GenMsgIdReq);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): GenMsgIdReq_Type {\n    return new GenMsgIdReq().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { GenMsgIdRes_Type } from './types';\n\nexport default class GenMsgIdRes extends BaseMsg {\n  public msg?: GenMsgIdRes_Type\n  constructor(msg?: GenMsgIdRes_Type) {\n    super('PTP.Msg.GenMsgIdRes', msg);\n    this.setCommandId(ActionCommands.CID_GenMsgIdRes);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): GenMsgIdRes_Type {\n    return new GenMsgIdRes().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { UploadMsgReq_Type } from './types';\n\nexport default class UploadMsgReq extends BaseMsg {\n  public msg?: UploadMsgReq_Type\n  constructor(msg?: UploadMsgReq_Type) {\n    super('PTP.Msg.UploadMsgReq', msg);\n    this.setCommandId(ActionCommands.CID_UploadMsgReq);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): UploadMsgReq_Type {\n    return new UploadMsgReq().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { DownloadUserReq_Type } from './types';\n\nexport default class DownloadUserReq extends BaseMsg {\n  public msg?: DownloadUserReq_Type\n  constructor(msg?: DownloadUserReq_Type) {\n    super('PTP.User.DownloadUserReq', msg);\n    this.setCommandId(ActionCommands.CID_DownloadUserReq);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): DownloadUserReq_Type {\n    return new DownloadUserReq().decode(pdu.body());\n  }\n}\n","import MsgDispatcher from \"./MsgDispatcher\";\nimport {selectChat, selectChatMessage, selectUser} from \"../../global/selectors\";\nimport {updateChat, updateUser} from \"../../global/reducers\";\nimport {DEFAULT_BOT_COMMANDS, UserIdFirstBot} from \"../setting\";\nimport {getActions, getGlobal, setGlobal} from \"../../global\";\nimport {ApiBotCommand} from \"../../api/types\";\nimport {callApiWithPdu} from \"./utils\";\nimport {currentTs} from \"../share/utils/utils\";\n\nimport {MessageStoreRow_Type, UserStoreRow_Type} from \"../../lib/ptp/protobuf/PTPCommon/types\";\nimport {UploadMsgReq} from \"../../lib/ptp/protobuf/PTPMsg\";\nimport {DownloadUserReq, UploadUserReq} from \"../../lib/ptp/protobuf/PTPUser\";\nimport Mnemonic from \"../../lib/ptp/wallet/Mnemonic\";\nimport Account from \"../share/Account\";\nimport {AuthNativeReq} from \"../../lib/ptp/protobuf/PTPAuth\";\nimport {GlobalState} from \"../../global/types\";\nimport {getPasswordFromEvent} from \"../share/utils/password\";\nimport {hashSha256} from \"../share/utils/helpers\";\nimport MsgCommandSetting from \"./MsgCommandSetting\";\nimport {ControllerPool} from \"../../lib/ptp/functions/requests\";\nimport MsgCommandChatGpt from \"./MsgCommandChatGpt\";\n\nexport default class MsgCommand {\n  private msgDispatcher: MsgDispatcher;\n  constructor(msgDispatcher:MsgDispatcher) {\n    this.msgDispatcher = msgDispatcher;\n  }\n  static async sendText(chatId:string,text:string){\n    const messageId = await MsgDispatcher.genMsgId();\n    MsgDispatcher.newMessage(chatId,messageId,{\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:text\n        }\n      },\n    })\n  }\n  static async clearHistory(chatId:string){\n    let global = getGlobal();\n    const chatMessages = global.messages.byChatId[chatId];\n    const ids = Object.keys(chatMessages.byId).map(Number);\n    const chat = selectChat(global,chatId)\n    MsgDispatcher.apiUpdate({\n      \"@type\":\"deleteMessages\",\n      chatId,\n      ids\n    })\n    setTimeout(()=>{\n      global = getGlobal();\n      global = updateChat(global,chatId,{\n        ...chat,\n        unreadCount:0,\n        lastMessage:MsgDispatcher.buildMsgHistoryClear(chatId)\n      })\n      setGlobal(global)\n    },500)\n\n    return true;\n  }\n\n  async showMnemonic(){\n    await this.msgDispatcher.sendOutgoingMsg();\n    await this.msgDispatcher.replyText(\"显示成功\")\n    getActions().updateGlobal({\n      showMnemonicModal:true\n    })\n  }\n  async setAuth(){\n    await this.msgDispatcher.sendOutgoingMsg();\n    const m = \"control combine high meat erode catalog public tumble rebel benefit upon public\"\n    const account = Account.getInstance(Account.genAccountId());\n    const entropy = new Mnemonic(m).toEntropy();\n    await account.setEntropy(entropy)\n    const accountId = account.getAccountId();\n    Account.setCurrentAccountId(accountId)\n    const session = account?.getSession();\n    if(!session){\n      const {password} = await getPasswordFromEvent();\n      if(password){\n        const pwd = hashSha256(password)\n        const ts = +(new Date());\n        const {address, sign} = await account.signMessage(ts.toString(), pwd);\n        const session = Account.formatSession({address,sign,ts});\n        account.saveSession(session)\n        const entropy = await account.getEntropy()\n        const accountId = account.getAccountId();\n        await callApiWithPdu(new AuthNativeReq({\n          accountId,entropy,session\n        }).pack())\n        await this.msgDispatcher.replyText(\"账户设置成功\")\n        await this.msgDispatcher.replyCode(session)\n        await this.msgDispatcher.replyCode(entropy)\n        await this.msgDispatcher.replyCode(accountId.toString())\n      }\n    }else {\n      await this.msgDispatcher.replyCode(session)\n    }\n  }\n  async genMnemonic(){\n    await this.msgDispatcher.sendOutgoingMsg();\n    const m = new Mnemonic()\n    return await this.msgDispatcher.replyNewTextMessage({text:m.getWords()})\n  }\n  async downloadBots(botId:string){\n    let global = getGlobal();\n    const user = selectUser(global,botId);\n\n    await this.msgDispatcher.sendOutgoingMsg();\n    const res = await callApiWithPdu(new DownloadUserReq({\n      userIds:[user!.id!],\n    }).pack())\n\n    await this.msgDispatcher.replyNewTextMessage({text:`正在下载`})\n    return true;\n\n  }\n  async uploadBots(botId:string){\n    let global = getGlobal();\n    const user = selectUser(global,botId);\n\n    await this.msgDispatcher.sendOutgoingMsg();\n    const users:UserStoreRow_Type[] = [];\n    const ids = [user?.id]\n    for (let i = 0; i < ids.length; i++) {\n      if(i > 0){\n        break\n      }\n      const id = ids[i];\n      users.push({\n        time:currentTs(),\n        userId:id!,\n        user:selectUser(global,botId)\n      })\n    }\n    const res = await callApiWithPdu(new UploadUserReq({\n      users,\n      time:currentTs()\n    }).pack())\n    const text = await Account.getCurrentAccount()?.getEntropy();\n    await this.msgDispatcher.replyNewTextMessage({text})\n    return true;\n\n  }\n  async uploadMessages(chatId:string,messageIds?:number[]){\n    let global = getGlobal();\n    const chatMessages = global.messages.byChatId[chatId];\n    const ids = Object.keys(chatMessages.byId).map(Number);\n    await this.msgDispatcher.sendOutgoingMsg();\n    const messages:MessageStoreRow_Type[] = [];\n    for (let i = 0; i < ids.length; i++) {\n      if(i > 0){\n        break\n      }\n      const id = ids[i]\n\n      messages.push({\n        time:currentTs(),\n        messageId:id,\n        message:selectChatMessage(global,chatId,id)\n      })\n    }\n    const res = await callApiWithPdu(new UploadMsgReq({\n      messages,\n      chatId,\n      time:currentTs()\n    }).pack())\n\n    await this.msgDispatcher.replyNewTextMessage({text:`正在上传.. ${ids.length}`})\n    return true;\n  }\n  async reloadCommands(){\n    let global = getGlobal();\n    let user = selectUser(global,this.msgDispatcher.getChatId())\n    const botInfo = user?.fullInfo?.botInfo;\n    if(botInfo){\n      //@ts-ignore\n      const commands:ApiBotCommand[] = DEFAULT_BOT_COMMANDS.map(cmd => {\n        return {\n          ...cmd,\n          botId: user?.id\n        };\n      });\n      global = updateUser(global,user?.id!,{\n        ...user,\n        fullInfo:{\n          ...user?.fullInfo,\n          botInfo:{\n            ...user?.fullInfo!.botInfo!,\n            commands\n          }\n        }\n      })\n      setGlobal(global)\n      global = getGlobal()\n      const chat = selectChat(global,this.msgDispatcher.getChatId())\n      user = selectUser(global,chat?.id!)\n\n      await this.msgDispatcher.sendOutgoingMsg();\n      await this.msgDispatcher.replyNewTextMessage({text:\"重载成功\"})\n      // await this.msgDispatcher.replyNewTextMessage({text:\"```\\n\"+JSON.stringify(chat,null,2)+\"```\"})\n      // await this.msgDispatcher.replyNewTextMessage({text:\"```\\n\"+JSON.stringify(user,null,2)+\"```\"})\n      return true;\n    }\n  }\n  async setting(){\n    const chatId = this.msgDispatcher.getChatId()\n    await this.msgDispatcher.sendOutgoingMsg();\n    await MsgCommandSetting.setting(chatId);\n  }\n  static async requestUploadImage(global:GlobalState,chatId:string,messageId:number,files:FileList | null){\n    debugger\n  }\n  static async answerCallbackButton(global:GlobalState,chatId:string,messageId:number,data:string){\n    await MsgCommandSetting.answerCallbackButton(global,chatId,messageId,data)\n    await MsgCommandChatGpt.answerCallbackButton(global,chatId,messageId,data)\n    if(data.startsWith(\"requestChatStream/stop/\")){\n      const [chatId,messageId] = data.replace(\"requestChatStream/stop/\",\"\").split(\"/\").map(Number)\n      ControllerPool.stop(chatId,messageId);\n    }\n  }\n  async temp(){\n    await this.msgDispatcher.sendOutgoingMsg();\n    await this.msgDispatcher.sendNewMessage({\n      text:{\n        text:\"test\"\n      }\n    },{\n      inlineButtons:[\n        [\n          {\n            data:\"1\",\n            text:\"callback button\",\n            type:\"callback\"\n          },\n        ],\n        [\n          {\n            text:\"command button\",\n            type:'command'\n          },\n          {\n            text:\"unsupported button\",\n            type:'unsupported'\n          },\n          {\n            text:\"buy button\",\n            type:'buy'\n          }\n        ],\n        [\n          {\n            text:\"game button\",\n            type:'game'\n          },\n          {\n            text:\"requestPhone button\",\n            type:'requestPhone'\n          }\n        ],\n        [\n          {\n            text:\"receipt button\",\n            type:'receipt',\n            receiptMessageId:1\n          },\n        ],\n        [\n          {\n            text:\"url button\",\n            type:'url',\n            url:\"http://www.ai.com\"\n          },\n        ],\n        [\n          {\n            text:\"simpleWebView button\",\n            type:'simpleWebView',\n            url:\"http://www.ai.com\"\n          },\n          {\n            text:\"webView button\",\n            type:'webView',\n            url:\"http://www.ai.com\"\n          },\n        ],\n        [\n          {\n            text:\"requestPoll button\",\n            type:'requestPoll',\n            isQuiz:true\n          },\n          {\n            text:\"switchBotInline button\",\n            type:'switchBotInline',\n            query: \"\",\n            isSamePeer: false\n          },\n          {\n            text:\"userProfile button\",\n            type:'userProfile',\n            userId: UserIdFirstBot,\n          },\n        ],\n        [\n          {\n            text:\"requestUploadImage button\",\n            type:'requestUploadImage',\n          },\n        ]\n      ],\n      senderId:this.msgDispatcher.getChatId()\n    });\n    await this.msgDispatcher.focusLastMessage()\n  }\n}\n","import MsgDispatcher from \"./MsgDispatcher\";\nimport {currentTs} from \"../share/utils/utils\";\nimport {ApiBotInfo, ApiMessage} from \"../../api/types\";\nimport {GlobalState} from \"../../global/types\";\nimport {getGlobal, setGlobal} from \"../../global\";\nimport {selectUser} from \"../../global/selectors\";\nimport {updateUser} from \"../../global/reducers\";\nimport {DEFAULT_PROMPT} from \"../setting\";\n\nexport default class MsgCommandChatGpt{\n  private chatId: string;\n  private botInfo: ApiBotInfo;\n  constructor(chatId:string,botInfo:ApiBotInfo) {\n    this.chatId = chatId\n    this.botInfo = botInfo;\n  }\n  async start(){\n    const messageId = await MsgDispatcher.genMsgId();\n    const {chatId} = this\n    const message = {\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:\"welcome\"\n        }\n      },\n    }\n    MsgDispatcher.newMessage(chatId,messageId,message)\n    return message\n  }\n  async initPrompt(){\n    const messageId = await MsgDispatcher.genMsgId();\n    const {chatId} = this\n    const init_system_content = this.botInfo.aiBot?.chatGptConfig?.init_system_content || DEFAULT_PROMPT\n    const message:ApiMessage = {\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:`当前 上下文 prompt:\\n ${init_system_content?init_system_content:\"未设置\"}`\n        }\n      },\n      inlineButtons:[\n        [\n          {\n            text:\"点击修改\",\n            type:\"callback\",\n            data:`${chatId}/init_system_content`\n          }\n        ]\n      ]\n    }\n    MsgDispatcher.newMessage(chatId,messageId,message)\n    return message\n  }\n  async apiKey(){\n    const messageId = await MsgDispatcher.genMsgId();\n    const {chatId} = this\n    const api_key = this.botInfo.aiBot?.chatGptConfig?.api_key\n    const message:ApiMessage = {\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:`当前apiKey:\\n ${api_key?api_key:\"未设置\"}`\n        }\n      },\n      inlineButtons:[\n        [\n          {\n            text:\"点击修改\",\n            type:\"callback\",\n            data:`${chatId}/apiKey`\n          }\n        ]\n      ]\n    }\n    MsgDispatcher.newMessage(chatId,messageId,message)\n    return message\n  }\n  async aiModel(){\n    const messageId = await MsgDispatcher.genMsgId();\n    const {chatId} = this\n    const model = this.botInfo.aiBot?.chatGptConfig?.config?.model\n    const message:ApiMessage = {\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:`当前模型:【${model}】`\n        }\n      },\n    }\n    MsgDispatcher.newMessage(chatId,messageId,message)\n    return message\n  }\n  async enableAi(){\n    const messageId = await MsgDispatcher.genMsgId();\n    const {chatId} = this\n    const isEnable = !!this.botInfo.aiBot?.enableAi\n    const message:ApiMessage = {\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:`当前状态:【${isEnable ? \"开启\" : \"关闭\"}】，修改请点击下面按钮:`\n        }\n      },\n      inlineButtons:[\n        [\n          {\n            text:isEnable ? \"关闭\" : \"开启\",\n            type:\"callback\",\n            data:`${chatId}/enableAi/${isEnable ? \"0\":\"1\"}`\n          }\n        ]\n      ]\n    }\n    MsgDispatcher.newMessage(chatId,messageId,message)\n    return message\n  }\n  static async answerCallbackButton(global:GlobalState,chatId:string,messageId:number,data:string){\n    switch (data){\n      case `${chatId}/init_system_content`:\n        const init_system_content = prompt(\"请输入\")\n        if(init_system_content){\n          global = getGlobal();\n          const user = selectUser(global,chatId);\n          global = updateUser(global,chatId,{\n            ...user,\n            fullInfo:{\n              ...user?.fullInfo,\n              botInfo:{\n                ...user?.fullInfo?.botInfo,\n                aiBot:{\n                  ...user?.fullInfo?.botInfo?.aiBot,\n                  chatGptConfig:{\n                    ...user?.fullInfo?.botInfo?.aiBot?.chatGptConfig,\n                    init_system_content\n                  }\n                }\n              }\n            }\n          })\n          setGlobal(global)\n\n          const message1 = {\n            content:{\n              text:{\n                text:`当前 上下文 prompt:\\n ${init_system_content?init_system_content:\"未设置\"}`\n              }\n            },\n            inlineButtons:[\n              [\n                {\n                  text:\"点击修改\",\n                  type:\"callback\",\n                  data:`${chatId}/apiKey`\n                }\n              ]\n            ]\n          }\n          MsgDispatcher.newMessage(chatId,messageId,message1)\n        }\n        break;\n      case `${chatId}/apiKey`:\n        const api_key = prompt(\"请输入\")\n        if(api_key){\n          global = getGlobal();\n          const user = selectUser(global,chatId);\n          global = updateUser(global,chatId,{\n            ...user,\n            fullInfo:{\n              ...user?.fullInfo,\n              botInfo:{\n                ...user?.fullInfo?.botInfo,\n                aiBot:{\n                  ...user?.fullInfo?.botInfo?.aiBot,\n                  chatGptConfig:{\n                    ...user?.fullInfo?.botInfo?.aiBot?.chatGptConfig,\n                    api_key\n                  }\n                }\n              }\n            }\n          })\n          setGlobal(global)\n          const message2 = {\n            content:{\n              text:{\n                text:`当前apiKey:\\n ${api_key?api_key:\"未设置\"}`\n              }\n            },\n            inlineButtons:[\n              [\n                {\n                  text:\"点击修改\",\n                  type:\"callback\",\n                  data:`${chatId}/apiKey`\n                }\n              ]\n            ]\n          }\n          MsgDispatcher.newMessage(chatId,messageId,message2)\n        }\n\n        break;\n      case `${chatId}/enableAi/0`:\n      case `${chatId}/enableAi/1`:\n        const isEnable = data === `${chatId}/enableAi/1`;\n        global = getGlobal();\n        const user = selectUser(global,chatId);\n        global = updateUser(global,chatId,{\n          ...user,\n          fullInfo:{\n            ...user?.fullInfo,\n            botInfo:{\n              ...user?.fullInfo?.botInfo,\n              aiBot:{\n                ...user?.fullInfo?.botInfo?.aiBot,\n                enableAi:isEnable\n              }\n            }\n          }\n        })\n        setGlobal(global)\n        MsgDispatcher.updateMessage(chatId,messageId,{\n          content:{\n            text:{\n              text:`当前状态:【${isEnable ? \"开启\" : \"关闭\"}】，修改请点击下面按钮:`\n            }\n          },\n          inlineButtons:[\n            [\n              {\n                text:isEnable ? \"关闭\" : \"开启\",\n                type:\"callback\",\n                data:`${chatId}/enableAi/${isEnable ? \"0\":\"1\"}`\n              }\n            ]\n          ]\n        })\n        break\n    }\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { SyncReq_Type } from './types';\n\nexport default class SyncReq extends BaseMsg {\n  public msg?: SyncReq_Type\n  constructor(msg?: SyncReq_Type) {\n    super('PTP.Sync.SyncReq', msg);\n    this.setCommandId(ActionCommands.CID_SyncReq);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): SyncReq_Type {\n    return new SyncReq().decode(pdu.body());\n  }\n}\n","import BaseMsg from '../BaseMsg';\nimport { ActionCommands } from '../ActionCommands';\nimport type { Pdu } from '../BaseMsg';\nimport type { SyncRes_Type } from './types';\n\nexport default class SyncRes extends BaseMsg {\n  public msg?: SyncRes_Type\n  constructor(msg?: SyncRes_Type) {\n    super('PTP.Sync.SyncRes', msg);\n    this.setCommandId(ActionCommands.CID_SyncRes);\n    this.msg = msg;\n  }\n  static parseMsg(pdu : Pdu): SyncRes_Type {\n    return new SyncRes().decode(pdu.body());\n  }\n}\n","import MsgDispatcher from \"./MsgDispatcher\";\nimport {selectChatMessage, selectChatMessages, selectUser} from \"../../global/selectors\";\nimport {addChats, addUsers, updateUser} from \"../../global/reducers\";\nimport {UserIdFirstBot} from \"../setting\";\nimport {getActions, getGlobal, setGlobal} from \"../../global\";\nimport {ApiKeyboardButtons, ApiUser} from \"../../api/types\";\nimport {callApiWithPdu} from \"./utils\";\nimport {currentTs} from \"../share/utils/utils\";\nimport {MessageStoreRow_Type, UserStoreData_Type, UserStoreRow_Type} from \"../../lib/ptp/protobuf/PTPCommon/types\";\nimport {DownloadMsgReq, DownloadMsgRes, UploadMsgReq} from \"../../lib/ptp/protobuf/PTPMsg\";\nimport {DownloadUserReq, DownloadUserRes, UploadUserReq} from \"../../lib/ptp/protobuf/PTPUser\";\nimport Mnemonic from \"../../lib/ptp/wallet/Mnemonic\";\nimport Account from \"../share/Account\";\nimport {AuthNativeReq} from \"../../lib/ptp/protobuf/PTPAuth\";\nimport {GlobalState} from \"../../global/types\";\nimport {getPasswordFromEvent} from \"../share/utils/password\";\nimport {hashSha256} from \"../share/utils/helpers\";\nimport {SyncReq, SyncRes} from \"../../lib/ptp/protobuf/PTPSync\";\nimport MsgCommand from \"./MsgCommand\";\n\nlet currentSyncBotContext:string|undefined;\n\nexport default class MsgCommandSetting{\n  static async setting(chatId:string){\n    const account = Account.getCurrentAccount();\n    const isEnableSync = account?.getSession();\n    const messageId = await MsgDispatcher.genMsgId();\n    MsgDispatcher.newMessage(chatId,messageId,{\n      chatId,\n      id:messageId,\n      senderId:chatId,\n      isOutgoing:false,\n      date:currentTs(),\n      content:{\n        text:{\n          text:\"设置面板\"\n        }\n      },\n      inlineButtons:MsgCommandSetting.getInlineButtons(chatId,!!isEnableSync),\n    })\n  }\n  static getInlineButtons(chatId:string,isEnableSync:boolean):ApiKeyboardButtons{\n    return isEnableSync ? [\n      [\n        {\n          data:`${chatId}/setting/uploadFolder`,\n          text:\"上传对话\",\n          type:\"callback\"\n        },\n        {\n          data:`${chatId}/setting/downloadFolder`,\n          text:\"下载对话\",\n          type:\"callback\"\n        },\n      ],\n      [\n        {\n          data:`${chatId}/setting/uploadMessages`,\n          text:\"上传消息\",\n          type:\"callback\"\n        },\n        {\n          data:`${chatId}/setting/downloadMessages`,\n          text:\"下载消息\",\n          type:\"callback\"\n        },\n      ],\n\n      [\n        {\n          data:`${chatId}/setting/getSession`,\n          text:\"获取session\",\n          type:\"callback\"\n        },\n      ],\n      [\n        {\n          data:`${chatId}/setting/showMnemonic`,\n          text:\"showMnemonic\",\n          type:\"callback\"\n        },\n        {\n          data:`${chatId}/setting/setMnemonic`,\n          text:\"setMnemonic\",\n          type:\"callback\"\n        },\n      ],\n      [\n        {\n          data:`${chatId}/setting/disableSync`,\n          text:\"关闭同步\",\n          type:\"callback\"\n        },\n        {\n          data:`${chatId}/setting/cancel`,\n          text:\"取消\",\n          type:\"callback\"\n        },\n      ],\n    ]:[\n      [\n        {\n          data:`${chatId}/setting/enableSync`,\n          text:\"开启同步\",\n          type:\"callback\"\n        },\n        {\n          data:`${chatId}/setting/cancel`,\n          text:\"取消\",\n          type:\"callback\"\n        },\n      ],\n    ]\n  }\n  static async answerCallbackButton(global:GlobalState,chatId:string,messageId:number,data:string){\n    switch (data){\n      case `${chatId}/setting/getSession`:\n        const account = Account.getCurrentAccount();\n        const entropy = await account?.getEntropy();\n        const mnemonic = Mnemonic.fromEntropy(entropy!)\n        await MsgCommand.sendText(chatId,account?.getSession()!)\n        await MsgCommand.sendText(chatId,entropy!)\n        await MsgCommand.sendText(chatId,mnemonic.getWords())\n        break\n\n      case `${chatId}/setting/setMnemonic`:\n        const res = prompt(\"setMnemonic\")\n        if(res){\n          const mnemonic = new Mnemonic(res)\n          if(mnemonic.checkMnemonic()){\n            await MsgCommand.sendText(chatId,mnemonic.toEntropy())\n            const {password} = await getPasswordFromEvent()\n            if(password){\n              const entropy = mnemonic.toEntropy();\n              let accountId = Account.getAccountIdByEntropy(entropy);\n              if(!accountId){\n                accountId = Account.genAccountId()\n              }\n              const account = Account.getInstance(accountId);\n              Account.setCurrentAccountId(accountId);\n              await account?.setEntropy(entropy,true)\n              const pwd = hashSha256(password)\n              const ts = +(new Date());\n              const {address, sign} = await account!.signMessage(ts.toString(), pwd);\n              const session = Account.formatSession({address,sign,ts});\n              account!.saveSession(session)\n              await callApiWithPdu(new AuthNativeReq({\n                accountId,entropy:mnemonic.toEntropy(),session\n              }).pack())\n              await MsgCommand.sendText(chatId,session)\n              window.location.reload()\n            }\n          }else{\n            await MsgCommand.sendText(chatId,\"mnemonic 不合法\")\n          }\n        }\n        break\n      case `${chatId}/setting/uploadFolder`:\n        await MsgCommandSetting.syncFolders(true)\n        break\n      case `${chatId}/setting/downloadFolder`:\n        await MsgCommandSetting.syncFolders(false)\n        break\n      case `${chatId}/setting/syncMessage`:\n        getActions().updateGlobal({\n          showPickBotModal:true\n        })\n        break\n      case `${chatId}/setting/uploadMessages`:\n      case `${chatId}/setting/downloadMessages`:\n        currentSyncBotContext = data;\n        getActions().updateGlobal({\n          showPickBotModal:true\n        })\n        break\n      case `${chatId}/setting/showMnemonic`:\n        getActions().updateGlobal({\n          showMnemonicModal:true\n        })\n        break\n      case `${chatId}/setting/cancel`:\n        MsgDispatcher.updateMessage(chatId,messageId,{\n          inlineButtons:[],\n        })\n        break\n      case `${chatId}/setting/disableSync`:\n        await MsgCommandSetting.disableSync(global,chatId,messageId)\n        break\n      case `${chatId}/setting/enableSync`:\n        const {password} = await getPasswordFromEvent()\n        if(!password){\n          MsgDispatcher.updateMessage(chatId,messageId,{\n            inlineButtons:[],\n          })\n        }\n        await MsgCommandSetting.enableSync(global,chatId,messageId,password)\n        break\n    }\n  }\n  static buildDefaultChat(user:ApiUser){\n    return {\n      \"id\": user.id,\n      \"title\":  user.firstName,\n      \"type\": \"chatTypePrivate\",\n      \"isMuted\": false,\n      \"isMin\": false,\n      \"hasPrivateLink\": false,\n      \"isSignaturesShown\": false,\n      \"isVerified\": true,\n      \"isJoinToSend\": true,\n      \"isJoinRequest\": true,\n      lastMessage:{\n        id:0,\n        chatId:user.id,\n        isOutgoing:false,\n        date:Math.ceil(+(new Date)/1000),\n        content:{\n          action:{\n            type:\"chatCreate\",\n            text:\"\",\n          }\n        }\n      },\n      \"isForum\": false,\n      \"isListed\": true,\n      \"settings\": {\n        \"isAutoArchived\": false,\n        \"canReportSpam\": false,\n        \"canAddContact\": false,\n        \"canBlockContact\": false\n      },\n      \"accessHash\": \"\"\n    }\n  }\n  static async syncFolders(isUpload:boolean){\n    let global = getGlobal();\n    const chats = global.chats.byId\n    const chatIds = Object.keys(chats).filter(id=>id !== \"1\");\n    const chatIdsDeleted:string[] = global.chatIdsDeleted;\n    console.log(\"local\",{chatIds,chatIdsDeleted})\n    const userStoreData:UserStoreData_Type|undefined = isUpload ?{\n      time:currentTs(),\n      chatFolders:JSON.stringify(global.chatFolders),\n      chatIds,\n      chatIdsDeleted\n    } :undefined\n\n    const res = await callApiWithPdu(new SyncReq({\n      userStoreData\n    }).pack())\n    const syncRes = SyncRes.parseMsg(res!.pdu)\n    let users:UserStoreRow_Type[] = [];\n    if(isUpload){\n      for (let index = 0; index < chatIds.length; index++) {\n        const userId = chatIds[index];\n        users.push({\n          time:currentTs(),\n          userId,\n          user:selectUser(global,userId)\n        })\n      }\n      await callApiWithPdu(new UploadUserReq({\n        users,\n        time:currentTs()\n      }).pack())\n    }\n\n    if(syncRes.userStoreData){\n      const {chatFolders,...res} = syncRes.userStoreData\n      res.chatIdsDeleted?.forEach(id=>{\n        if(!chatIdsDeleted.includes(id)){\n          chatIdsDeleted.push(id)\n        }\n      })\n      console.log(\"remote\",res)\n      if(res.chatIds){\n        const DownloadUserReqRes = await callApiWithPdu(new DownloadUserReq({\n          userIds:res.chatIds,\n        }).pack())\n        if(DownloadUserReqRes){\n          const downloadUserRes = DownloadUserRes.parseMsg(DownloadUserReqRes?.pdu!)\n          console.log(\"downloadUserRes\",downloadUserRes)\n          global = getGlobal();\n          if(downloadUserRes.users){\n            const addUsersObj = {}\n            const addChatsObj = {}\n            for (let index = 0; index < downloadUserRes.users.length; index++) {\n              const {user} = downloadUserRes.users[index];\n              if(!chatIdsDeleted.includes(user!.id)){\n                if(chatIds.includes(user!.id)){\n                  // @ts-ignore\n                  global = updateUser(global,user!.id, user!)\n                }else{\n                  // @ts-ignore\n                  addUsersObj[user!.id] = user!\n                  // @ts-ignore\n                  addChatsObj[user!.id] = MsgCommandSetting.buildDefaultChat(user!)\n                }\n                if(Object.keys(addUsersObj).length > 0){\n                  global = addUsers(global,addUsersObj)\n                  global = addChats(global,addChatsObj)\n                }\n              }\n            }\n          }\n          setGlobal({\n            ...global,\n            chatIdsDeleted:chatIdsDeleted || [],\n            chatFolders:JSON.parse(chatFolders)\n          })\n        }\n      }else{\n        getActions().updateGlobal({\n          chatIdsDeleted:chatIdsDeleted || [],\n          chatFolders:JSON.parse(chatFolders)\n        })\n      }\n    }\n    getActions().showNotification({message:\"更新成功\"})\n  }\n  static async enableSync(global:GlobalState,chatId:string,messageId:number,password:string){\n    const account = Account.getCurrentAccount();\n    const pwd = hashSha256(password)\n    const ts = +(new Date());\n    const {address, sign} = await account!.signMessage(ts.toString(), pwd);\n    const session = Account.formatSession({address,sign,ts});\n    account!.saveSession(session)\n    const entropy = await account!.getEntropy()\n    const accountId = account!.getAccountId();\n    await callApiWithPdu(new AuthNativeReq({\n      accountId,entropy,session\n    }).pack())\n    MsgDispatcher.updateMessage(chatId,messageId,{\n      inlineButtons:[]\n    })\n    getActions().showNotification({message:\"开启成功\"})\n    setTimeout(()=>window.location.reload(),500)\n  }\n\n  static async disableSync(global:GlobalState,chatId:string,messageId:number){\n    const account = Account.getCurrentAccount();\n    account?.delSession();\n    MsgDispatcher.updateMessage(chatId,messageId,{\n      inlineButtons:[]\n    })\n    await callApiWithPdu(new AuthNativeReq({\n      accountId:account!.getAccountId(),\n      entropy:await account!.getEntropy(),\n      session:undefined\n    }).pack())\n    getActions().showNotification({message:\"关闭成功\"})\n    setTimeout(()=>window.location.reload(),500)\n  }\n\n  static async onSelectSyncBot(chatId:string){\n    const data = currentSyncBotContext;\n    const isUpload = !data?.endsWith(\"downloadMessages\");\n    currentSyncBotContext = undefined\n    await MsgCommand.sendText(UserIdFirstBot,data!)\n    let global = getGlobal();\n    if(isUpload){\n      const messageById = selectChatMessages(global,chatId);\n      const messages:MessageStoreRow_Type[] = [];\n      if(messageById){\n        for (let i = 0; i < Object.keys(messageById).length; i++) {\n          const msgId = parseInt(Object.keys(messageById)[i])\n          messages.push({\n            time:currentTs(),\n            message:messageById[msgId],\n            messageId:msgId,\n          })\n        }\n      }\n      if(messages.length > 0){\n        const res = await callApiWithPdu(new UploadMsgReq({\n          messages,\n          chatId,\n          time:currentTs(),\n        }).pack())\n        if(!res){\n          getActions().showNotification({message:\"更新失败\"})\n        }\n      }\n    }else{\n      const res = await callApiWithPdu(new DownloadMsgReq({\n        chatId,\n      }).pack())\n      if(res){\n        const {err,messages} = DownloadMsgRes.parseMsg(res?.pdu)\n        console.log(\"messages\",messages)\n        if(messages){\n          for (let i = 0; i < messages?.length; i++) {\n            const {message,messageId} = messages[i]\n            const localMsg = selectChatMessage(global,chatId,messageId)\n            if(!localMsg){\n              // @ts-ignore\n              MsgDispatcher.newMessage(chatId,messageId,message)\n            }else{\n              // @ts-ignore\n              MsgDispatcher.updateMessage(chatId,messageId,message)\n            }\n          }\n        }\n\n      }else{\n        getActions().showNotification({message:\"更新失败\"})\n      }\n    }\n  }\n}\n","import {\n  ApiAttachment, ApiBotInfo,\n  ApiChat,\n  ApiFormattedText,\n  ApiKeyboardButtons,\n  ApiMessage,\n  ApiMessageEntity,\n  ApiNewPoll,\n  ApiSticker,\n  ApiUser,\n  ApiVideo\n} from \"../../api/types\";\nimport {GlobalState} from \"../../global/types\";\nimport {getActions} from \"../../global\";\nimport {callApiWithPdu} from \"./utils\";\nimport {currentTs} from \"../share/utils/utils\";\nimport {GenMsgIdReq, GenMsgIdRes} from \"../../lib/ptp/protobuf/PTPMsg\";\nimport MsgCommand from \"./MsgCommand\";\nimport {parseCodeBlock} from \"../share/utils/stringParse\";\nimport MsgWorker from \"./MsgWorker\";\nimport {UserIdFirstBot} from \"../setting\";\nimport MsgCommandChatGpt from \"./MsgCommandChatGpt\";\n\nexport type ParamsType = {\n  chat: ApiChat;\n  text?: string;\n  entities?: ApiMessageEntity[];\n  replyingTo?: number;\n  attachment?: ApiAttachment;\n  sticker?: ApiSticker;\n  gif?: ApiVideo;\n  poll?: ApiNewPoll;\n  isSilent?: boolean;\n  scheduledAt?: number;\n  sendAs?: ApiChat | ApiUser;\n  replyingToTopId?: number;\n  groupedId?: string;\n  botInfo?: ApiBotInfo\n}\nexport type OptionsType = {\n  senderId?:string,\n  inlineButtons?:ApiKeyboardButtons\n  isLocalMessageId?:boolean,\n}\n\nexport default class MsgDispatcher {\n  private params: ParamsType;\n  private global: GlobalState;\n  private msgCommand: MsgCommand;\n  constructor(global:GlobalState,params: ParamsType) {\n    this.global = global;\n    this.params = params;\n    this.msgCommand = new MsgCommand(this)\n  }\n\n  static apiUpdate(update:any){\n    const {apiUpdate} = getActions()\n    apiUpdate(update)\n  }\n  getMsgSenderAsId(){\n    return this.params.sendAs?.id;\n  }\n  getMsgText(){\n    return this.params.text;\n  }\n\n  getChatId(){\n    return this.params.chat.id;\n  }\n  genMsgDate(){\n    return Math.ceil(+(new Date())/1000);\n  }\n\n  static async genMsgId(isLocal?:boolean){\n    // @ts-ignore\n    const {pdu} = await callApiWithPdu(new GenMsgIdReq({isLocal:!!isLocal}).pack())\n    const {messageId} = GenMsgIdRes.parseMsg(pdu)\n    return messageId\n  }\n\n  updateMessageSendSucceeded(localId:number,message:ApiMessage){\n    MsgDispatcher.apiUpdate({\n      '@type': \"updateMessageSendSucceeded\",\n      localId,\n      chatId: this.params.chat.id,\n      message: message\n    });\n  }\n  updateMessageText(id:number,{text}:{text: any},message:ApiMessage){\n    this.updateMessage(id,{\n      ...message,\n      content:{\n        ...message.content,\n        text: {\n          ...message.content.text,\n          text\n        }\n      }\n    })\n  }\n  updateMessage(id:number,message:Partial<ApiMessage>){\n    return MsgDispatcher.updateMessage(this.getChatId(),id,message)\n  }\n  static updateMessage(chatId:string,messageId:number,message:Partial<ApiMessage>){\n    MsgDispatcher.apiUpdate({\n        '@type': \"updateMessage\",\n        id: messageId,\n        chatId,\n        message,\n      });\n    return message\n  }\n  static newMessage(chatId:string,messageId:number,message:ApiMessage){\n    MsgDispatcher.apiUpdate({\n      '@type': \"newMessage\",\n      chatId,\n      id:messageId,\n      message,\n      shouldForceReply:false\n    });\n    return message\n  }\n  async sendNewMessage(content:{text?:ApiFormattedText},options:OptionsType){\n    const {isLocalMessageId,senderId,inlineButtons} = options || {}\n    const id = await MsgDispatcher.genMsgId(!!isLocalMessageId)\n    const message = {\n      id,\n      content,\n      inlineButtons,\n      chatId: this.getChatId(),\n      date: this.genMsgDate(),\n      senderId:this.getMsgSenderAsId(),\n      isOutgoing:(senderId || this.getMsgSenderAsId()) !== this.getChatId(),\n      sendingState: undefined\n    }\n    if(this.params.botInfo){\n      MsgWorker.handleBotCmdText(message,this.params.botInfo)\n    }\n    return MsgDispatcher.newMessage(this.getChatId(),id,message)\n  }\n  async sendNewTextMessage({text,options}:{text?:string,options?:OptionsType}){\n    const res = parseCodeBlock(text!)\n    // @ts-ignore\n    return await this.sendNewMessage({text:res!,},options)\n  }\n\n  async replyText(text:string){\n    return await this.replyNewTextMessage({text})\n  }\n\n  async replyCode(text:string){\n    return await this.replyNewTextMessage({text:\"```\\n\"+text+\"```\"})\n  }\n\n  async replyNewTextMessage({text,options}:{text?:string,options?:OptionsType}){\n    this.focusLastMessage(200)\n    return await this.sendNewTextMessage({text,options:{\n      ...options,\n        senderId:this.getChatId()\n      }})\n\n  }\n  async sendOutgoingMsg(){\n    this.focusLastMessage(100)\n    return await this.sendNewTextMessage({\n      text:this.getMsgText(),\n    })\n  }\n  static buildMsgHistoryClear(chatId:string):ApiMessage{\n    return {\n      id: 0,\n      chatId,\n      isOutgoing: false,\n      date: currentTs(),\n      content: {\n        action: {\n          text: \"历史记录已清空\",\n          type: 'historyClear',\n          translationValues:[],\n        }\n      }\n    }\n  }\n  getBotCommands(){\n    const {botInfo} = this.params;\n    if(botInfo && botInfo.commands){\n      const commands: string[] = []\n      botInfo.commands.forEach(cmd=>commands.push(\"/\"+cmd.command))\n      return commands\n    }else{\n      return []\n    }\n  }\n  async processCmd(){\n    let res;\n    const sendMsgText = this.getMsgText();\n    const commands = this.getBotCommands();\n    if(sendMsgText && commands.includes(sendMsgText)){\n      if(this.params.botInfo?.botId === UserIdFirstBot){\n        return await this.processFirstBotCmd();\n      }\n      if(this.params.botInfo?.aiBot?.chatGptConfig){\n        return await this.processAiBotCmd();\n      }\n    }\n\n    return true\n  }\n\n  async processAiBotCmd(){\n    const sendMsgText = this.getMsgText();\n    const msgCommandChatGpt = new MsgCommandChatGpt(this.getChatId(),this.params.botInfo!);\n    await this.sendOutgoingMsg();\n    switch(sendMsgText){\n      case \"/start\":\n        return await msgCommandChatGpt.start();\n      case \"/clearHistory\":\n        return await MsgCommand.clearHistory(this.getChatId());\n      case \"/enableAi\":\n        return await msgCommandChatGpt.enableAi();\n      case \"/aiModel\":\n        return await msgCommandChatGpt.aiModel();\n      case \"/initPrompt\":\n        return await msgCommandChatGpt.initPrompt();\n      case \"/apiKey\":\n        return await msgCommandChatGpt.apiKey();\n      default:\n        return await this.sendOutgoingMsg();\n    }\n  }\n  async processFirstBotCmd(){\n\n    const sendMsgText = this.getMsgText();\n    switch(sendMsgText){\n      case \"/start\":\n        return await this.sendOutgoingMsg();\n      case \"/reloadCommands\":\n        return await this.msgCommand.reloadCommands();\n      case \"/clearHistory\":\n        return await MsgCommand.clearHistory(this.getChatId());\n      case \"/temp\":\n        return await this.msgCommand.temp();\n      case \"/setting\":\n        return await this.msgCommand.setting();\n      default:\n        return await this.sendOutgoingMsg();\n    }\n  }\n  focusLastMessage(delay:number = 500){}\n  async process(){\n    let res;\n    if(this.getMsgText()?.startsWith(\"/\")){\n      res = this.processCmd();\n    }\n    return res\n  }\n}\n","import {callApi} from \"../../api/gramjs\";\nimport {Pdu} from \"../../lib/ptp/protobuf/BaseMsg\";\nexport type CallApiWithPduRes = {\n  pdu:Pdu\n}\nexport async function callApiWithPdu(pdu:Pdu):Promise<undefined|CallApiWithPduRes>{\n  //@ts-ignore\n  const buf = await callApi(\"sendWithCallback\",Buffer.from(pdu.getPbData()))\n  if(buf){\n    return {pdu:new Pdu(Buffer.from(buf))}\n  }else{\n    return undefined\n  }\n}\n","\nexport function generateRandomString(length:number) {\n  let result = '';\n  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function sha1(str: string): string {\n  function utf8_encode(str: string): string {\n    str = str.replace(/\\r\\n/g, '\\n');\n    let utf8str = '';\n    for (let n = 0; n < str.length; n++) {\n      let c = str.charCodeAt(n);\n      if (c < 128) {\n        utf8str += String.fromCharCode(c);\n      } else if ((c > 127) && (c < 2048)) {\n        utf8str += String.fromCharCode((c >> 6) | 192);\n        utf8str += String.fromCharCode((c & 63) | 128);\n      } else {\n        utf8str += String.fromCharCode((c >> 12) | 224);\n        utf8str += String.fromCharCode(((c >> 6) & 63) | 128);\n        utf8str += String.fromCharCode((c & 63) | 128);\n      }\n    }\n    return utf8str;\n  }\n\n  function rotate_left(n: number, s: number): number {\n    return (n << s) | (n >>> (32 - s));\n  }\n\n  function cvt_hex(val: number): string {\n    let str = '';\n    let i;\n    let v;\n    for (i = 7; i >= 0; i--) {\n      v = (val >>> (i * 4)) & 0x0f;\n      str += v.toString(16);\n    }\n    return str;\n  }\n\n  let blockstart;\n\n  let i: number, j: number;\n\n  let W = new Array(80);\n\n  let H0 = 0x67452301;\n  let H1 = 0xEFCDAB89;\n  let H2 = 0x98BADCFE;\n  let H3 = 0x10325476;\n  let H4 = 0xC3D2E1F0;\n\n  let A, B, C, D, E;\n\n  let temp;\n\n  str = utf8_encode(str);\n\n  let len = str.length * 8;\n\n  let K = new Array(\n    0x5A827999,\n    0x6ED9EBA1,\n    0x8F1BBCDC,\n    0xCA62C1D6\n  );\n\n  let str_len = str.length;\n\n  let word_array = new Array();\n\n  for (i = 0; i < str_len - 3; i += 4) {\n    j =\n      (str.charCodeAt(i) << 24) |\n      (str.charCodeAt(i + 1) << 16) |\n      (str.charCodeAt(i + 2) << 8) |\n      str.charCodeAt(i + 3);\n    word_array.push(j);\n  }\n\n  switch (str_len % 4) {\n    case 0:\n      i = 0x080000000;\n      break;\n    case 1:\n      i = (str.charCodeAt(str_len - 1) << 24) | 0x0800000;\n      break;\n\n    case 2:\n      i =\n        (str.charCodeAt(str_len - 2) << 24) |\n        (str.charCodeAt(str_len - 1) << 16) |\n        0x08000;\n      break;\n\n    case 3:\n      i =\n        (str.charCodeAt(str_len - 3) << 24) |\n        (str.charCodeAt(str_len - 2) << 16) |\n        (str.charCodeAt(str_len - 1) << 8) |\n        0x80;\n      break;\n  }\n\n  word_array.push(i);\n\n  while (word_array.length % 16 != 14) word_array.push(0);\n\n  word_array.push(len >>> 32);\n  word_array.push(len & 0xffffffff);\n\n  for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {\n    for (i = 0; i < 16; i++) W[i] = word_array[blockstart + i];\n    for (i = 16; i < 80; i++)\n      W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n    A = H0;\n    B = H1;\n    C = H2;\n    D = H3;\n    E = H4;\n\n    for (i = 0; i < 20; i++) {\n      temp =\n        (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + K[0]) &\n        0xffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    for (i = 20; i < 40; i++) {\n      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + K[1]) & 0xffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    for (i = 40; i < 60; i++) {\n      temp =\n        (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + K[2]) &\n        0xffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    for (i = 60; i < 80; i++) {\n      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + K[3]) & 0xffffffff;\n      E = D;\n      D = C;\n      C = rotate_left(B, 30);\n      B = A;\n      A = temp;\n    }\n\n    H0 = (H0 + A) & 0xffffffff;\n    H1 = (H1 + B) & 0xffffffff;\n    H2 = (H2 + C) & 0xffffffff;\n    H3 = (H3 + D) & 0xffffffff;\n    H4 = (H4 + E) & 0xffffffff;\n  }\n\n  let result =\n    cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);\n  return result.toLowerCase();\n}\n\nexport function replaceSubstring(text:string, offset:number, length:number,replace:string) {\n  const prefix = text.substring(0, offset);\n  const suffix = text.substring(offset + length);\n  return prefix + replace + suffix;\n\n}\nexport function fetchWithTimeout(url: RequestInfo | URL, options: RequestInit | undefined, timeout = 10000) {\n  return Promise.race([\n    fetch(url, options),\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}s`)), timeout)\n    )\n  ]);\n}\n\nexport const isEmailValid = (email:string)=>{\n  const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return re.test(email);\n}\n\nexport function parseQueryFromUrl(urlStr: string): { url: URL; query: Record<string, string> } {\n  const replacedUrl = urlStr.replace(/#/g, '?');\n  const url = new URL(replacedUrl);\n  const query = Array.from(url.searchParams.entries()).reduce(\n    (acc, [key, value]) => ({\n      ...acc,\n      [key]: value,\n    }),\n    {}\n  );\n\n  return { url, query };\n}\n\n\nexport function getCorsHeader(Access_Control_Allow_Origin: string = '*',ContentType:string = \"application/json;charset=UTF-8\") {\n  return {\n    'content-type': ContentType,\n    'Access-Control-Allow-Origin': Access_Control_Allow_Origin,\n    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization, Accept',\n    'Access-Control-Allow-Credentials': 'true',\n  };\n}\n\nexport function ResponseJson(result: object, status = 200,Access_Control_Allow_Origin: string = '*') {\n  return new Response(JSON.stringify(result), {\n    status,\n    headers: {\n      ...getCorsHeader(Access_Control_Allow_Origin),\n    },\n  });\n}\n\nexport function currentTs(){\n  return Math.ceil(+(new Date)/1000)\n}\n\nexport function currentTs1000(){\n  return Math.ceil(+(new Date))\n}\n"],"names":["omitVirtualClassFields","instance","flags","CONSTRUCTOR_ID","SUBCLASS_OF_ID","className","classType","getBytes","rest","TIMESTAMP_BASE","TIMESTAMP_PRECISION","LOCAL_MESSAGES_LIMIT","localMessageCounter","LOCAL_MESSAGE_MIN_ID","getNextLocalMessageId","datePart","Math","round","Date","now","IS_MULTITAB_SUPPORTED","self","channel","BroadcastChannel","DATA_BROADCAST_CHANNEL_NAME","undefined","batchedUpdates","throttledLocalDbUpdate","throttle","postMessage","type","convertToVirtualClass","value","Uint8Array","Buffer","from","Object","keys","length","BigInt","Array","isArray","map","VirtualClass","split","reduce","acc","field","constructors","valueOmited","key","_initial","initial","valueVirtualClass","acc2","key2","name","Proxy","get","target","prop","Reflect","set","push","Set","GramJsLogger","DEBUG_GRAMJS","SERVICE_NOTIFICATIONS_USER_ID","runThrottledForLoadTopChats","cb","runDebouncedForLoadFullChat","debounce","async","loadChats","global","listType","offsetId","offsetDate","shouldReplace","isFullDraftSync","getGlobal","lastLocalServiceMessage","selectLastServiceNotification","message","result","users","byId","UserIdFirstBot","chats","isFullyLoaded","setGlobal","LoadAllChats","i","chat","messages","byChatId","id","threadsById","lastViewportIds","lastMessage","userStatusesById","forEach","user","chatIds","shift","totalChatCount","chatFoldersById","chatFolders","row","orderedIds","folderIds","msgClientState","tabStates","values","byTabId","visibleChats","flatMap","tabId","currentChat","selectCurrentChat","visibleUsers","selectVisibleUsers","currentUserId","replaceUsers","buildCollectionByKey","concat","replaceUserStatuses","replaceChats","updateChatListIds","addUsers","addUserStatuses","updateChats","replaceChatListIds","newChats","includes","notificationsChat","updateChatListSecondaryInfo","draftsById","chatId","draft","thread","selectThread","MAIN_THREAD_ID","selectDraft","isLocal","replaceThreadParam","replyingToById","e","console","error","loadFullChat","actions","getCurrentTabId","callApi","fullInfo","groupCall","membersCount","existingGroupCall","selectGroupCall","updateGroupCall","omit","participantsCount","updateChat","stickerSet","loadStickers","stickerSetInfo","accessHash","fetchChatByUsername","username","localChat","selectChatByUsername","isMin","updateUser","getAttachBotOrNotify","selectUser","isUserBot","bot","showNotification","langProvider","openAttachMenuFromLink","attach","startAttach","callAttachBot","startParam","ensureIsSuperGroup","selectChat","isChatBasicGroup","newChat","openLimitReachedModal","limit","showDialog","data","hasErrorKey","migrateChat","openChat","addActionHandler","preloadedChatIds","TOP_CHAT_MESSAGES_PRELOAD_LIMIT","pause","currentChatIds","selectCurrentMessageList","filter","Boolean","folderAllOrderedIds","getOrderedIds","ALL_FOLDER_ID","nextChatId","find","has","add","loadViewportMessages","threadId","payload","hasUnreadMark","toggleChatUnread","isChatSummaryOnly","requestThreadInfoUpdate","originChannelId","topMessageId","selectThreadTopMessageId","selectThreadOriginChat","TMP_CHAT_ID","openPreviousChat","chatFullInfo","linkedChatId","messageId","focusMessage","selectSupportChat","shouldReplaceHistory","onReplace","getOrderDate","date","joinDate","DEBUG","listIds","oldestChat","selectIsChatPinned","sort","chat1","chat2","force","lastLocalMessage","isMuted","topicId","updateTopic","title","about","photo","memberIds","createdChannel","updateTabState","chatCreation","progress","ChatCreationProgress","channelId","selectTabState","userId","leaveChat","userIds","a","b","parseInt","isSelf","avatarHash","isPremium","firstName","photos","usernames","bio","DEFAULT_CREATE_USER_BIO","botInfo","aiBot","enableAi","chatGptConfig","init_system_content","api_key","max_history_length","config","ChatModelConfig","botId","commands","DEFAULT_AI_CONFIG_COMMANDS","cmd","MsgCommandSetting","activeChatFolderRow","activeChatFolder","window","sessionStorage","getItem","chatFolderById","includedChatIds","addChats","editChatFolder","folderUpdate","createdChat","folderId","selectCurrentLimit","folder","selectChatFolder","shouldBePinned","pinnedChatIds","newPinnedIds","pinnedId","newIncludedChatIds","selectChatListType","isPinned","ARCHIVED_FOLDER_ID","ids","orderedPinnedIds","isChatArchived","recommendedChatFolders","recommended","idsToRemove","idsToAdd","some","includedId","emoticon","maxId","max","recommendedId","description","newFolder","setActiveChatFolder","unreadCount","lastTopicMessageId","topics","lastMessageId","updateThreadInfo","lastReadInboxMessageId","hash","phoneNumber","localUser","selectUserByPhoneNumber","fetchChatByPhoneNumber","replace","url","openChatByPhoneNumber","openChatByInvite","openStickerSet","openChatWithDraft","joinVoiceChatByLink","openInvoice","processAttachBotParameters","openChatByUsername","openChatByUsernameAction","match","RE_TG_LINK","processDeepLink","uri","URL","toLowerCase","startsWith","TME_WEB_DOMAINS","hostname","pathname","open","toString","hostParts","part1","part2","part3","part","decodeURI","params","fromEntries","searchParams","hasOwnProperty","startattach","choose","parseChooseParameter","substr","shortName","chatOrChannelPostId","Number","commentId","comment","text","formatShareText","inviteHash","voicechat","livestream","slug","substring","start","c","channelPostId","isCurrentChat","startBot","param","usernameChat","threadInfo","selectThreadInfo","chatByUsername","discussionChatId","isEnabled","isPreHistoryHidden","bannedRights","chatAfterUpdate","members","kickedMembers","isBanned","viewMessages","isUnblocked","m","adminRights","customTitle","adminMembersById","isDismissed","newAdminMembersById","remove","updateManagementProgress","ManagementProgress","Promise","all","profilePhoto","loadProfilePhotos","profileId","photosToDelete","nextPhoto","groups","addedById","group","isForum","forDiscussionIds","fullChat","setItem","requestedDraft","offset","addChatMembers","setNewChatMembersDialogState","newChatMembersProgress","NewChatMembersProgress","isProtected","enabledReactions","settings","isChatSuperGroup","isChatChannel","forumPanelChatId","attachMenu","bots","requestedAttachBotInstall","onConfirm","action","requestAttachBotInChat","listedTopicIds","topicsCount","offsetTopic","el","topic","accTopic","offsetTopicId","TOPICS_SLICE","TOPICS_SLICE_SECOND_LOAD","addMessages","updateTopics","count","updateListedTopicIds","entries","formattedText","replyingToId","readInboxMessageIdByTopicId","shouldCloseChatOnError","prevIsForum","prevIsEnabled","areParticipantsHidden","iconColor","iconEmojiId","createTopicPanel","isLoading","closeCreateTopicPanel","deleteTopic","editTopicPanel","closeEditTopicPanel","topicsPinnedLimit","appConfig","silentSound","audioElement","audioContext","sounds","initializeSoundsForSafari","initializeSounds","sound","prevSrc","src","muted","volume","play","then","currentTime","requestAnimationFrame","joinAudio","Audio","connectingAudio","loop","leaveAudio","allowTalkAudio","busyAudio","connectAudio","endAudio","incomingAudio","ringingAudio","join","allowTalk","leave","connecting","incoming","end","connect","busy","ringing","fetchGroupCall","call","isLoaded","fetchGroupCallParticipants","nextOffset","isCallPanelVisible","subscribed","peer","requestMasterAndJoinGroupCall","selectActiveGroupCall","hasPublicUsername","getMainUsername","inviteLink","canSelfUnmute","copyTextToClipboard","full","requestMasterAndCallAction","ARE_CALLS_SUPPORTED","phoneCall","toggleGroupCallPanel","ctx","AudioContext","webkitAudioContext","srcObject","silence","safePlay","createAudioElement","checkNavigatorUserMediaPermissions","groupCalls","activeGroupCallId","selectChatGroupCall","leaveGroupCall","rejoin","isVideo","state","participantId","adminId","oscillator","createOscillator","dst","createMediaStreamDestination","MediaStream","assign","stream","getAudioTracks","enabled","getGroupCallAudioElement","getGroupCallAudioContext","removeGroupCallAudioElement","navigator","mediaDevices","getUserMedia","video","getVideoTracks","checkMicrophonePermission","catch","audio","groupCallId","groupCallUpdate","addToParticipantCount","resetParticipantCount","participants","isLeft","removeGroupCall","updateActiveGroupCall","updateGroupCallParticipant","participantUpdate","noUpdateCount","KB_TO_BYTES","LARGE_FILE_THRESHOLD","DISCONNECT_SLEEP","MAX_CONCURRENT_CONNECTIONS","MAX_CONCURRENT_CONNECTIONS_PREMIUM","foremans","fill","Foreman","uploadFileV1","fileParams","file","onProgress","size","fileIdStr","readBigIntFromBuffer","generateRandomBytes","fileId","String","localDb","isLarge","partSize","getUploadPartSize","partCount","floor","activeCounts","activeWorkers","currentForemanIndex","indexOf","min","promises","senderIndex","requestWorker","isCanceled","releaseWorker","blobSlice","slice","jMemo","blobSliceMemo","CLOUD_MESSAGE_API","Account","getSession","log","partBytes","arrayBuffer","buf","fileInfo","part_total","uploadReq","UploadReq","body","pack","getPbData","fetch","method","headers","Authorization","err","Error","Api","parts","md5Checksum","uploadFile","client","sender","getSender","session","dcId","send","filePart","fileTotalParts","bytes","isConnected","sleep","errors","seconds","RPCError","require","rpcErrorRe","Common","RPCBaseErrors","RPCErrorList","module","exports","RPCMessageToError","rpcError","request","msgRegex","Cls","errorMessage","capture","parseTl","serializeBytes","serializeDate","toSignedLittleBuffer","tlContent","schemeContent","CACHING_SUPPORTED","localStorage","CACHE_KEY","extractParams","fileContent","f","functions","d","isFunction","argToBytes","x","alloc","writeInt32LE","writeDoubleLE","getArgFromReader","reader","arg","isVector","useVectorId","readInt","temp","len","flagIndicator","readLong","readLargeInt","readDouble","tgReadString","tgReadBool","tgReadBytes","tgReadDate","skipConstructorId","tgReadObject","createClasses","classesType","classes","classParams","constructorId","subclassOfId","argsConfig","namespace","fullName","constructor","args","_defineProperty","argName","this","static","isFlag","flagValue","flagGroup","flagIndex","idForBytes","writeUInt32LE","buffers","l","flagCalculate","boxed","charAt","toUpperCase","readResult","definitions","fromCache","jsonCache","JSON","parse","loadFromCache","constructorParamsApi","functionParamsApi","constructorParamsSchema","functionParamsSchema","requests","loadFromTlSchemas","stringify","obj1","obj2","mergeWithNamespaces","buildApiFromTlSchema","ActionCommands","AuthNativeReq","BaseMsg","msg","super","setCommandId","pdu","decode","PbMsg","PbQrCode","PbUser","DownloadMsgReq","DownloadMsgRes","GenMsgIdReq","GenMsgIdRes","UploadMsgReq","DownloadUserReq","MsgCommand","msgDispatcher","MsgDispatcher","senderId","isOutgoing","currentTs","content","chatMessages","setTimeout","sendOutgoingMsg","replyText","getActions","updateGlobal","showMnemonicModal","account","entropy","Mnemonic","toEntropy","setEntropy","accountId","getAccountId","replyCode","password","getPasswordFromEvent","pwd","hashSha256","ts","address","sign","signMessage","saveSession","getEntropy","callApiWithPdu","replyNewTextMessage","getWords","time","UploadUserReq","messageIds","selectChatMessage","getChatId","DEFAULT_BOT_COMMANDS","files","MsgCommandChatGpt","ControllerPool","sendNewMessage","inlineButtons","receiptMessageId","isQuiz","query","isSamePeer","focusLastMessage","DEFAULT_PROMPT","model","isEnable","prompt","message1","message2","SyncReq","SyncRes","currentSyncBotContext","isEnableSync","getInlineButtons","mnemonic","res","checkMnemonic","location","reload","syncFolders","showPickBotModal","disableSync","enableSync","ceil","isUpload","chatIdsDeleted","userStoreData","syncRes","parseMsg","index","DownloadUserReqRes","downloadUserRes","DownloadUserRes","addUsersObj","addChatsObj","buildDefaultChat","delSession","endsWith","messageById","selectChatMessages","msgId","msgCommand","update","apiUpdate","getMsgSenderAsId","sendAs","getMsgText","genMsgDate","updateMessageSendSucceeded","localId","updateMessageText","updateMessage","shouldForceReply","options","isLocalMessageId","genMsgId","sendingState","MsgWorker","newMessage","parseCodeBlock","sendNewTextMessage","translationValues","getBotCommands","command","sendMsgText","processFirstBotCmd","processAiBotCmd","msgCommandChatGpt","aiModel","initPrompt","apiKey","reloadCommands","setting","delay","processCmd","Pdu","replaceSubstring","isEmailValid","email","test","parseQueryFromUrl","urlStr","replacedUrl","currentTs1000"],"sourceRoot":""}